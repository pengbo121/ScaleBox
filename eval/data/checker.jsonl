{"id": 60164, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens between correct answer (stdout_path) and \n  participant's output (answer_path). Returns true only if:\n  1. Both contain identical sequence of tokens\n  2. Both contain same number of tokens\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read correct answer (stdout.txt corresponds to 'ans' in original)\n    vector<string> ans_lines = read_file(stdout_path);\n    // Read participant's output (answer.txt corresponds to 'ouf' in original)\n    vector<string> ouf_lines = read_file(answer_path);\n\n    // Convert answer lines into token sequence\n    vector<string> ans_tokens;\n    for (string& line : ans_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant lines into token sequence\n    vector<string> ouf_tokens;\n    for (string& line : ouf_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Check token count mismatch (EOF condition)\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60173, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validator for the problem that checks if participant's output\n  matches the expected solution according to the problem's rules.\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize all input lines into individual values\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n    if (stdin_tokens.size() < 2) return false;\n    \n    // Parse input data (n, m, edges, permutation)\n    int idx_stdin = 0;\n    int n = stoi(stdin_tokens[idx_stdin++]);\n    int m = stoi(stdin_tokens[idx_stdin++]);\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        if (idx_stdin + 1 >= stdin_tokens.size()) return false;\n        int u = stoi(stdin_tokens[idx_stdin++]);\n        int v = stoi(stdin_tokens[idx_stdin++]);\n        edges.push_back({u, v});\n    }\n    \n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        if (idx_stdin >= stdin_tokens.size()) return false;\n        p[i] = stoi(stdin_tokens[idx_stdin++]);\n    }\n\n    // Parse judge's answer (ja)\n    vector<string> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdout_tokens.push_back(token);\n        }\n    }\n    if (stdout_tokens.empty()) return false;\n    int ja = stoi(stdout_tokens[0]);\n\n    // Parse participant's output (pa and additional edges)\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n    if (participant_tokens.empty()) return false;\n    \n    int idx_participant = 0;\n    int pa = stoi(participant_tokens[idx_participant++]);\n    if (pa != ja) return false;\n\n    vector<pair<int, int>> additional_edges;\n    for (int i = 0; i < pa; ++i) {\n        if (idx_participant + 1 >= participant_tokens.size()) return false;\n        int u = stoi(participant_tokens[idx_participant++]);\n        int v = stoi(participant_tokens[idx_participant++]);\n        \n        // Validate edge constraints\n        if (u < 1 || u > n || v < 1 || v > n) return false;\n        if (u == v) return false;\n        \n        additional_edges.push_back({u, v});\n    }\n\n    // Build graph with original and additional edges\n    vector<vector<int>> g(n + 1);\n    for (auto e : edges) {\n        g[e.first].push_back(e.second);\n        g[e.second].push_back(e.first);\n    }\n    for (auto e : additional_edges) {\n        g[e.first].push_back(e.second);\n        g[e.second].push_back(e.first);\n    }\n\n    // Create index mapping based on permutation\n    vector<int> id(n + 1);\n    for (int i = 0; i < n; ++i) {\n        id[p[i]] = i;\n    }\n\n    // Sort neighbors according to permutation order\n    for (int i = 1; i <= n; ++i) {\n        sort(g[i].begin(), g[i].end(), [&](int u, int v) {\n            return id[u] < id[v];\n        });\n    }\n\n    // Perform DFS in permutation-sorted order\n    vector<int> visited(n + 1, 0);\n    vector<int> pa_p;\n    function<void(int)> dfs = [&](int x) {\n        if (visited[x]) return;\n        visited[x] = true;\n        pa_p.push_back(x);\n        for (int to : g[x]) {\n            dfs(to);\n        }\n    };\n\n    vector<int> order(n);\n    iota(order.begin(), order.end(), 1);\n    sort(order.begin(), order.end(), [&](int u, int v) {\n        return id[u] < id[v];\n    });\n\n    for (int node : order) {\n        if (!visited[node]) {\n            dfs(node);\n        }\n    }\n\n    // Final validation: participant's permutation must match expected\n    return (pa_p == p);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60166, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of integers from correct answer and \n  participant's output. Return true if identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin unused in comparison logic)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse correct answer numbers from stdout_lines\n    vector<long long> correct_nums;\n    for (const string& line : stdout_lines) {\n        if (!line.empty()) {\n            try {\n                correct_nums.push_back(stoll(line));\n            } catch (...) {\n                return false;  // Invalid number format\n            }\n        }\n    }\n\n    // Parse participant's output numbers from participant_lines\n    vector<long long> participant_nums;\n    for (const string& line : participant_lines) {\n        if (!line.empty()) {\n            try {\n                participant_nums.push_back(stoll(line));\n            } catch (...) {\n                return false;  // Invalid number format\n            }\n        }\n    }\n\n    // Compare sequences element-by-element\n    size_t i = 0;\n    while (i < correct_nums.size() && i < participant_nums.size()) {\n        if (correct_nums[i] != participant_nums[i]) {\n            return false;  // Mismatched numbers\n        }\n        ++i;\n    }\n\n    // Check for differing sequence lengths\n    if (correct_nums.size() != participant_nums.size()) {\n        return false;  // One sequence longer than the other\n    }\n\n    return true;  // All elements match and sequences are same length\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60150, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into tokens by splitting on whitespace.\n  Returns a flat vector of all tokens in file order.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing contestant's output (answer.txt) \n  against expected answer (stdout.txt) using input context (stdin.txt).\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Convert lines to tokens for processing\n    vector<string> stdin_tokens = tokenize(stdin_lines);\n    vector<string> ans_tokens   = tokenize(stdout_lines);\n    vector<string> ouf_tokens   = tokenize(participant_lines);\n\n    // Check first token exists and matches between expected and contestant output\n    if (ans_tokens.empty() || ouf_tokens.empty()) \n        return false;\n    if (ans_tokens[0] != ouf_tokens[0]) \n        return false;\n    \n    // Special case: \"NO\" solution requires no further validation\n    if (ans_tokens[0] == \"NO\") \n        return true;\n\n    // Parse input size from stdin\n    if (stdin_tokens.empty()) \n        return false;\n    int n = stoi(stdin_tokens[0]);\n    \n    // Validate sufficient tokens exist in input file\n    if (stdin_tokens.size() < 1 + 2*n) \n        return false;\n    \n    // Extract valid names and nicknames from input\n    set<string> names;\n    for (int i = 1; i <= n; ++i) \n        names.insert(stdin_tokens[i]);\n    \n    set<string> nicknames;\n    for (int i = n+1; i <= 2*n; ++i) \n        nicknames.insert(stdin_tokens[i]);\n    \n    // Validate contestant provided sufficient output tokens\n    if (ouf_tokens.size() < 1 + 2*n) \n        return false;\n    \n    set<string> used_names, used_nicknames;\n    for (int i = 0; i < n; ++i) {\n        string name     = ouf_tokens[1 + 2*i];\n        string nickname = ouf_tokens[1 + 2*i + 1];\n        \n        // Verify name/nickname exist in input\n        if (!names.count(name)) \n            return false;\n        if (!nicknames.count(nickname)) \n            return false;\n        \n        // Track distinctness\n        used_names.insert(name);\n        used_nicknames.insert(nickname);\n        \n        // Check nickname prefix matches name prefix\n        if (name.substr(0, 4) != nickname.substr(0, 4)) \n            return false;\n    }\n    \n    // Ensure all names/nicknames are distinct\n    if (used_names.size() != n || used_nicknames.size() != n)\n        return false;\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60185, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Tokenize a vector of lines into individual tokens by splitting\n  on whitespace. Empty lines are skipped, and each non-empty line\n  is split into its constituent tokens.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing contestant's output against\n  the correct answer using the test input. Implements the core\n  checking logic from the original testlib-based code, adapted to\n  use file-based input streams instead of testlib streams.\n  \n  Returns true if the solution is valid (AC), false otherwise (WA).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files into line vectors\n    vector<string> stdin_lines  = read_file(stdin_path);   // Corresponds to 'inf' (test input)\n    vector<string> stdout_lines = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> answer_lines = read_file(answer_path);  // Corresponds to 'ouf' (contestant output)\n\n    // Convert line vectors into token vectors for easier processing\n    auto stdin_tokens  = tokenize(stdin_lines);\n    auto stdout_tokens = tokenize(stdout_lines);\n    auto answer_tokens = tokenize(answer_lines);\n\n    // Track current token positions for each stream\n    int stdin_idx = 0;\n    int stdout_idx = 0;\n    int answer_idx = 0;\n\n    // Check if we have at least one token for test count\n    if (stdin_tokens.empty()) return false;\n\n    // Read number of test cases (t)\n    int t;\n    try {\n        t = stoi(stdin_tokens[stdin_idx++]);\n    } catch (...) {\n        return false;  // Non-integer token where integer expected\n    }\n\n    for (int i = 0; i < t; ++i) {\n        // Read n for current test case\n        if (stdin_idx >= stdin_tokens.size()) return false;\n        int n;\n        try {\n            n = stoi(stdin_tokens[stdin_idx++]);\n        } catch (...) {\n            return false;\n        }\n\n        // Read vector of pairs (3n elements)\n        vector<pair<int, int>> vec(3 * n + 1);  // 1-indexed up to 3n\n        for (int j = 1; j <= 3 * n; ++j) {\n            if (stdin_idx + 1 >= stdin_tokens.size()) return false;\n            try {\n                int first = stoi(stdin_tokens[stdin_idx++]);\n                int second = stoi(stdin_tokens[stdin_idx++]);\n                vec[j] = {first, second};\n            } catch (...) {\n                return false;\n            }\n        }\n\n        // Read \"Yes\"/\"No\" from correct answer and contestant output\n        if (stdout_idx >= stdout_tokens.size() || answer_idx >= answer_tokens.size()) {\n            return false;\n        }\n        string jury_token = stdout_tokens[stdout_idx++];  // 'ans' stream (correct answer)\n        string ouf_token  = answer_tokens[answer_idx++];  // 'ouf' stream (contestant output)\n\n        // First-level check: both must agree on \"Yes\" or \"No\"\n        if (jury_token != ouf_token) {\n            return false;\n        }\n\n        // If answer is \"Yes\", verify group assignments\n        if (jury_token == \"Yes\") {\n            set<int> used_indices;\n            for (int k = 0; k < n; ++k) {\n                // Read and discard three integers from correct answer (group indices)\n                for (int l = 0; l < 3; ++l) {\n                    if (stdout_idx >= stdout_tokens.size()) return false;\n                    try {\n                        stoi(stdout_tokens[stdout_idx++]);\n                    } catch (...) {\n                        return false;\n                    }\n                }\n\n                // Read three group indices from contestant output\n                vector<int> cur(3);\n                for (int l = 0; l < 3; ++l) {\n                    if (answer_idx >= answer_tokens.size()) return false;\n                    try {\n                        int idx = stoi(answer_tokens[answer_idx++]);\n                        // Verify index is within valid range [1, 3n]\n                        if (idx < 1 || idx > 3 * n) {\n                            return false;\n                        }\n                        cur[l] = idx;\n                        used_indices.insert(idx);\n                    } catch (...) {\n                        return false;\n                    }\n                }\n\n                // Check pairwise charm constraints within the group\n                for (int l = 0; l < 3; ++l) {\n                    for (int m = 0; m < 3; ++m) {\n                        if (l == m) continue;\n                        int a = cur[l];\n                        int b = cur[m];\n                        // Verify charm condition: vec[a].first <= vec[b].second\n                        if (vec[a].first > vec[b].second) {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            // Verify all girls (1..3n) were used exactly once\n            if (static_cast<int>(used_indices.size()) != 3 * n) {\n                return false;\n            }\n        }\n    }\n\n    // Final validation: all tokens must be consumed from all streams\n    if (stdin_idx != stdin_tokens.size() || \n        stdout_idx != stdout_tokens.size() || \n        answer_idx != answer_tokens.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60177, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare correct answer (from stdout.txt) and participant's output (from answer.txt).\n  Both files must contain exactly one integer. Accept if equal, reject otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Verify both files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Convert string representations to integers\n        int ja = stoi(stdout_lines[0]);      // Judge's answer (correct)\n        int pa = stoi(participant_lines[0]); // Participant's answer\n\n        return (ja == pa);\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60165, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to get English ordinal suffix (e.g., 1st, 2nd).\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1:  return \"st\";\n        case 2:  return \"nd\";\n        case 3:  return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Parse all long long numbers from a vector of lines.\n  Each line is split into tokens (whitespace-separated).\n-----------------------------------------------------------*/\nvector<long long> parse_numbers(const vector<string>& lines)\n{\n    vector<long long> numbers;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                // Convert token to long long\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) {\n                    // Partial conversion occurred; skip invalid token\n                    continue;\n                }\n                numbers.push_back(num);\n            } catch (...) {\n                // Conversion error; skip invalid token\n                continue;\n            }\n        }\n    }\n    return numbers;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from answer and output files.\n  Return true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files: stdin_path (input), stdout_path (correct answer), answer_path (participant's output)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse numbers from both files\n    vector<long long> correctNumbers = parse_numbers(stdout_lines);\n    vector<long long> participantNumbers = parse_numbers(participant_lines);\n\n    // Compare sequences element-by-element\n    int n = 0;\n    string firstElems;\n\n    size_t minSize = min(correctNumbers.size(), participantNumbers.size());\n    for (size_t i = 0; i < minSize; ++i) {\n        n = i + 1;  // 1-based index for messages\n        if (correctNumbers[i] != participantNumbers[i]) {\n            // Mismatch found at position n\n            cout << n << englishEnding(n) << \" numbers differ - expected: '\"\n                 << correctNumbers[i] << \"', found: '\"\n                 << participantNumbers[i] << \"'\\n\";\n            return false;\n        }\n        // Collect first 5 numbers for OK message\n        if (n <= 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(correctNumbers[i]);\n        }\n    }\n\n    // Check for extra elements in either file\n    int extraInAnsCount = correctNumbers.size() - minSize;\n    int extraInOufCount = participantNumbers.size() - minSize;\n\n    if (extraInAnsCount > 0) {\n        cout << \"Answer contains longer sequence [length = \" << correctNumbers.size()\n             << \"], but output contains \" << participantNumbers.size() << \" elements\\n\";\n        return false;\n    }\n\n    if (extraInOufCount > 0) {\n        cout << \"Output contains longer sequence [length = \" << participantNumbers.size()\n             << \"], but answer contains \" << correctNumbers.size() << \" elements\\n\";\n        return false;\n    }\n\n    // All checks passed - output success message\n    if (n <= 5) {\n        cout << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60160, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing expected output\n  (stdout.txt) against participant's output (answer.txt) based\n  on test case count from stdin.txt. The first line of stdin.txt\n  specifies the number of test cases (t). The next t lines of\n  stdout.txt and answer.txt are compared as long long integers.\n  Returns true only if all t values match exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Input file must contain at least the test case count\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse test case count from first line of stdin\n        int t = stoi(stdin_lines[0]);\n        if (t < 0) {\n            return false;\n        }\n\n        // Verify sufficient lines in both output files\n        if (stdout_lines.size() < t || participant_lines.size() < t) {\n            return false;\n        }\n\n        // Compare each test case result\n        for (int i = 0; i < t; ++i) {\n            ll expected = stoll(stdout_lines[i]);\n            ll result   = stoll(participant_lines[i]);\n            \n            if (expected != result) {\n                return false;\n            }\n        }\n        return true;\n    }\n    catch (...) {\n        // Handle parsing errors (non-integer values, etc.)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60167, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output against the correct answer\n  using the input to verify constraints and correctness.\n  - stdin_lines: problem input (test cases)\n  - stdout_lines: correct output (expected answers)\n  - participant_lines: contestant's output to verify\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files were read successfully\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of input\n    if (stdin_lines.size() < 1) {\n        return false;\n    }\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    int stdin_idx = 1;      // Current position in stdin_lines (after T)\n    int stdout_idx = 0;     // Current position in stdout_lines (correct answers)\n    int participant_idx = 0; // Current position in participant_lines (contestant's output)\n\n    for (int tc = 0; tc < T; tc++) {\n        // Check available input lines for test case parameters\n        if (stdin_idx >= stdin_lines.size()) {\n            return false;\n        }\n\n        // Parse n, k, m from input line\n        string line = stdin_lines[stdin_idx++];\n        stringstream ss(line);\n        vector<string> tokens;\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n        if (tokens.size() != 3) {\n            return false;\n        }\n\n        int n, k, m;\n        try {\n            n = stoi(tokens[0]);\n            k = stoi(tokens[1]);\n            m = stoi(tokens[2]);\n        } catch (...) {\n            return false;\n        }\n\n        // Verify answer files have sufficient lines for expected/reported values\n        if (stdout_idx + 1 > stdout_lines.size() || \n            participant_idx + 1 > participant_lines.size()) {\n            return false;\n        }\n\n        // Compare reported value against expected value\n        int expected, reported;\n        try {\n            expected = stoi(stdout_lines[stdout_idx++]);\n            reported = stoi(participant_lines[participant_idx++]);\n        } catch (...) {\n            return false;\n        }\n\n        if (reported != expected) {\n            return false;\n        }\n\n        // Process m matrix rows from contestant's output\n        vector<string> s;\n        for (int i = 0; i < m; i++) {\n            if (participant_idx >= participant_lines.size()) {\n                return false;\n            }\n            string row = participant_lines[participant_idx++];\n            \n            // Validate row length matches n\n            if (static_cast<int>(row.size()) != n) {\n                return false;\n            }\n            \n            // Count '1's in row must equal k\n            int cnt = count(row.begin(), row.end(), '1');\n            if (cnt != k) {\n                return false;\n            }\n            s.push_back(row);\n        }\n\n        // Check for duplicate rows in the matrix\n        set<string> st(s.begin(), s.end());\n        if (static_cast<int>(st.size()) != m) {\n            return false;\n        }\n\n        // Calculate frequency of '1's in each column\n        vector<int> freq(n, 0);\n        for (const string& row : s) {\n            for (int j = 0; j < n; j++) {\n                if (row[j] == '1') {\n                    freq[j]++;\n                }\n            }\n        }\n        int actual = *max_element(freq.begin(), freq.end());\n        \n        // Verify calculated max frequency matches reported value\n        if (actual != reported) {\n            return false;\n        }\n    }\n\n    return true;  // All tests passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60162, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing:\n    - stdin.txt: problem input (corresponds to inf in original code)\n    - stdout.txt: jury's expected output (corresponds to ans in original code)\n    - answer.txt: participant's output (corresponds to ouf in original code)\n\n  Returns true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Tokenization helper: convert vector of lines to vector of tokens\n    auto tokenize = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            if (line.empty()) continue;\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    // Safe integer conversion with bounds checking\n    auto safe_stoi = [](const string& token, int min_val, int max_val, int& value) -> bool {\n        try {\n            size_t pos;\n            value = stoi(token, &pos);\n            // Check if entire token was consumed and value is within bounds\n            if (pos != token.size() || value < min_val || value > max_val) {\n                return false;\n            }\n            return true;\n        } catch (...) {\n            return false;\n        }\n    };\n\n    // Read and tokenize all three files\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    vector<string> input_tokens = tokenize(stdin_lines);\n    vector<string> jury_tokens  = tokenize(stdout_lines);\n    vector<string> part_tokens  = tokenize(participant_lines);\n\n    // Validate input token count (n, m, k + 4*m edge tokens)\n    if (input_tokens.size() < 3 || (input_tokens.size() - 3) % 4 != 0) {\n        return false;\n    }\n\n    // Parse n, m, k from input tokens\n    int n, m, k;\n    if (!safe_stoi(input_tokens[0], 1, 200000, n) ||\n        !safe_stoi(input_tokens[1], 0, 200000, m) ||\n        !safe_stoi(input_tokens[2], 1, 200000, k)) {\n        return false;\n    }\n\n    // Structure to store edge information\n    struct Edge {\n        int u, v, c, t;\n    };\n    vector<Edge> edges;\n    edges.reserve(m);\n\n    // Parse m edges (each with 4 tokens: u, v, c, t)\n    for (int i = 0; i < m; ++i) {\n        int idx = 3 + 4 * i;\n        int u, v, c, t;\n        if (!safe_stoi(input_tokens[idx], 1, n, u) ||\n            !safe_stoi(input_tokens[idx+1], 1, n, v) ||\n            !safe_stoi(input_tokens[idx+2], 1, k, c) ||\n            !safe_stoi(input_tokens[idx+3], 1, k, t)) {\n            return false;\n        }\n        edges.push_back({u, v, c, t});\n    }\n\n    // Parse participant's operation count (first token)\n    if (part_tokens.empty()) return false;\n    int op;\n    if (!safe_stoi(part_tokens[0], -1, n, op)) {\n        return false;\n    }\n\n    // Case 1: Participant claims no solution (op = -1)\n    if (op == -1) {\n        // Must have exactly one token\n        if (part_tokens.size() != 1) return false;\n        // Jury must also output -1\n        if (jury_tokens.size() != 1) return false;\n        int jury_op;\n        return safe_stoi(jury_tokens[0], -1, n, jury_op) && (jury_op == -1);\n    }\n\n    // Case 2: Participant provides operations (op >= 0)\n    // Validate token count (1 for op + 2*op for operations)\n    if (part_tokens.size() != 1 + 2 * static_cast<size_t>(op)) {\n        return false;\n    }\n\n    // Parse each operation (u, c)\n    vector<pair<int, int>> operations;\n    for (int i = 0; i < op; ++i) {\n        int u, c;\n        if (!safe_stoi(part_tokens[1 + 2*i], 1, n, u) ||\n            !safe_stoi(part_tokens[1 + 2*i + 1], 1, k, c)) {\n            return false;\n        }\n        operations.emplace_back(u, c);\n    }\n\n    // Build graph adjacency list (vertex -> incident edge indices)\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < m; ++i) {\n        graph[edges[i].u].push_back(i);\n        graph[edges[i].v].push_back(i);\n    }\n\n    // Track last operation for each vertex (key: vertex, value: {operation index, color})\n    map<int, pair<int, int>> last_op;\n    for (int i = 0; i < op; ++i) {\n        last_op[operations[i].first] = {i, operations[i].second};\n    }\n\n    // Reorder operations by original sequence index\n    map<int, pair<int, int>> ordered_ops;\n    for (const auto& [u, op_data] : last_op) {\n        ordered_ops[op_data.first] = {u, op_data.second};\n    }\n\n    // Simulate operations: start with initial edge colors\n    vector<int> current_colors;\n    for (const Edge& e : edges) {\n        current_colors.push_back(e.c);\n    }\n\n    // Apply operations in participant's specified order\n    for (const auto& [idx, op_data] : ordered_ops) {\n        int u = op_data.first;\n        int c = op_data.second;\n        for (int edge_idx : graph[u]) {\n            current_colors[edge_idx] = c;\n        }\n    }\n\n    // Verify all edges match expected colors\n    for (int i = 0; i < m; ++i) {\n        if (current_colors[i] != edges[i].t) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60174, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to uppercase.\n-----------------------------------------------------------*/\nstring toUpper(const string& s)\n{\n    string t = s;\n    for (char& c : t) \n        c = toupper(static_cast<unsigned char>(c));\n    return t;\n}\n\n/*-----------------------------------------------------------\n  Tokenize a vector of lines into a vector of tokens.\n  Each line is split by whitespace, and empty lines are skipped.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output for the problem:\n    The output must be a sequence of tokens, each being either\n    \"ALICE\" or \"BOB\" (case insensitive), and must exactly match\n    the judge's answer.\n    - If the judge's answer contains an invalid token, reject.\n    - If the contestant's output contains an invalid token, reject.\n    - If the sequences differ in length or in any token, reject.\n    Otherwise, accept.\n  Return true for accept, false for reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Convert lines to tokens for comparison\n    vector<string> answer_tokens = tokenize(answer_lines);\n    vector<string> participant_tokens = tokenize(stdout_lines);\n\n    const string YES = \"ALICE\";\n    const string NO = \"BOB\";\n\n    // Compare tokens in the overlapping part\n    int n = min(answer_tokens.size(), participant_tokens.size());\n    for (int i = 0; i < n; i++) {\n        string ja = toUpper(answer_tokens[i]);\n        string pa = toUpper(participant_tokens[i]);\n\n        // Check judge's token validity (should never fail in valid tests)\n        if (ja != YES && ja != NO) {\n            return false; // Invalid token in judge's answer\n        }\n\n        // Check participant's token validity\n        if (pa != YES && pa != NO) {\n            return false; // Invalid token in participant's output\n        }\n\n        // Check token match\n        if (ja != pa) {\n            return false; // Mismatched token\n        }\n    }\n\n    // Verify both sequences have the same length\n    if (answer_tokens.size() != participant_tokens.size()) {\n        return false; // Mismatched sequence length\n    }\n\n    return true; // All checks passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60175, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output (from stdout_path) against jury's answer (from answer_path).\n  Input (stdin_path) is read but unused in this checker.\n\n  The problem expects tokens of \"YES\" or \"NO\" (case-insensitive) in both outputs.\n  Validation requires:\n    - Both outputs have identical token count\n    - All participant tokens are \"YES\"/\"NO\" (case-insensitive)\n    - Each token matches corresponding jury token\n\n  Returns true for valid solution, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    const string YES = \"YES\";\n    const string NO = \"NO\";\n\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);  // Stores jury's answer\n\n    // Helper: Convert vector of lines to vector of tokens\n    auto tokenize = [](const vector<string>& lines) {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                // Convert token to uppercase for case-insensitive comparison\n                transform(token.begin(), token.end(), token.begin(), \n                         [](unsigned char c) { return toupper(c); });\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    vector<string> participant_tokens = tokenize(stdout_lines);      // Participant's output tokens\n    vector<string> jury_tokens        = tokenize(participant_lines); // Jury's answer tokens\n\n    // Check token-by-token while both sequences have tokens\n    for (size_t i = 0; i < min(participant_tokens.size(), jury_tokens.size()); ++i) {\n        const string& ja = jury_tokens[i];\n        const string& pa = participant_tokens[i];\n\n        // Validate jury token is valid\n        if (ja != YES && ja != NO) {\n            return false; // Invalid token in jury answer\n        }\n\n        // Validate participant token\n        if (pa != YES && pa != NO) {\n            return false; // Participant token not YES/NO\n        }\n\n        // Check token match\n        if (ja != pa) {\n            return false; // Mismatched tokens\n        }\n    }\n\n    // Check for mismatched token counts\n    if (participant_tokens.size() != jury_tokens.size()) {\n        return false; // Different number of tokens\n    }\n\n    return true; // All checks passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60163, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper: Get English ordinal suffix for a number (1st, 2nd, etc.)\n-----------------------------------------------------------*/\nstring get_english_ending(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer:\n  - Both files contain sequences of signed integers\n  - Verify element-wise equality and sequence length\n  - Output appropriate message to stdout on success/failure\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Note: Per problem specification:\n    //   stdin_path  -> corresponds to 'inf' (input to solution, unused here)\n    //   stdout_path -> corresponds to 'ans' (correct answer)\n    //   answer_path -> corresponds to 'ouf' (participant's output)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse all numbers from both files (ignoring line structure)\n    auto parse_numbers = [](const vector<string>& lines) -> vector<ll> {\n        vector<ll> numbers;\n        for (const string& line : lines) {\n            if (line.empty()) continue;\n            stringstream ss(line);\n            ll num;\n            while (ss >> num) {\n                numbers.push_back(num);\n            }\n        }\n        return numbers;\n    };\n\n    vector<ll> correct_nums     = parse_numbers(correct_lines);\n    vector<ll> participant_nums = parse_numbers(participant_lines);\n\n    int n = 0;\n    string firstElems;\n\n    // Compare element-by-element up to the common length\n    int min_size = min(correct_nums.size(), participant_nums.size());\n    for (; n < min_size; n++) {\n        if (correct_nums[n] != participant_nums[n]) {\n            cout << n+1 << get_english_ending(n+1) \n                 << \" numbers differ - expected: '\" << correct_nums[n] \n                 << \"', found: '\" << participant_nums[n] << \"'\\n\";\n            return false;\n        }\n        // Collect first up to 5 numbers for success message\n        if (n < 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(correct_nums[n]);\n        }\n    }\n\n    // Check for extra numbers in correct answer\n    if (correct_nums.size() > participant_nums.size()) {\n        cout << \"Answer contains longer sequence [length = \" << correct_nums.size()\n             << \"], but output contains \" << participant_nums.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra numbers in participant's output\n    if (participant_nums.size() > correct_nums.size()) {\n        cout << \"Output contains longer sequence [length = \" << participant_nums.size()\n             << \"], but answer contains \" << correct_nums.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Success: Output acceptance message\n    if (n <= 5) {\n        cout << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60180, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing contestant's output (stdout.txt)\n  against jury's answer (answer.txt), using input (stdin.txt) \n  to determine number of test cases. Follows original logic:\n  - Read T from stdin\n  - For each test, compare correct answer (answer.txt) vs output (stdout.txt)\n  - Check no extra output exists after T answers\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check valid input file (must have at least T value)\n    if (stdin_lines.empty() || stdin_lines[0].empty()) {\n        cerr << \"Invalid stdin format\\n\";\n        return false;\n    }\n\n    // Parse number of test cases (T) from first line of stdin\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n        if (T < 0) {\n            cerr << \"Negative test count: \" << T << '\\n';\n            return false;\n        }\n    } catch (...) {\n        cerr << \"Failed to parse T from stdin\\n\";\n        return false;\n    }\n\n    // Verify sufficient lines in both answer and output files\n    if (participant_lines.size() < T || stdout_lines.size() < T) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < T; ++i) {\n        try {\n            ll want = stoll(participant_lines[i]);  // Correct answer from answer.txt\n            ll got  = stoll(stdout_lines[i]);       // Contestant's output from stdout.txt\n\n            if (want != got) {\n                return false;\n            }\n        } catch (...) {\n            return false;  // Non-numeric values or conversion errors\n        }\n    }\n\n    // Ensure no extra output beyond T answers\n    if (stdout_lines.size() > T) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60149, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a text file into a vector<string>,\n  where tokens are whitespace-delimited strings (similar to \n  testlib's readString() behavior).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens between correct answer and participant's output.\n  Returns true if all tokens match in sequence, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);  // Not used in comparison\n    vector<string> participant_tokens = read_file(stdout_path); // Contestant's output (ouf)\n    vector<string> answer_tokens      = read_file(answer_path); // Correct answer (ans)\n\n    // Check if token counts differ\n    if (answer_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token\n    for (size_t i = 0; i < answer_tokens.size(); ++i) {\n        if (answer_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    // Special handling for single token case (as in original code)\n    if (answer_tokens.size() == 1) {\n        // Single token match is acceptable\n        return true;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60171, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output (stdout.txt)\n  against jury's answer (answer.txt). Expects both files to contain\n  a single integer on the first line. Returns true if values match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Verify both output files contain at least one line\n    if (stdout_lines.empty() || answer_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integer values from first line of each file\n        int jury_answer      = stoi(answer_lines[0]);\n        int participant_ans  = stoi(stdout_lines[0]);\n\n        return (jury_answer == participant_ans);\n    } catch (...) {\n        // Handle non-integer content or conversion errors\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60161, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing each query result\n  between correct output (stdout.txt) and participant's output (answer.txt).\n  Input format:\n    T\n    [n q][a1...an][l1 r1...lq rq] (repeated T times)\n  Correct output format:\n    [ja1...ja_q] (repeated T times)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert lines to token sequences for easier processing\n    auto tokenize = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            if (line.empty()) continue;  // Skip empty lines\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    vector<string> stdin_tokens = tokenize(stdin_lines);\n    vector<string> stdout_tokens = tokenize(stdout_lines);\n    vector<string> participant_tokens = tokenize(participant_lines);\n\n    int i_stdin = 0, i_stdout = 0, i_participant = 0;\n\n    // Process T test cases\n    if (i_stdin >= stdin_tokens.size()) return false;\n    int T = stoi(stdin_tokens[i_stdin++]);\n\n    while (T--) {\n        // Read problem parameters n and q\n        if (i_stdin + 1 >= stdin_tokens.size()) return false;\n        int n = stoi(stdin_tokens[i_stdin++]);\n        int q = stoi(stdin_tokens[i_stdin++]);\n\n        // Skip n integers (ai values)\n        for (int i = 0; i < n; i++) {\n            if (i_stdin >= stdin_tokens.size()) return false;\n            i_stdin++;\n        }\n\n        // Process each query\n        while (q--) {\n            // Skip query parameters l and r\n            if (i_stdin + 1 >= stdin_tokens.size()) return false;\n            i_stdin += 2;\n\n            // Verify participant's answer matches correct answer\n            if (i_stdout >= stdout_tokens.size() || \n                i_participant >= participant_tokens.size()) {\n                return false;\n            }\n\n            long long ja = stoll(stdout_tokens[i_stdout++]);\n            long long pa = stoll(participant_tokens[i_participant++]);\n\n            if (ja != pa) return false;\n        }\n    }\n\n    // Ensure all tokens were consumed (no extra data)\n    return (i_stdin == stdin_tokens.size() && \n            i_stdout == stdout_tokens.size() && \n            i_participant == participant_tokens.size());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60153, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  - stdin_path:   corresponds to 'inf' (input file)\n  - stdout_path:  corresponds to 'ans' (participant's output)\n  - answer_path:  corresponds to 'ouf' (correct answer)\n  Returns true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path); // 'ans' in original code\n    vector<string> answer_lines      = read_file(answer_path); // 'ouf' in original code\n\n    // Check if either output file is empty\n    if (participant_lines.empty() || answer_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse first line as long long (matching original code's readLong())\n        ll participant_value = stoll(participant_lines[0]);\n        ll answer_value      = stoll(answer_lines[0]);\n\n        // Compare values (same logic as original j != p check)\n        if (participant_value != answer_value) {\n            return false;\n        }\n    } catch (...) {\n        // Handle non-numeric content (matches testlib's readLong() failure behavior)\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60184, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  line-by-line after trimming whitespace. Ignore trailing empty lines in correct answer.\n  Return true if all non-empty trailing lines match and participant output has\n  at least as many lines as the trimmed correct answer.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin_path unused for comparison logic)\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> correct_lines  = read_file(stdout_path);  // Corresponds to 'ans' (correct answer)\n    vector<string> output_lines   = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Trim trailing empty lines from correct answer (mimics original code's behavior)\n    auto it = correct_lines.end();\n    while (it != correct_lines.begin() && it[-1].empty()) {\n        --it;\n    }\n    correct_lines.resize(distance(correct_lines.begin(), it));\n\n    // Check if participant output has sufficient lines\n    if (output_lines.size() < correct_lines.size()) {\n        return false;\n    }\n\n    // Compare each line up to the size of the trimmed correct answer\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (correct_lines[i] != output_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60158, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Check if the participant's configuration (placed) is valid \n  given the initial board state (init). Verifies:\n  1. Correct length and characters\n  2. Initial '#' positions preserved\n  3. All board positions covered by placed '#'\n  4. No redundant placements that maintain coverage\n-----------------------------------------------------------*/\nbool is_valid_solution(const string& placed, const string& init)\n{\n    int N = init.size();\n    if ((int)placed.size() != N) return false;\n\n    int cnt = 0;\n    for (int i = 0; i < N; i++) {\n        char c = placed[i];\n        if (c != '#' && c != '.') return false;\n        if (init[i] == '#' && c != '#') return false;\n        if (c == '#') cnt++;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            bool covered = false;\n            for (int k = 0; k < N; k++) {\n                if (placed[k] == '#' &&\n                   (i == k || j == k || i == j || i + j == 2*k)) {\n                    covered = true;\n                    break;\n                }\n            }\n            if (!covered) return false;\n        }\n    }\n\n    for (int k = 0; k < N; k++) {\n        if (init[k]=='.' && placed[k]=='#') {\n            bool stillAll = true;\n            for (int i = 0; i < N && stillAll; i++) {\n                for (int j = 0; j < N; j++) {\n                    bool cov = false;\n                    for (int u = 0; u < N; u++) {\n                        if (u == k) continue;\n                        if (placed[u]=='#' &&\n                           (i == u || j == u || i == j || i + j == 2*u)) {\n                            cov = true;\n                            break;\n                        }\n                    }\n                    if (!cov) {\n                        stillAll = false;\n                        break;\n                    }\n                }\n            }\n            if (stillAll) return false;\n        }\n    }\n\n    return true;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by:\n  1. Checking if output matches judge's answer exactly, OR\n  2. Verifying participant's output is a valid solution even if different\n  Returns true for accepted solutions, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Verify all files contain exactly one valid line\n    if (stdin_lines.empty() || stdout_lines.empty() || answer_lines.empty()) {\n        return false;\n    }\n    if (stdin_lines.size() != 1 || stdout_lines.size() != 1 || answer_lines.size() != 1) {\n        return false;\n    }\n\n    const string& init = stdin_lines[0];\n    const string& participant_output = stdout_lines[0];\n    const string& judge_answer = answer_lines[0];\n\n    // Accept if output matches judge's answer\n    if (participant_output == judge_answer) {\n        return true;\n    }\n\n    // Otherwise check if participant's solution is valid\n    return is_valid_solution(participant_output, init);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60179, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the\n  correct output. Checks:\n  1. Input format (n in valid range)\n  2. Output line counts match n\n  3. Each colored block group has exactly 3 connected blocks\n  4. Total groups match between correct and participant outputs\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check if any file reading failed\n    if (stdin_lines.empty() || stdout_lines.empty() || answer_lines.empty()) {\n        cerr << \"One or more input files are empty or failed to read\\n\";\n        return false;\n    }\n\n    // Parse grid size n from stdin (first line)\n    if (stdin_lines.size() < 1) {\n        cerr << \"stdin.txt must contain at least one line (n)\\n\";\n        return false;\n    }\n\n    int n;\n    try {\n        n = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid integer format for n in stdin.txt\\n\";\n        return false;\n    }\n\n    if (n < 1 || n > 1024) {\n        cerr << \"n must be in range [1, 1024]\\n\";\n        return false;\n    }\n\n    // Verify output files have exactly n lines\n    if (stdout_lines.size() != n || answer_lines.size() != n) {\n        cerr << \"Output line count mismatch: expected \" << n \n             << \" lines, got stdout=\" << stdout_lines.size() \n             << \", answer=\" << answer_lines.size() << \"\\n\";\n        return false;\n    }\n\n    // Process grid to count valid color groups (each must be exactly 3 blocks)\n    auto process_grid = [](const vector<string>& lines) -> int {\n        vector<string> grid = lines;\n        const int rows = grid.size();\n\n        // Remove all spaces from each line (as per original checker)\n        for (auto& line : grid) {\n            line.erase(remove(line.begin(), line.end(), ' '), line.end());\n        }\n\n        // Prepare visited matrix for DFS\n        vector<vector<bool>> vis(rows);\n        for (int i = 0; i < rows; ++i) {\n            vis[i] = vector<bool>(grid[i].size(), false);\n        }\n\n        // Hexagonal movement directions (6 neighbors)\n        const int DX[6] = {0, 0, 1, -1, 1, -1};\n        const int DY[6] = {1, -1, 0, 0, 1, -1};\n        int total_groups = 0;\n\n        // DFS to count connected blocks of same color\n        function<void(int, int, char, int&)> dfs = [&](int x, int y, char c, int& count) {\n            // Boundary and validity checks\n            if (x < 0 || y < 0 || x >= rows || y >= static_cast<int>(grid[x].size()) || \n                vis[x][y] || grid[x][y] != c) {\n                return;\n            }\n            \n            vis[x][y] = true;\n            ++count;\n            \n            // Explore all 6 hex neighbors\n            for (int k = 0; k < 6; ++k) {\n                const int nx = x + DX[k];\n                const int ny = y + DY[k];\n                dfs(nx, ny, c, count);\n            }\n        };\n\n        // Check all cells in the grid\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < static_cast<int>(grid[i].size()); ++j) {\n                if (vis[i][j] || grid[i][j] == '.') continue;\n                \n                // Validate color character (must be uppercase letter)\n                if (grid[i][j] < 'A' || grid[i][j] > 'Z') {\n                    return -1;\n                }\n\n                int group_size = 0;\n                const char color = grid[i][j];\n                dfs(i, j, color, group_size);\n                \n                // Each color group must contain exactly 3 blocks\n                if (group_size != 3) {\n                    return -1;\n                }\n                ++total_groups;\n            }\n        }\n        return total_groups;\n    };\n\n    // Process both outputs\n    const int judge_groups = process_grid(answer_lines);\n    const int participant_groups = process_grid(stdout_lines);\n\n    // Validate results\n    if (judge_groups == -1 || participant_groups == -1) {\n        cerr << \"Invalid grid structure detected\\n\";\n        return false;\n    }\n    \n    if (judge_groups != participant_groups) {\n        cerr << \"Group count mismatch: judge=\" << judge_groups \n             << \", participant=\" << participant_groups << \"\\n\";\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60157, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split a vector of lines into individual tokens (whitespace-separated).\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\nstruct Circle {\n    ll x, y, r;\n    int f;\n};\n\nstruct Point {\n    ll x, y;\n    int v;\n};\n\nbool inside(const Circle& c, const Point& p) {\n    ll dx = c.x - p.x;\n    ll dy = c.y - p.y;\n    return dx * dx + dy * dy <= c.r * c.r;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution against jury's output using \n  input, participant output, and jury answer files.\n  Return true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Tokenize all input files for easier parsing\n    vector<string> stdin_tokens  = tokenize(stdin_lines);\n    vector<string> stdout_tokens = tokenize(stdout_lines);\n    vector<string> answer_tokens = tokenize(answer_lines);\n\n    int s_idx = 0, o_idx = 0, a_idx = 0;\n\n    // Parse input (stdin)\n    if (s_idx + 2 > stdin_tokens.size()) return false;\n    ll N_ll = stoll(stdin_tokens[s_idx++]);\n    ll M_ll = stoll(stdin_tokens[s_idx++]);\n    if (N_ll < 0 || M_ll < 0) return false;\n    int N = static_cast<int>(N_ll);\n    int M = static_cast<int>(M_ll);\n\n    vector<Circle> circles(N);\n    for (int i = 0; i < N; ++i) {\n        if (s_idx + 4 > stdin_tokens.size()) return false;\n        ll x = stoll(stdin_tokens[s_idx++]);\n        ll y = stoll(stdin_tokens[s_idx++]);\n        ll r = stoll(stdin_tokens[s_idx++]);\n        ll f = stoll(stdin_tokens[s_idx++]);\n        \n        // Validate ranges as per problem constraints\n        if (x < -1000000000 || x > 1000000000 ||\n            y < -1000000000 || y > 1000000000 ||\n            r < 1 || r > 1000000000 ||\n            f < 1 || f > 300) {\n            return false;\n        }\n        circles[i] = {x, y, r, static_cast<int>(f)};\n    }\n\n    vector<Point> points(M);\n    for (int i = 0; i < M; ++i) {\n        if (s_idx + 3 > stdin_tokens.size()) return false;\n        ll x = stoll(stdin_tokens[s_idx++]);\n        ll y = stoll(stdin_tokens[s_idx++]);\n        ll v = stoll(stdin_tokens[s_idx++]);\n        \n        if (x < -1000000000 || x > 1000000000 ||\n            y < -1000000000 || y > 1000000000 ||\n            v < 1 || v > 1000000000) {\n            return false;\n        }\n        points[i] = {x, y, static_cast<int>(v)};\n    }\n    if (s_idx != stdin_tokens.size()) return false;  // Ensure all tokens consumed\n\n    // Parse jury answer\n    if (a_idx + 2 > answer_tokens.size()) return false;\n    ll jury_value = stoll(answer_tokens[a_idx++]);\n    ll jury_count = stoll(answer_tokens[a_idx++]);\n    if (jury_count < 0 || jury_count > M) return false;\n\n    vector<int> jury_points;\n    for (int i = 0; i < jury_count; ++i) {\n        if (a_idx >= answer_tokens.size()) return false;\n        ll idx = stoll(answer_tokens[a_idx++]);\n        if (idx < 1 || idx > M) return false;\n        jury_points.push_back(static_cast<int>(idx));\n    }\n    if (a_idx != answer_tokens.size()) return false;\n\n    // Parse participant output\n    if (o_idx + 2 > stdout_tokens.size()) return false;\n    ll participant_value = stoll(stdout_tokens[o_idx++]);\n    ll participant_count = stoll(stdout_tokens[o_idx++]);\n    if (participant_count < 0 || participant_count > M) return false;\n\n    vector<int> participant_points;\n    set<int> used;\n    for (int i = 0; i < participant_count; ++i) {\n        if (o_idx >= stdout_tokens.size()) return false;\n        ll idx = stoll(stdout_tokens[o_idx++]);\n        if (idx < 1 || idx > M) return false;\n        if (!used.insert(static_cast<int>(idx)).second) {\n            return false;  // Duplicate point usage\n        }\n        participant_points.push_back(static_cast<int>(idx));\n    }\n    if (o_idx != stdout_tokens.size()) return false;\n\n    // Check total value calculation\n    ll total_value = 0;\n    for (int idx : participant_points) {\n        total_value += points[idx - 1].v;\n    }\n    if (total_value != participant_value) {\n        return false;\n    }\n\n    // Check capacity constraints for circles\n    vector<int> count_in_circle(N, 0);\n    for (int idx : participant_points) {\n        const Point& p = points[idx - 1];\n        for (int i = 0; i < N; ++i) {\n            if (inside(circles[i], p)) {\n                if (++count_in_circle[i] > circles[i].f) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Final comparison with jury's value\n    return participant_value == jury_value;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60176, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant output (answer.txt) against jury output (stdout.txt)\n  based on test count specified in stdin.txt.\n  Return true if all words match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if we successfully read all files\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // First line of stdin contains test count\n    int testCount = 0;\n    try {\n        testCount = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid test count in stdin.txt\" << endl;\n        return false;\n    }\n\n    // Verify we have exactly 'testCount' words in both output files\n    if (stdout_lines.size() != testCount || participant_lines.size() != testCount) {\n        cerr << \"Line count mismatch: expected \" << testCount \n             << \" lines, got stdout=\" << stdout_lines.size() \n             << \" answer=\" << participant_lines.size() << endl;\n        return false;\n    }\n\n    // Compare each word pair\n    for (int i = 0; i < testCount; i++) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            cerr << \"Mismatch at test \" << i+1 << \": expected '\"\n                 << stdout_lines[i] << \"', found '\" << participant_lines[i] << \"'\"\n                 << endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60181, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n// Returns the English ordinal suffix for a number (1st, 2nd, etc.)\nstring englishEnding(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n// Shortens a string to max_len characters, appending \"...\" if longer.\nstring compress(const string& s, int max_len = 1000) {\n    if (static_cast<int>(s.length()) <= max_len) {\n        return s;\n    }\n    return s.substr(0, max_len - 3) + \"...\";\n}\n\n// Splits lines into tokens (words), ignoring all whitespace.\nvector<string> tokenize(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Check if participant's output matches expected token-by-token.\n  Print 'ok' or 'wa' messages to stdout and return true for OK, false for WA.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    vector<string> expected_tokens = tokenize(stdout_lines);\n    vector<string> participant_tokens = tokenize(answer_lines);\n\n    int n = 0;\n    for (int i = 0; i < expected_tokens.size() && i < participant_tokens.size(); ++i) {\n        n = i + 1;\n        if (expected_tokens[i] != participant_tokens[i]) {\n            cout << n << englishEnding(n) << \" words differ - expected: '\"\n                 << compress(expected_tokens[i]) << \"', found: '\"\n                 << compress(participant_tokens[i]) << \"'\" << endl;\n            return false;\n        }\n    }\n\n    if (expected_tokens.size() == participant_tokens.size()) {\n        if (n == 1) {\n            cout << \"ok \\\"\" << compress(expected_tokens[0]) << \"\\\"\" << endl;\n        } else {\n            cout << \"ok \" << n << \" tokens\" << endl;\n        }\n        return true;\n    } else if (expected_tokens.size() < participant_tokens.size()) {\n        cout << \"Participant output contains extra tokens\" << endl;\n    } else {\n        cout << \"Unexpected EOF in the participants output\" << endl;\n    }\n    return false;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60156, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split a vector of lines into individual tokens (whitespace-delimited).\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing tokens from the three files.\n  - stdin.txt: problem input (n, k, and strings s)\n  - stdout.txt: jury's correct output (answer)\n  - answer.txt: participant's output\n\n  Returns true if the participant's output is correct, else false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files into vector of lines.\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> jury_lines   = read_file(stdout_path);  // Correct output\n    vector<string> part_lines   = read_file(answer_path);  // Participant's output\n\n    // Convert lines to tokens for easier processing.\n    vector<string> stdin_tokens = tokenize(stdin_lines);\n    vector<string> jury_tokens  = tokenize(jury_lines);\n    vector<string> part_tokens  = tokenize(part_lines);\n\n    // Validate input structure: must have at least n and k.\n    if (stdin_tokens.size() < 2) {\n        return false;\n    }\n\n    // Parse n and k from the input tokens.\n    int n, k;\n    try {\n        n = stoi(stdin_tokens[0]);\n        k = stoi(stdin_tokens[1]);\n    } catch (...) {\n        return false; // Non-integer values for n or k.\n    }\n\n    // Check if there are enough tokens for the k strings.\n    if (static_cast<int>(stdin_tokens.size()) < 2 + k) {\n        return false;\n    }\n\n    // Check that both output files have at least one token (the main answer).\n    if (jury_tokens.empty() || part_tokens.empty()) {\n        return false;\n    }\n\n    string jans = jury_tokens[0];   // Jury's answer (e.g., \"YES\" or \"NO\")\n    string pans = part_tokens[0];   // Participant's answer\n\n    // First, the main answer must match.\n    if (pans != jans) {\n        return false;\n    }\n\n    // If the answer is \"NO\", there should be no further tokens.\n    if (jans == \"NO\") {\n        return (jury_tokens.size() == 1) && (part_tokens.size() == 1);\n    }\n\n    // For \"YES\" answers, expect exactly n integers following the main token.\n    if (static_cast<int>(jury_tokens.size()) != 1 + n ||\n        static_cast<int>(part_tokens.size()) != 1 + n) {\n        return false;\n    }\n\n    // Validate each of the n integers.\n    for (int i = 0; i < n; ++i) {\n        try {\n            // Participant's integer must be in [1, n].\n            size_t pos;\n            int p = stoi(part_tokens[1 + i], &pos);\n            if (pos != part_tokens[1 + i].size()) {\n                return false; // Extra characters after the number.\n            }\n            if (p < 1 || p > n) {\n                return false; // Out of valid range.\n            }\n\n            // Jury's integer (no need to check range, assumed correct).\n            int j = stoi(jury_tokens[1 + i]);\n\n            if (p != j) {\n                return false;\n            }\n        } catch (...) {\n            return false; // Failed to parse integer.\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60159, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare correct output (stdout.txt) and participant's output (answer.txt)\n  as sequences of integers. Returns true only if participant's output contains\n  at least as many tokens as correct output AND all corresponding tokens match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path); // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path); // Participant's output (ouf)\n\n    // Extract all integer tokens from correct output\n    vector<int> correct_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            correct_tokens.push_back(num);\n        }\n    }\n\n    // Extract all integer tokens from participant's output\n    vector<int> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            participant_tokens.push_back(num);\n        }\n    }\n\n    // Check if participant's output has fewer tokens than correct output\n    if (participant_tokens.size() < correct_tokens.size()) {\n        return false;\n    }\n\n    // Verify all tokens in correct output match participant's output\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (participant_tokens[i] != correct_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60198, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>.\n  Lines are stored exactly as read, including leading/trailing whitespace.\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path).\n  Returns true if participant's output has at least as many lines as correct output\n  and the first N lines (N = number of lines in correct output) match exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant has fewer lines than correct answer\n    if (participant_lines.size() < stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line of correct answer with participant's output\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60183, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing the jury's answer (stdout.txt)\n  with the participant's output (answer.txt) for 't' test cases.\n  Reads the number of test cases from stdin.txt.\n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if stdin file was read successfully\n    if (stdin_lines.empty()) {\n        cerr << \"Error: Empty stdin file\\n\";\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Error: Failed to parse test case count from stdin\\n\";\n        return false;\n    }\n\n    // Verify sufficient lines in both output files\n    if (stdout_lines.size() < t || participant_lines.size() < t) {\n        cerr << \"Error: Output files have insufficient test cases (expected \" \n             << t << \")\\n\";\n        return false;\n    }\n\n    // Compare each test case's answer\n    for (int i = 0; i < t; ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            cerr << \"[Case : \" << t << \"] - The jury's string mismatches with the output\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60202, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse integer 'n' from stdin (first non-empty line)\n    int n = 0;\n    bool found_n = false;\n    for (const auto& line : stdin_lines) {\n        if (!line.empty()) {\n            try {\n                size_t pos;\n                n = stoi(line, &pos);\n                // Ensure entire line is a valid integer\n                if (pos != line.size()) return false;\n                found_n = true;\n                break;\n            } catch (...) {\n                return false;\n            }\n        }\n    }\n    if (!found_n || n < 1) return false;\n\n    // Collect non-empty lines from correct output (stdout_lines) and participant output (participant_lines)\n    vector<string> ans_nonempty;\n    for (const auto& line : stdout_lines) {\n        if (!line.empty()) ans_nonempty.push_back(line);\n    }\n    vector<string> ouf_nonempty;\n    for (const auto& line : participant_lines) {\n        if (!line.empty()) ouf_nonempty.push_back(line);\n    }\n\n    // Verify sufficient lines exist for comparison (2n-1 integers)\n    const int required = 2 * n - 1;\n    if (ans_nonempty.size() < required || ouf_nonempty.size() < required) {\n        return false;\n    }\n\n    // Compare first n integers\n    for (int i = 0; i < n; ++i) {\n        try {\n            size_t pos1, pos2;\n            int ja = stoi(ans_nonempty[i], &pos1);\n            int pa = stoi(ouf_nonempty[i], &pos2);\n            if (pos1 != ans_nonempty[i].size() || \n                pos2 != ouf_nonempty[i].size() ||\n                ja != pa) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Compare next n-1 integers\n    for (int i = n; i < required; ++i) {\n        try {\n            size_t pos1, pos2;\n            int ja = stoi(ans_nonempty[i], &pos1);\n            int pa = stoi(ouf_nonempty[i], &pos2);\n            if (pos1 != ans_nonempty[i].size() || \n                pos2 != ouf_nonempty[i].size() ||\n                ja != pa) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Check for extra tokens beyond 2n-1\n    if ((ans_nonempty.size() == required && ouf_nonempty.size() > required) ||\n        (ans_nonempty.size() > required && ouf_nonempty.size() == required)) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60207, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against jury's output by comparing\n  line-by-line token sequences. Returns true only if all lines match\n  exactly in token count and content.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify both outputs have identical line count\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Process each line: split into tokens and compare sequences\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        // Tokenize jury's output line\n        istringstream iss_ja(stdout_lines[i]);\n        vector<string> ja_tokens;\n        string token;\n        while (iss_ja >> token) {\n            ja_tokens.push_back(token);\n        }\n\n        // Tokenize participant's output line\n        istringstream iss_pa(participant_lines[i]);\n        vector<string> pa_tokens;\n        while (iss_pa >> token) {\n            pa_tokens.push_back(token);\n        }\n\n        // Compare token sequences for this test case\n        if (ja_tokens != pa_tokens) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60170, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution for multiple Yes/No problem.\n  Compares expected output (from stdout_path) against participant's \n  output (from answer_path). Input file (stdin_path) is unused \n  in this validator but read for template consistency.\n  Returns true if outputs match exactly with valid tokens; \n  otherwise false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (though stdin_path/input is unused)\n    vector<string> inf_lines       = read_file(stdin_path);\n    vector<string> ans_lines       = read_file(stdout_path);  // Expected output (jury)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Convert expected output lines to tokens\n    vector<string> ans_tokens;\n    for (const string& line : ans_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant's output lines to tokens\n    vector<string> ouf_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    const string YES = \"Yes\";\n    const string NO = \"No\";\n    int index = 0;\n    int yesCount = 0, noCount = 0;\n\n    // Compare tokens sequentially\n    while (index < ans_tokens.size() && index < ouf_tokens.size()) {\n        string ja = ans_tokens[index];  // Expected token\n        string pa = ouf_tokens[index];  // Participant's token\n\n        // Validate expected token is \"Yes\" or \"No\"\n        if (ja != YES && ja != NO) {\n            return false;\n        }\n\n        // Count participant's valid tokens and validate\n        if (pa == YES) {\n            yesCount++;\n        } else if (pa == NO) {\n            noCount++;\n        } else {\n            return false;  // Invalid token (presentation error)\n        }\n\n        // Check match with expected output\n        if (ja != pa) {\n            return false;  // Wrong answer\n        }\n        index++;\n    }\n\n    // Check for mismatched token counts\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;  // Extra tokens in either output\n    }\n\n    return true;  // All tokens matched correctly\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60169, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper: Returns ordinal suffix for a number (1st, 2nd, etc.)\n-----------------------------------------------------------*/\nstring english_ending(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of integers from correct answer and \n  participant's output files. Returns true if valid, false otherwise.\n  Prints appropriate verdict messages to standard output.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files (stdin unused but required by interface)\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> correct_lines  = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> output_lines   = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse all integers from correct answer file\n    vector<int> correct_tokens;\n    for (const string& line : correct_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                correct_tokens.push_back(stoi(token));\n            } catch (...) {\n                // Invalid integer format - treat as WA\n                cout << \"wa Invalid integer format in correct answer file\\n\";\n                return false;\n            }\n        }\n    }\n\n    // Parse all integers from participant's output file\n    vector<int> output_tokens;\n    for (const string& line : output_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                output_tokens.push_back(stoi(token));\n            } catch (...) {\n                // Invalid integer format - treat as WA\n                cout << \"wa Invalid integer format in participant's output\\n\";\n                return false;\n            }\n        }\n    }\n\n    // Compare sequences element-by-element\n    int n = 0;\n    string firstElems = \"\";\n    int min_size = min(correct_tokens.size(), output_tokens.size());\n\n    for (int i = 0; i < min_size; ++i) {\n        if (correct_tokens[i] != output_tokens[i]) {\n            cout << \"wa \" << (n+1) << english_ending(n+1) \n                 << \" numbers differ - expected: '\" << correct_tokens[i]\n                 << \"', found: '\" << output_tokens[i] << \"'\\n\";\n            return false;\n        }\n        \n        // Collect first 5 numbers for OK message\n        if (n < 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(correct_tokens[i]);\n        }\n        n++;\n    }\n\n    // Check for extra elements in correct answer\n    int extraInAns = correct_tokens.size() - min_size;\n    if (extraInAns > 0) {\n        cout << \"wa Answer contains longer sequence [length = \" << correct_tokens.size()\n             << \"], but output contains \" << output_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra elements in participant's output\n    int extraInOuf = output_tokens.size() - min_size;\n    if (extraInOuf > 0) {\n        cout << \"wa Output contains longer sequence [length = \" << output_tokens.size()\n             << \"], but answer contains \" << correct_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // All checks passed - output OK message\n    if (n <= 5) {\n        cout << \"ok \" << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << \"ok \" << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60151, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing participant's output (answer.txt)\n  against the correct output (stdout.txt) for each test case.\n  The number of test cases is read from stdin.txt.\n  Return true if all match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file is empty or first line can't be parsed\n    if (stdin_lines.empty()) \n        return false;\n\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Ensure there are enough lines in both output files\n    if (stdout_lines.size() < (size_t)t || participant_lines.size() < (size_t)t)\n        return false;\n\n    for (int i = 0; i < t; ++i) {\n        ll correct_val, participant_val;\n        try {\n            correct_val    = stoll(stdout_lines[i]);\n            participant_val = stoll(participant_lines[i]);\n        } catch (...) {\n            return false;\n        }\n        if (correct_val != participant_val)\n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60192, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a file into a vector<string>.\n  Tokens are separated by whitespace; leading/trailing whitespace\n  is automatically skipped by the stream extraction operator.\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compress a string for display, truncating to 100 characters\n  with ellipses if necessary (first 50 + ... + last 50 chars).\n-----------------------------------------------------------*/\nstring compress(const string& s)\n{\n    const int MAX_LEN = 100;\n    if (s.length() <= MAX_LEN) {\n        return s;\n    }\n    return s.substr(0, 50) + \"...\" + s.substr(s.length() - 50);\n}\n\n/*-----------------------------------------------------------\n  Return the English ordinal suffix for a number (1st, 2nd, etc.)\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct output by comparing\n  token sequences. Returns true if all tokens match and both files\n  end at the same position, otherwise prints detailed error and returns false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Note: stdin_path is unused in this validator but kept for interface consistency\n    vector<string> correct_tokens = read_file(stdout_path);\n    vector<string> participant_tokens = read_file(answer_path);\n\n    size_t n = 0;\n    size_t min_size = min(correct_tokens.size(), participant_tokens.size());\n\n    // Compare tokens one by one\n    for (; n < min_size; n++) {\n        if (correct_tokens[n] != participant_tokens[n]) {\n            cerr << (n+1) << englishEnding(n+1) << \" words differ - expected: '\"\n                 << compress(correct_tokens[n]) << \"', found: '\"\n                 << compress(participant_tokens[n]) << \"'\\n\";\n            return false;\n        }\n    }\n\n    // Check if both files ended simultaneously\n    if (correct_tokens.size() == participant_tokens.size()) {\n        if (n == 1) {\n            cerr << \"Accepted: \\\"\" << compress(correct_tokens[0]) << \"\\\"\\n\";\n        } else {\n            cerr << \"Accepted: \" << n << \" tokens\\n\";\n        }\n        return true;\n    }\n    // Participant has extra tokens\n    else if (participant_tokens.size() > correct_tokens.size()) {\n        cerr << \"Participant output contains extra tokens\\n\";\n        return false;\n    }\n    // Participant's output ended prematurely\n    else {\n        cerr << \"Unexpected EOF in the participant's output\\n\";\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60212, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst string YES = \"YES\";\nconst string NO = \"NO\";\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Checks:\n    1. All tokens in correct answer are YES/NO\n    2. All tokens in participant's output are YES/NO\n    3. Tokens match exactly between correct and participant\n    4. No extra tokens in either file\n  Returns true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to inf (unused here)\n    vector<string> correct_lines     = read_file(stdout_path);      // Corresponds to ans (correct answer)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to ouf (participant's output)\n\n    int index = 0;\n\n    // Process tokens while both files have content\n    while (index < correct_lines.size() && index < participant_lines.size()) {\n        string ja = correct_lines[index];   // Correct token (from ans)\n        string pa = participant_lines[index]; // Participant's token (from ouf)\n\n        // Validate correct token is valid\n        if (ja != YES && ja != NO) {\n            return false;\n        }\n\n        // Validate participant's token is valid\n        if (pa != YES && pa != NO) {\n            return false;\n        }\n\n        // Check tokens match\n        if (ja != pa) {\n            return false;\n        }\n\n        index++;\n    }\n\n    // Check for leftover tokens in either file\n    if (index < correct_lines.size() || index < participant_lines.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60148, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate contestant's solution against jury's answer and input.\n  Steps:\n    1. Tokenize all three files (stdin.txt = input test case,\n       stdout.txt = jury's expected output, answer.txt = contestant's output)\n    2. Parse tokens to extract:\n        - Input: n (integer) and s (string)\n        - Jury's output: optimal_ja (integer)\n        - Contestant's output: optimal_pa (integer) and pa (string)\n    3. Verify optimal_ja equals optimal_pa\n    4. Verify pa has length equal to optimal_pa\n    5. Verify pa contains only lowercase letters\n    6. Build transition graph from pa:\n        * For each character in pa, consider its neighbors (left, right, self)\n        * Record transitions from neighbor characters to current character\n    7. Validate string s follows valid transitions in the graph\n\n  Return true if all checks pass (correct solution), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize stdin_lines (input test case)\n    vector<string> tokens_stdin;\n    for (const string& line : stdin_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_stdin.push_back(token);\n        }\n    }\n\n    // Tokenize stdout_lines (jury's expected output)\n    vector<string> tokens_stdout;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_stdout.push_back(token);\n        }\n    }\n\n    // Tokenize participant_lines (contestant's output)\n    vector<string> tokens_ouf;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_ouf.push_back(token);\n        }\n    }\n\n    // Verify sufficient tokens exist\n    if (tokens_stdin.size() < 2 || tokens_stdout.size() < 1 || tokens_ouf.size() < 2) {\n        return false;\n    }\n\n    // Parse input tokens\n    int n;\n    try {\n        n = stoi(tokens_stdin[0]);\n    } catch (...) {\n        return false;\n    }\n    string s = tokens_stdin[1];\n\n    // Parse jury's output token\n    int optimal_ja;\n    try {\n        optimal_ja = stoi(tokens_stdout[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Parse contestant's output tokens\n    int optimal_pa;\n    try {\n        optimal_pa = stoi(tokens_ouf[0]);\n    } catch (...) {\n        return false;\n    }\n    string pa = tokens_ouf[1];\n\n    // Check 1: Optimal path length must match jury's answer\n    if (optimal_ja != optimal_pa) {\n        return false;\n    }\n\n    // Check 2: Contestant's output string must have correct length\n    if (static_cast<int>(pa.size()) != optimal_pa) {\n        return false;\n    }\n\n    // Check 3: Contestant's string must contain only lowercase letters\n    for (char c : pa) {\n        if (c < 'a' || c > 'z') {\n            return false;\n        }\n    }\n\n    // Build character transition graph from contestant's string\n    vector<int> cnt(26, 0);\n    int m = optimal_pa;\n    for (int i = 0; i < m; i++) {\n        cnt[pa[i] - 'a']++;\n    }\n\n    // Initialize transition matrix (26x26)\n    vector<vector<int>> nxt(26, vector<int>(26, 0));\n    for (int i = 0; i < m; i++) {\n        set<char> pre;\n        if (i > 0) pre.insert(pa[i-1]);\n        if (i < m-1) pre.insert(pa[i+1]);\n        pre.insert(pa[i]);  // Always include current character\n\n        for (char x : pre) {\n            nxt[x - 'a'][pa[i] - 'a']++;\n        }\n    }\n\n    // Validate string s follows valid transitions\n    for (int i = 1; i < n; i++) {\n        int from = s[i-1] - 'a';\n        int to   = s[i]   - 'a';\n        \n        // Check character bounds (must be lowercase)\n        if (from < 0 || from >= 26 || to < 0 || to >= 26) {\n            return false;\n        }\n        \n        // Check transition exists in graph\n        if (nxt[from][to] <= 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60208, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer token-by-token.\n  Returns true if all tokens match and both files have same token count.\n  Returns false otherwise (mismatched token or different token count).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path); // Unused (problem input)\n    vector<string> stdout_lines      = read_file(stdout_path); // Jury's answer (correct output)\n    vector<string> participant_lines = read_file(answer_path); // Participant's output\n\n    // Extract tokens from jury's answer (treat entire file as token stream)\n    vector<string> jury_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            jury_tokens.push_back(token);\n        }\n    }\n\n    // Extract tokens from participant's output\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Check token count mismatch\n    if (jury_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token sequentially\n    for (size_t i = 0; i < jury_tokens.size(); ++i) {\n        if (jury_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60191, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // If stdin is empty, cannot proceed\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse the number of test cases 't' from the first line\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false; // Invalid integer\n    }\n\n    // Collect all tokens from the participant's output (answer.txt)\n    vector<string> participant_tokens;\n    for (string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Collect all tokens from the judge's output (stdout.txt)\n    vector<string> judge_tokens;\n    for (string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            judge_tokens.push_back(token);\n        }\n    }\n\n    // Ensure there are at least 't' tokens in both outputs\n    if (static_cast<int>(participant_tokens.size()) < t || \n        static_cast<int>(judge_tokens.size()) < t) {\n        return false;\n    }\n\n    // Compare the first 't' tokens\n    for (int i = 0; i < t; ++i) {\n        if (participant_tokens[i] != judge_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60214, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing first 4 integers in participant's \n  output (answer.txt) against correct answer (stdout.txt). \n  Return true if all match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Ensure both output files contain at least 4 lines\n    if (stdout_lines.size() < 4 || participant_lines.size() < 4) {\n        return false;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        try {\n            ll actual   = stoll(participant_lines[i]);\n            ll expected = stoll(stdout_lines[i]);\n            if (actual != expected) {\n                return false;\n            }\n        } catch (...) {\n            // Handle conversion errors (non-integer values)\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60206, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_path) against correct answer \n  (answer_path). The stdin_path is unused in this checker but \n  maintained for template consistency. Expects single integer \n  output on first non-empty line of each file.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify both output files contain data\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integers from first line of each output file\n        int expected = stoi(participant_lines[0]);\n        int got      = stoi(stdout_lines[0]);\n\n        // Check for exact integer match\n        return (expected == got);\n    } \n    catch (...) {\n        // Handle non-integer content or conversion errors\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60178, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Geometry problem: compares expected and contestant medians for each test case.\n  Returns true if all test cases match and no extra output, else false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file has at least one line for test count\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases (T) from first line of stdin\n    ll T_val;\n    try {\n        T_val = stoll(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (T_val <= 0) {\n        return false;\n    }\n    size_t T = static_cast<size_t>(T_val);\n\n    // Verify sufficient lines in expected and participant outputs\n    if (stdout_lines.size() < T || participant_lines.size() < T) {\n        return false;\n    }\n\n    // Process each test case\n    for (size_t i = 0; i < T; ++i) {\n        ll expected, found;\n\n        // Parse expected median from stdout (correct answer)\n        stringstream ss1(stdout_lines[i]);\n        if (!(ss1 >> expected) || ss1.rdbuf()->in_avail() != 0) {\n            return false;\n        }\n\n        // Parse found median from participant output\n        stringstream ss2(participant_lines[i]);\n        if (!(ss2 >> found) || ss2.rdbuf()->in_avail() != 0) {\n            return false;\n        }\n\n        // Compare values\n        if (expected != found) {\n            return false;\n        }\n    }\n\n    // Check for extra output beyond T test cases\n    if (participant_lines.size() > T) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60210, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against expected answer.\n  Return true if values match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input data (unused in checker)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Expected answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Extract first non-empty line from expected answer\n    string expected_str;\n    for (const auto& line : stdout_lines) {\n        if (!line.empty()) {\n            expected_str = line;\n            break;\n        }\n    }\n    if (expected_str.empty()) {\n        cerr << \"Error: Expected answer is empty\\n\";\n        return false;\n    }\n\n    // Extract first non-empty line from participant's output\n    string participant_str;\n    for (const auto& line : participant_lines) {\n        if (!line.empty()) {\n            participant_str = line;\n            break;\n        }\n    }\n    if (participant_str.empty()) {\n        cerr << \"Error: Participant output is empty\\n\";\n        return false;\n    }\n\n    // Convert strings to long long with error handling\n    try {\n        ll expected = stoll(expected_str);\n        ll participant = stoll(participant_str);\n        return expected == participant;\n    } catch (const exception& e) {\n        cerr << \"Conversion error: \" << e.what() << '\\n';\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60211, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (stdout.txt) against correct answer (answer.txt)\n  Line-by-line ensuring:\n  1. Contestant's output has at least as many lines as correct answer\n  2. All lines up to correct answer's length match exactly\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Check if contestant's output has fewer lines than required\n    if (stdout_lines.size() < answer_lines.size()) {\n        return false;\n    }\n\n    // Compare each line in the correct answer with contestant's output\n    for (size_t i = 0; i < answer_lines.size(); ++i) {\n        if (answer_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60205, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (from answer_path) against model answer \n  (from stdout_path) for sequences of signed integers (as long long).\n  The problem input (stdin_path) is not used in comparison.\n  \n  Returns true if sequences are identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);      // Problem input (unused)\n    vector<string> model_lines       = read_file(stdout_path);     // Model answer (ans)\n    vector<string> participant_lines = read_file(answer_path);     // Participant output (ouf)\n\n    // Convert model answer lines to tokens\n    vector<string> model_tokens;\n    for (const string& line : model_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            model_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant output lines to tokens\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Compare tokens one-by-one\n    int count = 0;\n    string firstElems;\n\n    while (count < model_tokens.size() && count < participant_tokens.size()) {\n        try {\n            long long model_val = stoll(model_tokens[count]);\n            long long part_val = stoll(participant_tokens[count]);\n            \n            if (model_val != part_val) {\n                // Format ordinal suffix (1st, 2nd, 3rd, etc.)\n                string suffix = \"th\";\n                if (count == 0) suffix = \"st\";\n                else if (count == 1) suffix = \"nd\";\n                else if (count == 2) suffix = \"rd\";\n                \n                cerr << (count+1) << suffix \n                     << \" numbers differ - expected: '\" << model_val \n                     << \"', found: '\" << part_val << \"'\\n\";\n                return false;\n            }\n            \n            // Collect first 5 numbers for success message\n            if (count < 5) {\n                if (!firstElems.empty()) firstElems += \" \";\n                firstElems += to_string(model_val);\n            }\n        } catch (...) {\n            cerr << \"Token \" << (count+1) << \" is not a valid integer\\n\";\n            return false;\n        }\n        count++;\n    }\n\n    // Check for extra tokens in model answer\n    if (model_tokens.size() > participant_tokens.size()) {\n        cerr << \"Answer contains longer sequence [length = \" << model_tokens.size()\n             << \"], but output contains \" << participant_tokens.size() << \" elements\\n\";\n        return false;\n    }\n    \n    // Check for extra tokens in participant output\n    if (participant_tokens.size() > model_tokens.size()) {\n        cerr << \"Output contains longer sequence [length = \" << participant_tokens.size()\n             << \"], but answer contains \" << model_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Success: Output acceptance message\n    if (count <= 5) {\n        cerr << \"ok \" << count << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cerr << \"ok \" << count << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60199, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected answers.\n  stdin.txt: Contains input data (first line is test count T)\n  stdout.txt: Contains expected answers (jury's output)\n  answer.txt: Contains participant's output to verify\n  Returns true if all T test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Must have at least one line for test count T\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse T (number of test cases) from first line of stdin\n    int T;\n    stringstream ss(stdin_lines[0]);\n    if (!(ss >> T) || T < 0 || ss.get() != EOF) {\n        return false;\n    }\n\n    // Verify sufficient lines in both output files\n    if (stdout_lines.size() < T || participant_lines.size() < T) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < T; ++i) {\n        // Parse expected value from stdout (jury's answer)\n        stringstream ss_exp(stdout_lines[i]);\n        ll expected;\n        if (!(ss_exp >> expected) || ss_exp.get() != EOF) {\n            return false;\n        }\n\n        // Parse actual value from participant's output\n        stringstream ss_act(participant_lines[i]);\n        ll actual;\n        if (!(ss_act >> actual) || ss_act.get() != EOF) {\n            return false;\n        }\n\n        // Check for mismatch\n        if (actual != expected) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60193, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by checking contestant's output against\n  problem input. Returns true if valid, false otherwise.\n  \n  Logic:\n  1. Parse input tokens (test cases, tree structure)\n  2. Parse contestant's color assignments\n  3. Verify white/cayan balance (sum == 0)\n  4. Validate coloring constraints via DFS\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Unused per problem note\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Convert stdin_lines to token stream\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    // Convert answer_lines to token stream (contestant's output)\n    vector<string> answer_tokens;\n    for (const string& line : answer_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            answer_tokens.push_back(token);\n        }\n    }\n\n    int idx_stdin = 0;\n    int idx_answer = 0;\n\n    // Read number of test cases (t)\n    if (idx_stdin >= stdin_tokens.size()) return false;\n    int t = stoi(stdin_tokens[idx_stdin++]);\n    if (t < 1 || t > 10000) return false;\n\n    // Adjacency list and color array (1-based indexing up to 200000 nodes)\n    vector<vector<int>> adj(200010);\n    vector<int> col(200010, 0);\n    bool failed = false;\n\n    for (int i = 0; i < t; i++) {\n        // Read tree size parameter (n)\n        if (idx_stdin >= stdin_tokens.size()) return false;\n        int n = stoi(stdin_tokens[idx_stdin++]);\n        if (n < 1 || n > 100000) return false;\n        int max_node = 2 * n;\n\n        // Reset graph structures for current test case\n        for (int u = 1; u <= max_node; u++) {\n            adj[u].clear();\n            col[u] = 0;\n        }\n\n        // Read tree edges (2n-1 edges for 2n-node tree)\n        for (int j = 0; j < 2*n - 1; j++) {\n            if (idx_stdin + 1 >= stdin_tokens.size()) return false;\n            int u = stoi(stdin_tokens[idx_stdin++]);\n            int v = stoi(stdin_tokens[idx_stdin++]);\n            if (u < 1 || u > 2*n || v < 1 || v > 2*n) return false;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        // Read contestant's color assignments (0=white, 1=cayan)\n        int sum = 0;\n        for (int j = 1; j <= 2*n; j++) {\n            if (idx_answer >= answer_tokens.size()) return false;\n            int c = stoi(answer_tokens[idx_answer++]);\n            if (c != 0 && c != 1) return false;\n            col[j] = (c == 0) ? -1 : 1;  // Convert 0-1 for balance check\n            sum += col[j];\n        }\n        if (sum != 0) return false;  // White must equal cayan count\n\n        // DFS to validate coloring constraints\n        failed = false;\n        function<pair<int, int>(int, int)> dfs;\n        dfs = [&](int u, int p) -> pair<int, int> {\n            int mx = 0, mn = 0;\n            int secmx = 0, secmn = 0;\n\n            for (int v : adj[u]) {\n                if (v == p) continue;\n                auto res = dfs(v, u);\n                \n                // Track top two max/min values from children\n                if (mx < res.first) {\n                    secmx = mx;\n                    mx = res.first;\n                } else if (secmx < res.first) {\n                    secmx = res.first;\n                }\n                if (mn > res.second) {\n                    secmn = mn;\n                    mn = res.second;\n                } else if (secmn > res.second) {\n                    secmn = res.second;\n                }\n\n                // Immediate failure checks\n                if (mx > 3 || mn < -3 || \n                    mx + secmx + col[u] > 3 || \n                    mn + secmn + col[u] < -3) {\n                    failed = true;\n                }\n            }\n\n            if (mx > 3 || mn < -3) failed = true;\n            \n            // Apply current node's color\n            mx += col[u];\n            mn += col[u];\n            mx = max(mx, 0);\n            mn = min(mn, 0);\n            \n            if (mx > 3 || mn < -3) failed = true;\n            return {mx, mn};\n        };\n\n        dfs(1, 0);\n        if (failed) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60168, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a vector of lines into a vector of tokens by splitting\n  each line into space-separated tokens.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Return the English ordinal suffix for a given integer (e.g., 1  \"st\").\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from correct answer\n  (stdout_path) and participant's output (answer_path).\n  Return true if identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> correct_lines    = read_file(stdout_path);  // Corresponds to 'ans' (correct answer)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to 'ouf' (participant's output)\n\n    auto correct_tokens    = tokenize(correct_lines);\n    auto participant_tokens = tokenize(participant_lines);\n\n    size_t min_len = min(correct_tokens.size(), participant_tokens.size());\n    string firstElems = \"\";\n\n    // Compare each token in the common sequence\n    for (size_t i = 0; i < min_len; i++) {\n        try {\n            ll j = stoll(correct_tokens[i]);\n            ll p = stoll(participant_tokens[i]);\n            if (j != p) {\n                int pos = i + 1;\n                cerr << pos << englishEnding(pos) \n                     << \" numbers differ - expected: '\" << j \n                     << \"', found: '\" << p << \"'\\n\";\n                return false;\n            }\n            // Record first 5 matching numbers for OK message\n            if (i < 5) {\n                if (!firstElems.empty()) firstElems += \" \";\n                firstElems += to_string(j);\n            }\n        } catch (...) {\n            cerr << \"Token \" << (i+1) << \" is not a valid integer\\n\";\n            return false;\n        }\n    }\n\n    // Check if correct answer has extra tokens\n    if (correct_tokens.size() > participant_tokens.size()) {\n        size_t extra = correct_tokens.size() - participant_tokens.size();\n        cerr << \"Answer contains longer sequence [length = \" << correct_tokens.size()\n             << \"], but output contains \" << participant_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check if participant output has extra tokens\n    if (participant_tokens.size() > correct_tokens.size()) {\n        size_t extra = participant_tokens.size() - correct_tokens.size();\n        cerr << \"Output contains longer sequence [length = \" << participant_tokens.size()\n             << \"], but answer contains \" << correct_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Output success message with first few numbers if applicable\n    if (min_len <= 5) {\n        cout << min_len << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << min_len << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60227, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing against correct answer.\n  Uses input file to determine grid dimensions (n, m) for total cells NM.\n  Expects both outputs to contain exactly NM integers in sequence.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse grid dimensions n and m from first line of input\n    if (stdin_lines.empty()) {\n        cerr << \"Error: stdin file is empty\\n\";\n        return false;\n    }\n    stringstream ss(stdin_lines[0]);\n    int n, m;\n    if (!(ss >> n >> m)) {\n        cerr << \"Error: failed to parse n and m from stdin\\n\";\n        return false;\n    }\n    ll NM = (ll)n * m;\n\n    // Helper to extract all integers from lines (handles multi-line output)\n    auto extractInts = [](const vector<string>& lines) -> vector<int> {\n        vector<int> nums;\n        for (const string& line : lines) {\n            stringstream ls(line);\n            int num;\n            while (ls >> num) {\n                nums.push_back(num);\n            }\n        }\n        return nums;\n    };\n\n    vector<int> correct_ints = extractInts(stdout_lines);\n    vector<int> found_ints   = extractInts(participant_lines);\n\n    // Verify both outputs contain exactly NM integers\n    if (correct_ints.size() != NM || found_ints.size() != NM) {\n        return false;\n    }\n\n    // Compare each integer in sequence\n    for (ll i = 0; i < NM; i++) {\n        if (found_ints[i] != correct_ints[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60155, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define ld  long double\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nnamespace {\n    const int MAXN = 220;\n    const int MAXM = 20000000;\n    int nxt[MAXM][2];\n    int Tnode;\n    bitset<MAXN> msk;\n}\n\nstruct P { ld x, y; };\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Calculate intersection points of two circles.\n  Returns two points (which may be equal if circles are tangent).\n-----------------------------------------------------------*/\npair<P, P> circleInter(const P &a, const P &b, ld r1, ld r2) {\n    P vec{b.x - a.x, b.y - a.y};\n    ld d2 = vec.x*vec.x + vec.y*vec.y;\n    ld pfrac = (d2 + r1*r1 - r2*r2) / (2*d2);\n    ld h2 = r1*r1 - pfrac*pfrac*d2;\n    P mid{a.x + vec.x*pfrac, a.y + vec.y*pfrac};\n    ld f = sqrt(max((ld)0, h2/d2));\n    P per{-vec.y * f, vec.x * f};\n    return {\n      P{mid.x + per.x, mid.y + per.y},\n      P{mid.x - per.x, mid.y - per.y}\n    };\n}\n\n/*-----------------------------------------------------------\n  Update the bitset mask for a given point 'o'.\n  Sets msk[i] = 1 if point 'o' is inside circle i.\n-----------------------------------------------------------*/\nvoid Do(const P &o) {\n    for(int i = 0; i < MAXN; i++) {\n        ld dx = o.x - (P::x == 0 ? 0 : p[i].x); // Avoid unused variable warning\n        ld dy = o.y - (P::y == 0 ? 0 : p[i].y);\n        msk[i] = (dx*dx + dy*dy < (ld)rad[i]*rad[i]);\n    }\n}\n\n/*-----------------------------------------------------------\n  Add the current bitset mask to the trie structure.\n-----------------------------------------------------------*/\nvoid Add() {\n    int v = 0;\n    for(int i = 0; i < MAXN; i++) {\n        int b = msk[i];\n        if(!nxt[v][b]) nxt[v][b] = ++Tnode;\n        v = nxt[v][b];\n    }\n}\n\n/*-----------------------------------------------------------\n  Check if there exists any mask not present in the trie.\n  Returns true if a missing mask is found.\n-----------------------------------------------------------*/\nbool Find(int v, int d) {\n    if(v == 0 && d != 0) return true;\n    if(d == MAXN) return false;\n    for(int b = 0; b < 2; b++) {\n        if(Find(nxt[v][b], d+1)) return true;\n    }\n    return false;\n}\n\n/*-----------------------------------------------------------\n  Solve a single test case.\n  Returns 1 if there exists an uncovered point (answer YES), 0 otherwise.\n-----------------------------------------------------------*/\nint solveCase(int g_n, const int x[], const int y[], const int rad[]) {\n    // Copy input to local arrays for circles\n    P p[MAXN];\n    for(int i = 0; i < g_n; i++) {\n        p[i] = P{ (ld)x[i], (ld)y[i] };\n    }\n    \n    // Reset validator state for new test case\n    Tnode = 0;\n    msk.reset();\n    memset(nxt, 0, sizeof(nxt));\n    \n    if(g_n == 1) return 1;  // Single circle always leaves uncovered points\n\n    // Check trivial cases: disjoint circles or one inside another\n    for(int i = 0; i < g_n; i++){\n        for(int j = 0; j < i; j++){\n            ll dx = x[i] - x[j], dy = y[i] - y[j];\n            ll d2 = dx*dx + dy*dy;\n            ll s = rad[i] + rad[j], d = rad[i] - rad[j];\n            if(d2 >= s*s) {\n                msk.set(); \n                return 0;  // Disjoint circles -> no uncovered point\n            }\n            if(d2 <= d*d) {\n                msk.set();\n                if(rad[i] > rad[j]) msk[i] = 0;\n                else               msk[j] = 0;\n                return 0;  // One circle inside another -> no uncovered point\n            }\n        }\n    }\n\n    // Add trivial mask (all circles covering the point)\n    msk.reset();\n    Add();\n\n    // Sample all intersection-based masks\n    for(int i = 0; i < g_n; i++){\n        for(int j = 0; j < i; j++){\n            auto pr = circleInter(p[i], p[j], rad[i], rad[j]);\n            Do(pr.first);   msk[i]=0; msk[j]=0; Add();\n                             msk[i]=1; msk[j]=0; Add();\n                             msk[i]=0; msk[j]=1; Add();\n                             msk[i]=1; msk[j]=1; Add();\n            Do(pr.second);  msk[i]=0; msk[j]=0; Add();\n                             msk[i]=1; msk[j]=0; Add();\n                             msk[i]=0; msk[j]=1; Add();\n                             msk[i]=1; msk[j]=1; Add();\n        }\n    }\n\n    // If there's some mask not in trie, then an uncovered point exists\n    msk.reset();\n    return Find(0,0) ? 0 : 1;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution against expected behavior.\n  Returns true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Ignored (correct answer file)\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Pre-tokenize participant's output\n    vector<string> tokens_ouf;\n    for (string& line : participant_lines) {\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            tokens_ouf.push_back(token);\n        }\n    }\n\n    // Parse number of test cases\n    if (stdin_lines.empty()) return false;\n    int t = 0;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    int index_stdin = 1;\n    size_t token_index = 0;\n\n    for (int i = 0; i < t; i++) {\n        // Parse g_n\n        if (index_stdin >= (int)stdin_lines.size()) return false;\n        int g_n = 0;\n        try {\n            g_n = stoi(stdin_lines[index_stdin++]);\n        } catch (...) {\n            return false;\n        }\n        if (g_n < 1 || g_n > MAXN) return false;\n\n        // Parse circle parameters\n        int x[MAXN], y[MAXN], rad[MAXN];\n        for (int j = 0; j < g_n; j++) {\n            if (index_stdin >= (int)stdin_lines.size()) return false;\n            string line = stdin_lines[index_stdin++];\n            istringstream iss(line);\n            if (!(iss >> x[j] >> y[j] >> rad[j])) {\n                return false;\n            }\n        }\n\n        // Compute expected answer\n        int expect = solveCase(g_n, x, y, rad);\n\n        // Check participant's output\n        if (token_index >= tokens_ouf.size()) return false;\n        string verdict = tokens_ouf[token_index++];\n\n        if (verdict == \"YES\") {\n            if (expect == 0) return false;\n        } else if (verdict == \"NO\") {\n            if (expect == 1) return false;\n            vector<int> bits(g_n);\n            for (int j = 0; j < g_n; j++) {\n                if (token_index >= tokens_ouf.size()) return false;\n                string token = tokens_ouf[token_index++];\n                if (token != \"0\" && token != \"1\") return false;\n                bits[j] = stoi(token);\n            }\n            // Verify the provided hue is actually missing\n            int v = 0;\n            bool missing = false;\n            for (int j = 0; j < g_n; j++) {\n                int b = bits[j];\n                if (nxt[v][b] == 0) {\n                    missing = true;\n                    break;\n                }\n                v = nxt[v][b];\n            }\n            if (!missing) return false;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60213, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Checker for Flipping Paths problem. Validates contestant's\n  output against judge's expected answer by processing all\n  test cases and verifying path validity and grid uniformity.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse number of test cases from input\n    if (stdin_lines.empty()) \n        return false;\n    \n    int T;\n    stringstream T_ss(stdin_lines[0]);\n    if (!(T_ss >> T) || T < 1) \n        return false;\n\n    int stdin_idx = 1;      // Current position in stdin_lines\n    int stdout_idx = 0;     // Current position in stdout_lines (judge's answers)\n    int participant_idx = 0; // Current position in participant_lines (contestant's output)\n\n    for (int tc = 0; tc < T; ++tc) {\n        // Parse grid dimensions n x m\n        if (stdin_idx >= stdin_lines.size()) \n            return false;\n        \n        string nm_line = stdin_lines[stdin_idx++];\n        stringstream nm_ss(nm_line);\n        int n, m;\n        if (!(nm_ss >> n >> m) || n <= 0 || m <= 0) \n            return false;\n\n        // Parse grid (n rows of m characters)\n        vector<string> grid;\n        for (int i = 0; i < n; ++i) {\n            if (stdin_idx >= stdin_lines.size()) \n                return false;\n            \n            string row = stdin_lines[stdin_idx++];\n            if (row.size() != (size_t)m) \n                return false;\n            grid.push_back(row);\n        }\n\n        // Get judge's expected answer and contestant's actual answer\n        if (stdout_idx >= stdout_lines.size() || \n            participant_idx >= participant_lines.size()) \n            return false;\n        \n        string expected = stdout_lines[stdout_idx++];\n        string actual   = participant_lines[participant_idx++];\n\n        // Case 1: Expected answer is \"NO\"\n        if (expected == \"NO\") {\n            if (actual != \"NO\") \n                return false;\n            continue;\n        }\n\n        // Case 2: Expected answer is \"YES\" - validate contestant's solution\n        if (actual != \"YES\") \n            return false;\n\n        // Parse number of paths (k)\n        if (participant_idx >= participant_lines.size()) \n            return false;\n        \n        string k_line = participant_lines[participant_idx++];\n        int k;\n        stringstream k_ss(k_line);\n        if (!(k_ss >> k) || k < 0 || k > 400) \n            return false;\n\n        // Parse and validate each path\n        vector<string> paths;\n        for (int i = 0; i < k; ++i) {\n            if (participant_idx >= participant_lines.size()) \n                return false;\n            \n            string path = participant_lines[participant_idx++];\n            \n            // Check path length and character validity\n            if (path.length() != (size_t)(n + m - 2)) \n                return false;\n            for (char c : path) {\n                if (c != 'R' && c != 'D') \n                    return false;\n            }\n\n            // Verify path stays within grid bounds and ends at (n-1, m-1)\n            int x = 0, y = 0;\n            for (char c : path) {\n                if (c == 'R') ++y;\n                else if (c == 'D') ++x;\n                if (x >= n || y >= m) \n                    return false;\n            }\n            if (x != n - 1 || y != m - 1) \n                return false;\n            \n            paths.push_back(path);\n        }\n\n        // Apply flips to grid based on paths\n        vector<vector<int>> color(n, vector<int>(m, 0));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                color[i][j] = (grid[i][j] == 'W' ? 1 : 0);\n            }\n        }\n\n        for (const string& path : paths) {\n            int x = 0, y = 0;\n            color[x][y] ^= 1;\n            for (char c : path) {\n                if (c == 'R') ++y;\n                else if (c == 'D') ++x;\n                color[x][y] ^= 1;\n            }\n        }\n\n        // Check if final grid has uniform color\n        int first = color[0][0];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (color[i][j] != first) \n                    return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60187, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the\n  jury's answer using the input test data for context.\n  \n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Verify all files were read successfully\n    if (stdin_lines.empty() || stdout_lines.empty() || answer_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of input\n    if (stdin_lines.empty()) {\n        return false;\n    }\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (t <= 0) {\n        return false;\n    }\n\n    // Process each test case structure in input file\n    size_t idx = 1;  // Start after the first line (which contains 't')\n    for (int i = 0; i < t; i++) {\n        if (idx >= stdin_lines.size()) {\n            return false;  // Input structure incomplete\n        }\n\n        // Parse grid dimensions (n m)\n        string line = stdin_lines[idx++];\n        size_t pos = line.find(' ');\n        if (pos == string::npos) {\n            return false;  // Missing space between dimensions\n        }\n\n        int n, m;\n        try {\n            n = stoi(line.substr(0, pos));\n            m = stoi(line.substr(pos + 1));\n        } catch (...) {\n            return false;\n        }\n        if (n < 0 || m < 0) {\n            return false;\n        }\n\n        // Skip the grid lines (n lines)\n        if (idx + n > stdin_lines.size()) {\n            return false;  // Not enough grid lines\n        }\n        idx += n;\n    }\n\n    // Verify input file has exactly the expected number of lines\n    if (idx != stdin_lines.size()) {\n        return false;\n    }\n\n    // Verify answer and output files have exactly 't' lines\n    if (answer_lines.size() != t || stdout_lines.size() != t) {\n        return false;\n    }\n\n    // Compare each test case's answer\n    for (int i = 0; i < t; i++) {\n        try {\n            long long jury_ans = stoll(answer_lines[i]);\n            long long part_ans = stoll(stdout_lines[i]);\n            if (jury_ans != part_ans) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60204, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare model answer (from stdout.txt) with participant's output (from answer.txt).\n  Extract all integer tokens from both files and verify they match exactly.\n  Return true if all tokens match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> model_lines = read_file(stdout_path);\n    vector<string> part_lines  = read_file(answer_path);\n\n    vector<int> model_tokens;\n    vector<int> part_tokens;\n\n    // Extract all integer tokens from model answer\n    for (const string& line : model_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            model_tokens.push_back(num);\n        }\n    }\n\n    // Extract all integer tokens from participant's output\n    for (const string& line : part_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            part_tokens.push_back(num);\n        }\n    }\n\n    // Check token count mismatch\n    if (model_tokens.size() != part_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches\n    for (size_t i = 0; i < model_tokens.size(); ++i) {\n        if (model_tokens[i] != part_tokens[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60201, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's expected output.\n  stdin.txt contains test count, stdout.txt contains jury answers,\n  answer.txt contains participant's output. Each test case must \n  have exactly two integers per line in both outputs.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file is empty\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse test count from first line of stdin\n    int testCount;\n    try {\n        testCount = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Verify output line counts match test count\n    if (stdout_lines.size() != testCount || participant_lines.size() != testCount) {\n        return false;\n    }\n\n    // Compare each test case's two integers\n    for (int i = 0; i < testCount; i++) {\n        ll jury1, jury2;\n        stringstream jury_ss(stdout_lines[i]);\n        if (!(jury_ss >> jury1 >> jury2)) {\n            return false;\n        }\n\n        ll part1, part2;\n        stringstream part_ss(participant_lines[i]);\n        if (!(part_ss >> part1 >> part2)) {\n            return false;\n        }\n\n        // Check both integers match\n        if (part1 != jury1 || part2 != jury2) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60182, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the correct answer (stored in stdout.txt) against the \n  participant's output (stored in answer.txt) token by token.\n  Return true if all tokens match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path); // Correct answer (ans)\n    vector<string> answer_lines      = read_file(answer_path); // Participant's output (ouf)\n\n    // Extract tokens from the correct answer (stdout.txt)\n    vector<ll> ans_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            ans_tokens.push_back(num);\n        }\n    }\n\n    // Extract tokens from the participant's output (answer.txt)\n    vector<ll> ouf_tokens;\n    for (const string& line : answer_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            ouf_tokens.push_back(num);\n        }\n    }\n\n    // Check if token counts differ\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60197, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a file into a vector<string>,\n  where tokens are sequences of non-whitespace characters.\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n// Convert string to uppercase\nstring upperCase(const string& s)\n{\n    string res = s;\n    for (char &c : res) {\n        c = toupper(static_cast<unsigned char>(c));\n    }\n    return res;\n}\n\n// Compress string (placeholder for testlib's compress)\nstring compress(const string& s)\n{\n    return s;  // Tokens are short (YES/NO), no compression needed\n}\n\n// Get English ordinal suffix (1st, 2nd, 3rd, etc.)\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Returns true if valid, false otherwise with error messages.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);  // Input (unused)\n    vector<string> stdout_lines = read_file(stdout_path); // Participant's output\n    vector<string> answer_lines = read_file(answer_path); // Correct answer\n\n    int index = 0;\n    int yesCount = 0;\n    int noCount = 0;\n    string pa;\n\n    // Compare tokens up to the common length\n    int n = min(answer_lines.size(), stdout_lines.size());\n    for (; index < n; index++) {\n        string ja = upperCase(answer_lines[index]);\n        pa = upperCase(stdout_lines[index]);\n\n        // Validate correct answer token\n        if (ja != \"YES\" && ja != \"NO\") {\n            cerr << \"YES or NO expected in answer, but \" << compress(ja) \n                 << \" found [\" << (index + 1) << englishEnding(index + 1) \n                 << \" token]\\n\";\n            return false;\n        }\n\n        // Validate participant's token\n        if (pa == \"YES\") {\n            yesCount++;\n        } else if (pa == \"NO\") {\n            noCount++;\n        } else {\n            cerr << \"YES or NO expected, but \" << compress(pa) \n                 << \" found [\" << (index + 1) << englishEnding(index + 1) \n                 << \" token]\\n\";\n            return false;\n        }\n\n        // Check token match\n        if (ja != pa) {\n            cerr << \"expected \" << compress(ja) << \", found \" << compress(pa) \n                 << \" [\" << (index + 1) << englishEnding(index + 1) \n                 << \" token]\\n\";\n            return false;\n        }\n    }\n\n    // Check for extra tokens in answer\n    if (answer_lines.size() > n) {\n        cerr << \"Answer contains longer sequence [length = \" << answer_lines.size()\n             << \"], but output contains \" << n << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra tokens in output\n    if (stdout_lines.size() > n) {\n        cerr << \"Output contains longer sequence [length = \" << stdout_lines.size()\n             << \"], but answer contains \" << n << \" elements\\n\";\n        return false;\n    }\n\n    // Output success message (mimics quitf(_ok, ...))\n    if (index == 0) {\n        cerr << \"Empty output\\n\";\n    } else if (index == 1) {\n        cerr << pa << '\\n';\n    } else {\n        cerr << index << \" token(s): yes count is \" << yesCount\n             << \", no count is \" << noCount << '\\n';\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60190, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper functions for parsing boolean expressions.\n  These functions evaluate the expression for a given variable assignment.\n  On error, sets `error` to true and returns 0.\n-----------------------------------------------------------*/\nstatic int parseF(const string& expr, int& pos, int n, const vector<int>& vars, bool& error);\nstatic int parseT(const string& expr, int& pos, int n, const vector<int>& vars, bool& error);\nstatic int parseE(const string& expr, int& pos, int n, const vector<int>& vars, bool& error);\n\nstatic int parseF(const string& expr, int& pos, int n, const vector<int>& vars, bool& error)\n{\n    if (error) return 0;\n    if (pos >= (int)expr.size()) {\n        error = true;\n        return 0;\n    }\n\n    char c = expr[pos];\n    if (c == 'T' || c == 'F') {\n        pos++;\n        return (c == 'T');\n    }\n    \n    // Accept single-letter variables a..(a+n-1)\n    if (c >= 'a' && c <= 'z') {\n        int idx = c - 'a' + 1;\n        if (idx < 1 || idx > n) {\n            error = true;\n            return 0;\n        }\n        pos++;\n        return vars[idx-1];\n    }\n\n    if (c == 'x') {\n        pos++;\n        if (pos >= (int)expr.size() || !isdigit(expr[pos])) {\n            error = true;\n            return 0;\n        }\n        int idx = 0;\n        while (pos < (int)expr.size() && isdigit(expr[pos])) {\n            idx = idx * 10 + (expr[pos] - '0');\n            pos++;\n        }\n        if (idx < 1 || idx > n) {\n            error = true;\n            return 0;\n        }\n        return vars[idx-1];\n    }\n    \n    if (c == '(') {\n        pos++;\n        int v = parseE(expr, pos, n, vars, error);\n        if (error) return 0;\n        if (pos >= (int)expr.size() || expr[pos] != ')') {\n            error = true;\n            return 0;\n        }\n        pos++;\n        return v;\n    }\n    \n    error = true;\n    return 0;\n}\n\nstatic int parseT(const string& expr, int& pos, int n, const vector<int>& vars, bool& error)\n{\n    if (error) return 0;\n    int v = parseF(expr, pos, n, vars, error);\n    while (!error && pos < (int)expr.size() && expr[pos] == '&') {\n        pos++;\n        int r = parseF(expr, pos, n, vars, error);\n        v = v & r;\n    }\n    return v;\n}\n\nstatic int parseE(const string& expr, int& pos, int n, const vector<int>& vars, bool& error)\n{\n    if (error) return 0;\n    int v = parseT(expr, pos, n, vars, error);\n    while (!error && pos < (int)expr.size() && expr[pos] == '|') {\n        pos++;\n        int r = parseT(expr, pos, n, vars, error);\n        v = v | r;\n    }\n    return v;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's solution by comparing the contestant's\n  output (read from answer_path) against the problem input (read from stdin_path).\n  The model output (stdout_path) is ignored as the expected behavior is derived from input.\n  Return true if the solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read problem input and contestant's output\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> contestant_lines = read_file(answer_path);\n    // stdout_path (model output) is not used\n\n    // Tokenize both files\n    vector<string> tokens_input;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_input.push_back(token);\n        }\n    }\n\n    vector<string> tokens_ouf;\n    for (const string& line : contestant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_ouf.push_back(token);\n        }\n    }\n\n    // Check input token count: must have T followed by 2*T tokens (n and truth table)\n    if (tokens_input.empty()) {\n        return false;\n    }\n    int T;\n    try {\n        T = stoi(tokens_input[0]);\n    } catch (...) {\n        return false;\n    }\n    if (tokens_input.size() != 1 + 2 * static_cast<size_t>(T)) {\n        return false;\n    }\n\n    int index_in = 1;\n    int index_ouf = 0;\n\n    for (int tc = 0; tc < T; tc++) {\n        // Read n\n        if (index_in >= (int)tokens_input.size()) return false;\n        int n;\n        try {\n            n = stoi(tokens_input[index_in++]);\n        } catch (...) {\n            return false;\n        }\n        if (n <= 0 || n > 10) {  // n is constrained in problem (implied by expression limits)\n            return false;\n        }\n\n        // Read truth table string\n        if (index_in >= (int)tokens_input.size()) return false;\n        string want = tokens_input[index_in++];\n        int N = 1 << n;\n        if ((int)want.size() != N) {\n            return false;\n        }\n        for (char c : want) {\n            if (c != '0' && c != '1') {\n                return false;\n            }\n        }\n\n        // Read contestant's verdict\n        if (index_ouf >= (int)tokens_ouf.size()) {\n            return false;\n        }\n        string verdict = tokens_ouf[index_ouf++];\n\n        // Check monotonicity of truth table\n        bool isMono = true;\n        for (int mask = 0; mask < N && isMono; mask++) {\n            if (want[mask] == '1') {\n                for (int b = 0; b < n; b++) {\n                    if (!((mask >> b) & 1)) {\n                        int up = mask | (1 << b);\n                        if (up < N && want[up] == '0') {\n                            isMono = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isMono) {\n            if (verdict != \"No\") {\n                return false;\n            }\n            continue;  // Move to next test case\n        }\n\n        // Monotone case: must output \"Yes\" followed by expression\n        if (verdict != \"Yes\") {\n            return false;\n        }\n        if (index_ouf >= (int)tokens_ouf.size()) {\n            return false;\n        }\n        string expr = tokens_ouf[index_ouf++];\n\n        // Check operator count limit\n        int op_count = 0;\n        for (char c : expr) {\n            if (c == '&' || c == '|') {\n                op_count++;\n            }\n        }\n        int op_limit = (1 << (n - 1)) + 10;\n        if (op_count > op_limit) {\n            return false;\n        }\n\n        // Check parentheses balance and depth\n        int depth = 0, max_depth = 0;\n        for (char c : expr) {\n            if (c == '(') {\n                depth++;\n                if (depth > max_depth) max_depth = depth;\n            } else if (c == ')') {\n                depth--;\n                if (depth < 0) {\n                    return false;\n                }\n            }\n        }\n        if (depth != 0 || max_depth > 100) {\n            return false;\n        }\n\n        // Evaluate expression for all possible inputs\n        vector<int> vars(n, 0);\n        for (int mask = 0; mask < N; mask++) {\n            // Set variables according to current mask\n            for (int i = 0; i < n; i++) {\n                vars[i] = (mask >> i) & 1;\n            }\n            \n            // Parse and evaluate expression\n            int pos = 0;\n            bool error = false;\n            int got = parseE(expr, pos, n, vars, error);\n            if (error || pos != (int)expr.size()) {\n                return false;\n            }\n            \n            // Compare with expected value\n            int exp = want[mask] - '0';\n            if (got != exp) {\n                return false;\n            }\n        }\n    }\n\n    // Ensure all contestant output tokens were consumed\n    if (index_ouf != (int)tokens_ouf.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60203, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against expected \n  answer (answer.txt) as sequences of integers. Return true \n  only if all numbers match and both files have same length.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> output_lines = read_file(stdout_path);\n    vector<string> expected_lines = read_file(answer_path);\n\n    // Check if both files have identical line count\n    if (output_lines.size() != expected_lines.size()) {\n        return false;\n    }\n\n    // Compare each line as numeric value\n    for (size_t i = 0; i < output_lines.size(); ++i) {\n        try {\n            ll expected_num = stoll(expected_lines[i]);\n            ll output_num   = stoll(output_lines[i]);\n            \n            if (expected_num != output_num) {\n                return false;\n            }\n        } catch (...) {\n            // Non-numeric content or conversion error\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60195, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nstruct edge {\n    int v, w;\n};\n\nstruct DualZobristSetHasher {\n    unordered_map<int, uint64_t> R1, R2;\n    uint64_t h1 = 0, h2 = 0;\n\n    mt19937_64 rng{std::random_device{}()};\n\n    pair<uint64_t, uint64_t> randHash(int x) {\n        auto it1 = R1.find(x);\n        auto it2 = R2.find(x);\n        if (it1 != R1.end() && it2 != R2.end())\n            return {it1->second, it2->second};\n\n        uint64_t r1 = rng();\n        uint64_t r2 = rng();\n        R1.emplace(x, r1);\n        R2.emplace(x, r2);\n        return {r1, r2};\n    }\n\n    void insert(int x) {\n        auto [r1, r2] = randHash(x);\n        h1 ^= r1;\n        h2 ^= r2;\n    }\n\n    void erase(int x) {\n        auto [r1, r2] = randHash(x);\n        h1 ^= r1;\n        h2 ^= r2;\n    }\n\n    pair<uint64_t, uint64_t> hash() const {\n        return {h1, h2};\n    }\n};\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the\n  expected output using the problem input. Returns true for AC,\n  false for WA.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);  // Problem input (inf)\n    vector<string> stdout_lines = read_file(stdout_path); // Model answer (ans)\n    vector<string> answer_lines = read_file(answer_path); // Participant output (ouf)\n\n    // Convert lines to tokens for each file\n    vector<string> inf_tokens;\n    for (const string& line : stdin_lines) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            inf_tokens.push_back(token);\n        }\n    }\n\n    vector<string> ans_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    vector<string> ouf_tokens;\n    for (const string& line : answer_lines) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Indices for token traversal\n    int inf_idx = 0, ans_idx = 0, ouf_idx = 0;\n\n    // Read number of test cases\n    if (inf_idx >= inf_tokens.size()) return false;\n    int t = stoi(inf_tokens[inf_idx++]);\n\n    for (int i = 0; i < t; ++i) {\n        // Read n (nodes) and m (edges)\n        if (inf_idx + 1 >= inf_tokens.size()) return false;\n        int n = stoi(inf_tokens[inf_idx++]);\n        int m = stoi(inf_tokens[inf_idx++]);\n\n        // Build graph structure for current test case\n        vector<vector<edge>> adj(n + 1);\n        vector<pair<int, int>> edges;\n        for (int j = 0; j < m; ++j) {\n            if (inf_idx + 1 >= inf_tokens.size()) return false;\n            int u = stoi(inf_tokens[inf_idx++]);\n            int v = stoi(inf_tokens[inf_idx++]);\n            edges.emplace_back(u, v);\n        }\n\n        // Read boundary information\n        if (inf_idx >= inf_tokens.size()) return false;\n        int k = stoi(inf_tokens[inf_idx++]);\n        set<pair<uint64_t, uint64_t>> boundaries;\n        DualZobristSetHasher curBoundary;\n\n        for (int j = 0; j < k; ++j) {\n            if (inf_idx >= inf_tokens.size()) return false;\n            int b = stoi(inf_tokens[inf_idx++]);\n            vector<int> vec(b);\n            for (int l = 0; l < b; ++l) {\n                if (inf_idx >= inf_tokens.size()) return false;\n                vec[l] = stoi(inf_tokens[inf_idx++]);\n                curBoundary.insert(vec[l]);\n            }\n            boundaries.insert(curBoundary.hash());\n            for (int l = 0; l < b; ++l) {\n                curBoundary.erase(vec[l]);\n            }\n            // Verify boundary hash reset properly\n            if (curBoundary.hash() != make_pair((uint64_t)0, (uint64_t)0)) {\n                return false;\n            }\n        }\n\n        // Compare first token between model answer and participant output\n        if (ans_idx >= ans_tokens.size() || ouf_idx >= ouf_tokens.size()) {\n            return false;\n        }\n        string j_token = ans_tokens[ans_idx++];\n        string p_token = ouf_tokens[ouf_idx++];\n\n        if (j_token != p_token) {\n            return false;\n        }\n\n        // Skip processing if answer is \"No\"\n        if (j_token == \"No\") {\n            continue;\n        }\n\n        // Process edge weights from participant output\n        for (int l = 0; l < m; ++l) {\n            // Skip model answer weight (not validated beyond existence)\n            if (ans_idx >= ans_tokens.size()) {\n                return false;\n            }\n            ans_idx++;\n\n            if (ouf_idx >= ouf_tokens.size()) {\n                return false;\n            }\n            string w_str = ouf_tokens[ouf_idx++];\n            try {\n                long long w_val = stoll(w_str);\n                if (w_val < 1 || w_val > 1000000000) {\n                    return false;\n                }\n                int w = static_cast<int>(w_val);\n                auto [u, v] = edges[l];\n                adj[u].push_back({v, w});\n                adj[v].push_back({u, w});\n            } catch (...) {\n                return false;\n            }\n        }\n\n        // Dijkstra's algorithm with boundary validation\n        vector<ll> dist(n + 1, 1e18);\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;\n        dist[1] = 0;\n        pq.push({dist[1], 1});\n        curBoundary.insert(1);\n\n        while (!pq.empty()) {\n            // Remove processed boundary from expected boundaries\n            if (boundaries.count(curBoundary.hash())) {\n                boundaries.erase(curBoundary.hash());\n            }\n\n            ll d = pq.top().first;\n            int u = pq.top().second;\n            pq.pop();\n\n            if (d != dist[u]) continue;\n            curBoundary.erase(u);\n\n            for (auto& e : adj[u]) {\n                if (dist[e.v] == (ll)1e18) {\n                    curBoundary.insert(e.v);\n                }\n                if (dist[u] + e.w < dist[e.v]) {\n                    dist[e.v] = dist[u] + e.w;\n                    pq.push({dist[e.v], e.v});\n                }\n            }\n        }\n\n        // Final validation checks\n        if (curBoundary.hash() != make_pair((uint64_t)0, (uint64_t)0)) {\n            return false;\n        }\n\n        set<ll> unique_distances;\n        for (int i = 1; i <= n; ++i) {\n            unique_distances.insert(dist[i]);\n        }\n        if (static_cast<int>(unique_distances.size()) != n) {\n            return false;\n        }\n\n        if (!boundaries.empty()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60218, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer line-by-line.\n  Each line is treated as an integer. Returns true only if all\n  values match exactly and line counts are equal.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input)\n    vector<string> correct_lines     = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Verify both outputs have identical line counts\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line as integers\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        try {\n            int correct_val = stoi(correct_lines[i]);\n            int participant_val = stoi(participant_lines[i]);\n            if (correct_val != participant_val) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-integer values or conversion errors as WA\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60194, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer using:\n  - stdin.txt: contains input (n)\n  - stdout.txt: contains correct output (answer)\n  - answer.txt: contains participant's output (to validate)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if all files have at least one valid line\n    if (stdin_lines.empty() || correct_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse integer 'n' from first line of stdin\n    int n;\n    try {\n        n = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Parse participant's output (n+1 integers)\n    vector<int> participant_vals;\n    stringstream part_ss(participant_lines[0]);\n    int val;\n    while (part_ss >> val) {\n        participant_vals.push_back(val);\n    }\n    if (participant_vals.size() != (size_t)(n + 1)) {\n        return false;\n    }\n\n    // Parse correct output (n+1 integers)\n    vector<int> correct_vals;\n    stringstream corr_ss(correct_lines[0]);\n    while (corr_ss >> val) {\n        correct_vals.push_back(val);\n    }\n    if (correct_vals.size() != (size_t)(n + 1)) {\n        return false;\n    }\n\n    // Compare both vectors\n    return participant_vals == correct_vals;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60228, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer by:\n  1. Reading number of test cases (T) from stdin input\n  2. Comparing each test case's answer between stdout (jury) and answer (participant)\n  3. Outputting detailed error message on first mismatch\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if we have at least one line for stdin (should contain T)\n    if (stdin_lines.empty()) {\n        cerr << \"Empty stdin file\\n\";\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int T = 0;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid test case count in stdin\\n\";\n        return false;\n    }\n\n    // Verify we have enough lines in both output files\n    if (stdout_lines.size() < (size_t)T || participant_lines.size() < (size_t)T) {\n        cerr << \"Output file(s) have insufficient lines\\n\";\n        return false;\n    }\n\n    // Compare each test case's answer\n    for (int i = 0; i < T; ++i) {\n        try {\n            int ja = stoi(stdout_lines[i]);      // Jury's answer\n            int pa = stoi(participant_lines[i]); // Participant's answer\n\n            if (ja != pa) {\n                cerr << \"Mismatch at test \" << (i + 1) \n                     << \": expected \" << ja \n                     << \", found \" << pa << '\\n';\n                return false;\n            }\n        } catch (...) {\n            cerr << \"Failed to parse integer at test \" << (i + 1) << '\\n';\n            return false;\n        }\n    }\n\n    cout << \"All test cases passed.\" << endl;\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60189, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split a string by whitespace into tokens.\n-----------------------------------------------------------*/\nvector<string> Split(const string &output) {\n    vector<string> res;\n    stringstream ss(output);\n    string s;\n    while (ss >> s)\n        res.push_back(s);\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Concatenate a vector of strings into one string (without spaces).\n-----------------------------------------------------------*/\nstring Concat(const vector<string> &V) {\n    string s;\n    for (const auto & i : V)\n        s.append(i);\n    return s;\n}\n\n/*-----------------------------------------------------------\n  Check if a string represents a valid integer in [lef, rig].\n  Conditions: \n    - Must be non-empty digit sequence\n    - No leading zeros (unless single digit '0')\n    - Length must not exceed 9 (to prevent overflow in stoi)\n-----------------------------------------------------------*/\nbool validInteger(const string &s, int lef, int rig) {\n    if (s.length() > 9 || s.length() > 1 && s[0] == '0')\n        return false;\n    for (int i = 0; i < s.length(); i++)\n        if (!isdigit(s[i])) return false;\n    int res = stoi(s);\n    return lef <= res && res <= rig;\n}\n\n/*-----------------------------------------------------------\n  Check if string is \"try\" or \"tries\".\n-----------------------------------------------------------*/\nbool someAttempt(const string &s) {\n    return s == \"try\" || s == \"tries\";\n}\n\n/*-----------------------------------------------------------\n  Validate contestant's output against problem input.\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // Unused (corresponds to ans in original)\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Parse first line: n (teams) and m (problems)\n    if (stdin_lines.empty()) {\n        cerr << \"stdin.txt is empty\\n\";\n        return false;\n    }\n    \n    stringstream header(stdin_lines[0]);\n    int n, m;\n    if (!(header >> n >> m)) {\n        cerr << \"First line of stdin.txt must contain two integers\\n\";\n        return false;\n    }\n\n    // Validate line counts\n    if (stdin_lines.size() != (size_t)(n + 1)) {\n        cerr << \"stdin.txt should have \" << n+1 << \" lines, got \" << stdin_lines.size() << \"\\n\";\n        return false;\n    }\n    if (answer_lines.size() != (size_t)n) {\n        cerr << \"answer.txt should have \" << n << \" lines, got \" << answer_lines.size() << \"\\n\";\n        return false;\n    }\n\n    // Process each team's data\n    for (int z = 0; z < n; z++) {\n        const string& input_token = stdin_lines[1 + z];\n        const string& output_line = answer_lines[z];\n        \n        // Compare contestant's output (without spaces) to input token\n        vector<string> tokens = Split(output_line);\n        string concated = Concat(tokens);\n        if (concated != input_token) {\n            if (concated.length() != input_token.length()) {\n                cerr << \"Mismatch at line \" << (z+1) \n                     << \" (lengths: expected \" << input_token.length() \n                     << \", got \" << concated.length() << \")\\n\";\n            } else {\n                int ind = 0;\n                while (ind < (int)concated.length() && \n                       ind < (int)input_token.length() && \n                       concated[ind] == input_token[ind])\n                    ind++;\n                cerr << \"Mismatch at line \" << (z+1) \n                     << \" (at \" << ind << \": '\" << input_token[ind] \n                     << \"', got '\" << concated[ind] << \"')\\n\";\n            }\n            return false;\n        }\n\n        // Validate token count\n        if (tokens.size() < 2) {\n            cerr << \"Too few tokens at line \" << (z+1) << \"\\n\";\n            return false;\n        }\n\n        // Validate solved problems count (0 to m)\n        if (!validInteger(tokens[0], 0, m)) {\n            cerr << \"Invalid token at line \" << (z+1) << \" (index 0)\\n\";\n            return false;\n        }\n        int problems = stoi(tokens[0]);\n\n        // Validate penalty (0 to 10^9)\n        if (!validInteger(tokens[1], 0, 1000000000)) {\n            cerr << \"Invalid token at line \" << (z+1) << \" (index 1)\\n\";\n            return false;\n        }\n        int penalty = stoi(tokens[1]);\n\n        // Process remaining tokens\n        int leftAll = m;\n        int pnt = 2;\n        while (pnt < (int)tokens.size()) {\n            // Case 1: <attempts> <\"try\"|\"tries\">\n            if (pnt + 1 < (int)tokens.size() && someAttempt(tokens[pnt + 1])) {\n                if (!validInteger(tokens[pnt], 1, 100)) {\n                    cerr << \"Invalid token at line \" << (z+1) << \" (index \" << pnt << \")\\n\";\n                    return false;\n                }\n                int attempts = stoi(tokens[pnt]);\n                if ((tokens[pnt + 1] == \"try\" && attempts > 1) ||\n                    (tokens[pnt + 1] == \"tries\" && attempts == 1)) {\n                    cerr << \"Tries mismatch at line \" << (z+1) << \" (index \" << pnt << \")\\n\";\n                    return false;\n                }\n                leftAll--;\n                pnt += 2;\n            } \n            // Case 2: <time> <attempts> <\"try\"|\"tries\">\n            else if (pnt + 2 < (int)tokens.size() && someAttempt(tokens[pnt + 2])) {\n                if (!validInteger(tokens[pnt], 0, 299)) {\n                    cerr << \"Invalid token at line \" << (z+1) << \" (index \" << pnt << \")\\n\";\n                    return false;\n                }\n                int time = stoi(tokens[pnt]);\n                \n                if (!validInteger(tokens[pnt + 1], 1, 100)) {\n                    cerr << \"Invalid token at line \" << (z+1) << \" (index \" << (pnt+1) << \")\\n\";\n                    return false;\n                }\n                int attempts = stoi(tokens[pnt + 1]);\n                \n                problems--;\n                penalty -= (time + 20 * (attempts - 1));\n                \n                if ((tokens[pnt + 2] == \"try\" && attempts > 1) ||\n                    (tokens[pnt + 2] == \"tries\" && attempts == 1)) {\n                    cerr << \"Tries mismatch at line \" << (z+1) << \" (index \" << pnt << \")\\n\";\n                    return false;\n                }\n                leftAll--;\n                pnt += 3;\n            } \n            // Invalid token sequence\n            else {\n                cerr << \"Invalid tokens at line \" << (z+1) << \" (index \" << pnt << \")\\n\";\n                return false;\n            }\n        }\n\n        // Final validation checks\n        if (problems != 0) {\n            cerr << \"Solved problems mismatch at line \" << (z+1) \n                 << \" (expected 0, got \" << problems << \")\\n\";\n            return false;\n        }\n        if (penalty != 0) {\n            cerr << \"Penalty mismatch at line \" << (z+1) \n                 << \" (expected 0, got \" << penalty << \")\\n\";\n            return false;\n        }\n        if (leftAll < 0) {\n            cerr << \"Too many problems attempted at line \" << (z+1) \n                 << \" (m=\" << m << \", attempted=\" << (m - leftAll) << \")\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60200, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct answer \n  (stdout_path) by verifying sequences of integers token-by-token.\n  Returns true if sequences are identical in both length and content.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines   = read_file(stdout_path);  // Correct answer\n    vector<string> ouf_lines   = read_file(answer_path);  // Participant's output\n\n    // Tokenize correct answer into sequence of integers\n    vector<long long> ans_tokens;\n    for (const string& line : ans_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                // Validate token is a proper integer\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    return false;  // Trailing invalid characters\n                ans_tokens.push_back(num);\n            } catch (...) {\n                return false;  // Conversion failed\n            }\n        }\n    }\n\n    // Tokenize participant's output into sequence of integers\n    vector<long long> ouf_tokens;\n    for (const string& line : ouf_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    return false;\n                ouf_tokens.push_back(num);\n            } catch (...) {\n                return false;\n            }\n        }\n    }\n\n    // Verify sequences have identical length\n    if (ans_tokens.size() != ouf_tokens.size()) \n        return false;\n\n    // Verify each corresponding integer matches\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) \n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60209, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer using\n  the problem's input to determine number of test cases (T).\n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> out_lines   = read_file(stdout_path);  // Participant's output\n    vector<string> ans_lines   = read_file(answer_path);  // Jury's expected answer\n\n    // Check if input file has at least one line for T\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse T (number of test cases) from first line of stdin\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n        if (T < 1 || T > 100)  // T must be in [1, 100] as per original code\n            return false;\n    } catch (...) {\n        return false;\n    }\n\n    // Verify correct number of lines in answer and output files\n    if (ans_lines.size() != T || out_lines.size() != T) {\n        return false;\n    }\n\n    // Compare each test case's expected vs actual answer\n    for (int i = 0; i < T; ++i) {\n        try {\n            int expected = stoi(ans_lines[i]);\n            int actual   = stoi(out_lines[i]);\n            if (expected != actual) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60216, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against correct answer (answer.txt).\n  Both files must contain exactly one integer. Return true if values match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> correct_lines = read_file(answer_path);\n    vector<string> participant_lines = read_file(stdout_path);\n\n    // Must have exactly one non-empty line in each file\n    if (correct_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        int correct_value = stoi(correct_lines[0]);\n        int participant_value = stoi(participant_lines[0]);\n        \n        // Core comparison logic: check if integers match\n        return (correct_value == participant_value);\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60225, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into a flat vector of tokens by\n  splitting each line on whitespace.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\nstruct Node {\n    int v, s, p;\n    Node *l, *r;\n    Node(int x) : v(x), s(1), p(uniform_int_distribution<int>(0, 1e9)(rng)), l(nullptr), r(nullptr) {}\n};\n\nint sz(Node *t) {\n    return t ? t->s : 0;\n}\n\nvoid update(Node *t) {\n    if (t) {\n        t->s = 1 + sz(t->l) + sz(t->r);\n    }\n}\n\nNode* merge(Node *a, Node *b) {\n    if (!a || !b) {\n        return a ? a : b;\n    }\n    if (a->p < b->p) {\n        a->r = merge(a->r, b);\n        update(a);\n        return a;\n    } else {\n        b->l = merge(a, b->l);\n        update(b);\n        return b;\n    }\n}\n\nvoid split(Node *t, int k, Node *&a, Node *&b) {\n    if (!t) {\n        a = b = nullptr;\n        return;\n    }\n    if (sz(t->l) >= k) {\n        split(t->l, k, a, t->l);\n        b = t;\n    } else {\n        split(t->r, k - sz(t->l) - 1, t->r, b);\n        a = t;\n    }\n    update(t);\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing:\n  - stdin.txt (input test data)\n  - stdout.txt (participant's output)\n  - answer.txt (expected output)\n  \n  Returns true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    vector<string> stdin_tokens      = tokenize(stdin_lines);\n    vector<string> stdout_tokens     = tokenize(stdout_lines);\n    vector<string> answer_tokens     = tokenize(answer_lines);\n\n    // Validate input token counts\n    if (stdin_tokens.empty() || answer_tokens.size() < 2 || stdout_tokens.size() < 2) {\n        return false;\n    }\n\n    // Parse input test data (n and array)\n    int n = stoi(stdin_tokens[0]);\n    if (static_cast<int>(stdin_tokens.size()) < 1 + n) {\n        return false;\n    }\n    vector<int> original;\n    for (int i = 1; i <= n; i++) {\n        original.push_back(stoi(stdin_tokens[i]));\n    }\n\n    // Build treap from original array\n    Node *t = nullptr;\n    for (int i = 0; i < n; i++) {\n        t = merge(t, new Node(original[i]));\n    }\n\n    // Parse expected answer (minimum cost and jury moves)\n    long long expCost = stoll(answer_tokens[0]);\n    long long juryM   = stoll(answer_tokens[1]);\n\n    // Parse participant's output\n    long long partCost = stoll(stdout_tokens[0]);\n    long long m        = stoll(stdout_tokens[1]);\n\n    if (m < 0) {\n        return false;\n    }\n\n    if (static_cast<int>(stdout_tokens.size()) < 2 + 2 * m) {\n        return false;\n    }\n\n    // Process participant's moves\n    long long sum = 0;\n    vector<pair<int, int>> moves;\n    int idx = 2;\n    for (int i = 0; i < m; i++) {\n        int x = stoi(stdout_tokens[idx++]);\n        int y = stoi(stdout_tokens[idx++]);\n        if (x < 1 || x > n || y < 1 || y > n) {\n            return false;\n        }\n        sum += y;\n        moves.push_back({x, y});\n    }\n\n    // Validate cost calculations\n    if (sum != partCost) {\n        return false;\n    }\n    if (partCost != expCost) {\n        return false;\n    }\n\n    // Simulate participant's moves on the treap\n    for (auto [x, y] : moves) {\n        Node *a, *b, *c;\n        split(t, x - 1, a, b);\n        split(b, 1, b, c);\n        t = merge(a, c);\n        split(t, y - 1, a, c);\n        t = merge(merge(a, b), c);\n    }\n\n    // Verify final sequence is sorted\n    for (int i = 1; i < n; i++) {\n        Node *a, *b, *c;\n        split(t, 1, a, b);\n        split(b, 1, b, c);\n        if (a->v > b->v) {\n            return false;\n        }\n        t = merge(merge(a, b), c);\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60236, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Convert file contents into stringstreams for token processing\n    stringstream inf_ss, ouf_ss, ans_ss;\n    for (const string& line : stdin_lines)  inf_ss << line << '\\n';\n    for (const string& line : stdout_lines) ouf_ss << line << '\\n';\n    for (const string& line : answer_lines) ans_ss << line << '\\n';\n\n    int t;\n    // Read number of test cases with bounds check\n    if (!(inf_ss >> t) || t < 1 || t > 200000) \n        return false;\n\n    int sumN = 0, sumM = 0;\n    for (int tc = 0; tc < t; tc++) {\n        int n;\n        // Read n with bounds check (1  n  100000)\n        if (!(inf_ss >> n) || n < 1 || n > 100000) \n            return false;\n        sumN += n;\n        if (sumN > 200000) \n            return false;  // Cumulative n constraint\n\n        int m;\n        // Read m with bounds check (1  m  100000)\n        if (!(inf_ss >> m) || m < 1 || m > 100000) \n            return false;\n        sumM += m;\n        if (sumM > 200000) \n            return false;  // Cumulative m constraint\n\n        int k;\n        // Read k with bounds check (1  k  1e9)\n        if (!(inf_ss >> k) || k < 1 || k > 1000000000) \n            return false;\n\n        int w;\n        // Read w with bounds check (k  w  1e9)\n        if (!(inf_ss >> w) || w < k || w > 1000000000) \n            return false;\n\n        // Read red cells (array a) with duplicate check\n        set<int> sa;\n        vector<int> a;\n        for (int i = 0; i < n; i++) {\n            int x;\n            if (!(inf_ss >> x) || x < 1 || x > w) \n                return false;\n            if (sa.count(x)) \n                return false;  // Duplicate cell\n            sa.insert(x);\n            a.push_back(x);\n        }\n\n        // Read black cells (array b) with duplicate and overlap check\n        set<int> sb;\n        vector<int> b;\n        for (int i = 0; i < m; i++) {\n            int x;\n            if (!(inf_ss >> x) || x < 1 || x > w) \n                return false;\n            if (sa.count(x) || sb.count(x)) \n                return false;  // Duplicate or overlaps with red\n            sb.insert(x);\n            b.push_back(x);\n        }\n\n        // Read correct answer and participant's output\n        int answer, outAns;\n        if (!(ans_ss >> answer) || answer < -1 || answer > n) \n            return false;\n        if (!(ouf_ss >> outAns) || outAns < -1 || outAns > n) \n            return false;\n        if (answer != outAns) \n            return false;  // Mismatched answer\n\n        if (answer == -1) continue;  // Skip validation for impossible case\n\n        // Read participant's strip positions\n        vector<int> pa;\n        for (int i = 0; i < outAns; i++) {\n            int x;\n            if (!(ouf_ss >> x) || x < 1 || x > w) \n                return false;\n            pa.push_back(x);\n        }\n\n        // Read correct strip positions (for consumption only)\n        for (int i = 0; i < answer; i++) {\n            int x;\n            if (!(ans_ss >> x) || x < 1 || x > w) \n                return false;\n        }\n\n        // Sort all arrays for validation\n        sort(pa.begin(), pa.end());\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n\n        int idx = 0, idx2 = 0;\n        // Validate each strip placement\n        for (int i = 0; i < outAns; i++) {\n            // Check adjacent strips don't overlap\n            if (i < outAns - 1) {\n                if (pa[i] + k > pa[i+1]) \n                    return false;\n            } \n            // Check last strip doesn't exceed width\n            else {\n                if (pa[i] + k - 1 > w) \n                    return false;\n            }\n\n            // Check coverage of red cells\n            while (idx < n && a[idx] >= pa[i] && a[idx] < pa[i] + k) \n                idx++;\n\n            // Skip black cells before current strip\n            while (idx2 < m && b[idx2] < pa[i]) \n                idx2++;\n\n            // Check no black cell in current strip\n            if (idx2 < m && b[idx2] >= pa[i] && b[idx2] < pa[i] + k) \n                return false;\n        }\n        // Ensure all red cells were covered\n        if (idx < n) \n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60217, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst string YES = \"Puss in Boots\";\nconst string NO = \"Donkey\";\n\n/*-----------------------------------------------------------\n  Convert string to uppercase for case-insensitive comparison.\n-----------------------------------------------------------*/\nstring toUpperCase(const string& s) {\n    string res = s;\n    for (char& c : res) \n        c = toupper(static_cast<unsigned char>(c));\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against model answer:\n  - Both files must have same number of tokens\n  - Each token must be \"Puss in Boots\" or \"Donkey\" (case-insensitive)\n  - Corresponding tokens must match exactly\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> model_answer = read_file(answer_path);\n    vector<string> participant_output = read_file(stdout_path);\n\n    // Check if both files have identical number of tokens\n    if (model_answer.size() != participant_output.size()) \n        return false;\n\n    const string YES_UPPER = toUpperCase(YES);\n    const string NO_UPPER = toUpperCase(NO);\n\n    for (size_t i = 0; i < model_answer.size(); i++) {\n        string ja = toUpperCase(model_answer[i]);\n        string pa = toUpperCase(participant_output[i]);\n\n        // Validate model answer token\n        if (ja != YES_UPPER && ja != NO_UPPER) \n            return false;\n\n        // Validate participant's token\n        if (pa != YES_UPPER && pa != NO_UPPER) \n            return false;\n\n        // Check token correspondence\n        if (ja != pa) \n            return false;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60215, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Create stringstreams from file contents\n    stringstream inf_ss, ans_ss, ouf_ss;\n    for (const auto& line : stdin_lines)  inf_ss << line << ' ';\n    for (const auto& line : stdout_lines) ouf_ss << line << ' ';\n    for (const auto& line : answer_lines) ans_ss << line << ' ';\n\n    // Parse tokens with validation\n    int a, o, n;\n    if (!(ans_ss >> a) || a < 0 || a > 1000000) return false;\n    if (!(ouf_ss >> o) || o < 0 || o > 1000000) return false;\n    if (!(inf_ss >> n) || n < 3 || n > 1000) return false;\n\n    set<pair<int, int>> st;\n    vector<int> deg(n + 1, 0);\n\n    // Process input edges (tree structure)\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        if (!(inf_ss >> u >> v) || u < 1 || u > n || v < 1 || v > n) \n            return false;\n\n        deg[u]++;\n        deg[v]++;\n        if (u > v) swap(u, v);\n        st.insert({u, v});\n    }\n\n    // Check participant's move count matches expected\n    if (a != o) return false;\n\n    // Validate each move operation\n    for (int i = 0; i < o; ++i) {\n        int x, y, z;\n        if (!(ouf_ss >> x >> y >> z)) \n            return false;\n        \n        // Nodes must be distinct\n        if (x == y || y == z || x == z) \n            return false;\n        \n        // Check required edges exist\n        pair<int, int> edge_xy = {min(x, y), max(x, y)};\n        pair<int, int> edge_zy = {min(z, y), max(z, y)};\n        if (st.find(edge_xy) == st.end() || st.find(edge_zy) == st.end()) \n            return false;\n        \n        // Check forbidden edge doesn't exist\n        pair<int, int> edge_xz = {min(x, z), max(x, z)};\n        if (st.find(edge_xz) != st.end()) \n            return false;\n\n        // Update tree structure after move\n        st.erase(edge_zy);\n        deg[y]--;\n        st.insert(edge_xz);\n        deg[x]++;\n    }\n\n    // Final validation: must form a star tree\n    int deg1 = 0, degn = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (deg[i] == 1) deg1++;\n        else if (deg[i] == n - 1) degn++;\n        else return false;  // Invalid degree\n    }\n    return (deg1 == n - 1 && degn == 1);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60232, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against the correct answer\n  using the input data. This involves:\n  1. Parsing the input file (stdin.txt) to extract constraints.\n  2. Parsing the expected answer (answer.txt) and contestant's output (stdout.txt).\n  3. Ensuring all data meets problem constraints and matches exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // --- Step 1: Parse n and k from first line of stdin ---\n    if (stdin_lines.empty()) \n        return false;\n    \n    istringstream iss(stdin_lines[0]);\n    int n, k;\n    string dummy;\n    if (!(iss >> n) || !(iss >> k) || (iss >> dummy)) \n        return false;\n    \n    if (n < 2 || n > 200000 || k < 1 || k > 200000) \n        return false;\n\n    // Ensure total lines match expectation: 3 (n,k + a + b) + k (subway lines)\n    if (stdin_lines.size() != 3 + k) \n        return false;\n\n    // --- Step 2: Parse a[i] from second line ---\n    istringstream iss_a(stdin_lines[1]);\n    for (int i = 0; i < k; ++i) {\n        int x;\n        if (!(iss_a >> x) || x < 1 || x > 1000000) \n            return false;\n    }\n    if (iss_a >> dummy) \n        return false;\n\n    // --- Step 3: Parse b[i] from third line ---\n    istringstream iss_b(stdin_lines[2]);\n    for (int i = 0; i < k; ++i) {\n        int x;\n        if (!(iss_b >> x) || x < 1 || x > 1000000) \n            return false;\n    }\n    if (iss_b >> dummy) \n        return false;\n\n    // --- Step 4: Parse k subway lines (each has 2*p_i - 1 numbers after p_i) ---\n    for (int i = 0; i < k; ++i) {\n        istringstream iss_sub(stdin_lines[3 + i]);\n        int total;\n        if (!(iss_sub >> total) || total < 2 || total > n) \n            return false;\n        \n        for (int j = 0; j < 2 * total - 1; ++j) {\n            int val;\n            if (!(iss_sub >> val) || val < 1 || val > 1000000000) \n                return false;\n        }\n        if (iss_sub >> dummy) \n            return false;\n    }\n\n    // --- Step 5: Parse expected answer (answer.txt) ---\n    if (answer_lines.size() != 1) \n        return false;\n    \n    istringstream iss_ans(answer_lines[0]);\n    vector<long long> expected;\n    for (int i = 0; i < n - 1; ++i) {\n        long long val;\n        if (!(iss_ans >> val) || val < 0 || val > 1000000000000000000LL) \n            return false;\n        expected.push_back(val);\n    }\n    if (iss_ans >> dummy) \n        return false;\n\n    // --- Step 6: Parse contestant's output (stdout.txt) ---\n    if (stdout_lines.size() != 1) \n        return false;\n    \n    istringstream iss_ouf(stdout_lines[0]);\n    vector<long long> actual;\n    for (int i = 0; i < n - 1; ++i) {\n        long long val;\n        if (!(iss_ouf >> val) || val < 0 || val > 1000000000000000000LL) \n            return false;\n        actual.push_back(val);\n    }\n    if (iss_ouf >> dummy) \n        return false;\n\n    // --- Step 7: Compare expected and actual outputs ---\n    for (int i = 0; i < n - 1; ++i) {\n        if (actual[i] != expected[i]) \n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60220, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against model answer.\n  Both must contain exactly one integer with no extra data.\n  Returns true if:\n    1) Model answer (stdout.txt) has exactly one valid integer\n    2) Participant output (answer.txt) has exactly one valid integer\n    3) Both integers match\n  Otherwise returns false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);  // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path); // Corresponds to 'ans' (model answer)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to 'ouf' (participant output)\n\n    // Check model answer contains exactly one line\n    if (stdout_lines.size() != 1) {\n        return false;\n    }\n\n    // Check participant output contains exactly one line\n    if (participant_lines.size() != 1) {\n        return false;\n    }\n\n    // Parse expected integer from model answer\n    stringstream ss_exp(stdout_lines[0]);\n    int expected;\n    ss_exp >> expected;\n    // Verify no parsing errors and no extra data\n    if (ss_exp.fail() || ss_exp.peek() != EOF) {\n        return false;\n    }\n\n    // Parse actual integer from participant output\n    stringstream ss_act(participant_lines[0]);\n    int actual;\n    ss_act >> actual;\n    // Verify no parsing errors and no extra data\n    if (ss_act.fail() || ss_act.peek() != EOF) {\n        return false;\n    }\n\n    // Final comparison\n    return (expected == actual);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60241, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer.\n  Returns true if output is correct, false otherwise.\n  Implements:\n    - Check for leading newline in participant's output\n    - Compare three integer values\n    - Verify no extra output exists\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check participant's output doesn't start with empty line (PE)\n    if (participant_lines.empty() || participant_lines[0].empty()) {\n        return false;\n    }\n\n    // Extract tokens from participant's output\n    vector<string> p_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            p_tokens.push_back(token);\n        }\n    }\n\n    // Extract tokens from correct output (jury's answer)\n    vector<string> c_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            c_tokens.push_back(token);\n        }\n    }\n\n    // Must have exactly 3 tokens in both outputs\n    if (p_tokens.size() != 3 || c_tokens.size() != 3) {\n        return false;\n    }\n\n    // Compare each token as integers\n    for (int i = 0; i < 3; i++) {\n        try {\n            int p_val = stoi(p_tokens[i]);\n            int c_val = stoi(c_tokens[i]);\n            if (p_val != c_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60221, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to lowercase by processing each character:\n  - Lowercase letters are kept as-is\n  - Uppercase letters are converted to lowercase\n  Note: Non-alphabet characters may be altered due to the logic\n-----------------------------------------------------------*/\nstring lowString(string s) {\n    string res = \"\";\n    for (auto ch : s) {\n        if (ch >= 'a' && ch <= 'z') {\n            res += ch;\n            continue;\n        }\n        ch -= 'A' - 'a';\n        res += ch;\n    }\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output against jury's answer:\n  1. Parse number of test cases (T) from stdin.txt\n  2. For each test case i in [0, T-1]:\n      a. Get expected answer from stdout.txt (jury's output)\n      b. Get participant's answer from answer.txt\n      c. Process both strings through lowString()\n      d. If any comparison fails, reject solution\n  3. Return true only if all test cases pass\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    if (stdin_lines.empty()) {\n        cerr << \"Empty or missing stdin file\\n\";\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int T = 0;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid test case count in stdin\\n\";\n        return false;\n    }\n\n    vector<string> expected_lines = read_file(stdout_path);  // Jury's answers (ans)\n    vector<string> actual_lines   = read_file(answer_path);  // Participant's output (ouf)\n\n    // Verify sufficient lines exist for all test cases\n    if (expected_lines.size() < T || actual_lines.size() < T) {\n        cerr << \"Insufficient lines in output files\\n\";\n        return false;\n    }\n\n    for (int i = 0; i < T; ++i) {\n        string expected = lowString(expected_lines[i]);\n        string actual   = lowString(actual_lines[i]);\n\n        if (expected != actual) {\n            cerr << \"Mismatch at test \" << i+1 << \":\\n\";\n            cerr << \"Expected: '\" << expected_lines[i] << \"'\\n\";\n            cerr << \"Found:    '\" << actual_lines[i] << \"'\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60224, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the expected output (from stdout.txt) and the \n  participant's output (from answer.txt) line by line. \n  Both files are read and trimmed as in read_file(). \n  If line counts differ or any line content differs, \n  print error to cerr and return false. Otherwise, return true.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare expected output (stdout_lines) vs participant output (participant_lines)\n    if (stdout_lines.size() != participant_lines.size()) {\n        cerr << \"Number of lines differ: expected \" << stdout_lines.size() \n             << \", found \" << participant_lines.size() << \"\\n\";\n        return false;\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); i++) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            cerr << \"Line \" << (i+1) << \" differs: expected '\";\n            cerr << stdout_lines[i] << \"', found '\" << participant_lines[i] << \"'\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60240, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against the correct output (stdout.txt).\n  The first line of stdin.txt specifies the number of test cases (t).\n  For each of the t test cases, compare the corresponding lines.\n  Return true if all match, else false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if stdin has valid test case count\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (t < 0) {\n        return false;\n    }\n\n    // Ensure sufficient lines in both participant and correct outputs\n    if (participant_lines.size() < (size_t)t || stdout_lines.size() < (size_t)t) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < t; ++i) {\n        try {\n            int participant_val = stoi(participant_lines[i]);\n            int correct_val     = stoi(stdout_lines[i]);\n            if (participant_val != correct_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60251, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare correct answer (from stdout.txt) against participant's output (from answer.txt).\n  Both files must contain exactly one integer. Returns true only if integers match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify both answer files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    // Parse correct answer integer from stdout.txt (corresponds to 'ans' in original)\n    int ja;\n    stringstream ss_correct(stdout_lines[0]);\n    ss_correct >> ja;\n    if (ss_correct.fail() || ss_correct.peek() != EOF) {\n        return false;  // Failed to parse or extra characters\n    }\n\n    // Parse participant's output integer from answer.txt (corresponds to 'ouf' in original)\n    int pa;\n    stringstream ss_participant(participant_lines[0]);\n    ss_participant >> pa;\n    if (ss_participant.fail() || ss_participant.peek() != EOF) {\n        return false;  // Failed to parse or extra characters\n    }\n\n    // Compare values (core functionality from original code)\n    return ja == pa;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60223, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer by comparing\n  sequences of signed integers token-by-token. The problem input\n  (stdin_path) is read but unused in validation.\n\n  Steps:\n  1. Tokenize both output files by splitting lines and extracting tokens\n  2. Verify token counts match between jury's answer and participant's output\n  3. Convert each token to long long and compare values\n  4. Return true only if all tokens match numerically and format is valid\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin is unused but required by template structure)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Tokenize jury's answer (from stdout_path)\n    vector<string> jury_tokens;\n    for (string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            jury_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize participant's output (from answer_path)\n    vector<string> participant_tokens;\n    for (string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Verify token count matches\n    if (jury_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token as numeric value\n    for (size_t i = 0; i < jury_tokens.size(); i++) {\n        try {\n            // Convert jury token (with full token validation)\n            size_t pos_j;\n            long long jury_val = stoll(jury_tokens[i], &pos_j, 10);\n            if (pos_j != jury_tokens[i].size()) {\n                return false;  // Extra characters in token\n            }\n\n            // Convert participant token (with full token validation)\n            size_t pos_p;\n            long long participant_val = stoll(participant_tokens[i], &pos_p, 10);\n            if (pos_p != participant_tokens[i].size()) {\n                return false;  // Extra characters in token\n            }\n\n            // Verify numeric values match\n            if (jury_val != participant_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;  // Invalid number format or overflow\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60229, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer.\n  - stdin_path:   Input test case (not used in this checker)\n  - stdout_path:  Jury's answer (corresponds to 'ans' in testlib)\n  - answer_path:  Participant's output (corresponds to 'ouf' in testlib)\n  Returns true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> correct_lines = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> output_lines  = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if participant provided at least as many lines as expected\n    if (output_lines.size() < correct_lines.size()) {\n        return false;\n    }\n\n    // Compare each corresponding integer value\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        try {\n            int correct_val = stoi(correct_lines[i]);\n            int output_val  = stoi(output_lines[i]);\n            \n            if (correct_val != output_val) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-integer values or conversion errors\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60244, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output (answer_path) against the input (stdin_path).\n  The model answer (stdout_path) is not used in this problem.\n  Returns true if the participant's solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // Ignored (not used in this problem)\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Validate input file structure (must have 3 lines for initial state)\n    if (stdin_lines.size() < 3) {\n        return false;\n    }\n    string s_o = stdin_lines[0];\n    string s_g = stdin_lines[1];\n    string s_r = stdin_lines[2];\n\n    // Tokenize participant's output (moves)\n    vector<string> tokens;\n    for (string& line : answer_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n\n    // Must have at least one token (for k)\n    if (tokens.empty()) {\n        return false;\n    }\n\n    // Parse number of moves (k)\n    int k;\n    try {\n        k = stoi(tokens[0]);\n    } catch (...) {\n        return false;\n    }\n    if (k < 0 || k > 240) {\n        return false;\n    }\n    if (tokens.size() != 1 + k) {\n        return false;\n    }\n\n    // Process each move\n    for (int i = 0; i < k; i++) {\n        string move = tokens[1 + i];\n        if (move.length() != 2) {\n            return false;\n        }\n\n        char circle = move[0];\n        char amount_char = move[1];\n\n        if (!isdigit(amount_char)) {\n            return false;\n        }\n        int amount = amount_char - '0';\n\n        // Handle outer/green/red circle rotations\n        if (circle == 'o' || circle == 'g' || circle == 'r') {\n            if (amount < 1 || amount > 9) {\n                return false;\n            }\n            if (circle == 'o') {\n                rotate(s_o.begin(), s_o.begin() + 10 - amount, s_o.end());\n            } else if (circle == 'g') {\n                rotate(s_g.begin(), s_g.begin() + 10 - amount, s_g.end());\n            } else {  // circle == 'r'\n                rotate(s_r.begin(), s_r.begin() + 10 - amount, s_r.end());\n            }\n        } \n        // Handle center rotation\n        else if (circle == 'c') {\n            if (amount < 1 || amount > 2) {\n                return false;\n            }\n            string o_triple = s_o.substr(0, 3);\n            string g_triple = s_g.substr(0, 3);\n            string r_triple = s_r.substr(0, 3);\n            if (amount == 2) {\n                s_o.replace(0, 3, r_triple);\n                s_g.replace(0, 3, o_triple);\n                s_r.replace(0, 3, g_triple);\n            } else {  // amount == 1\n                s_o.replace(0, 3, g_triple);\n                s_g.replace(0, 3, r_triple);\n                s_r.replace(0, 3, o_triple);\n            }\n        } \n        // Invalid circle identifier\n        else {\n            return false;\n        }\n    }\n\n    // Verify final state (all beads must be uniform color per circle)\n    for (char bead : s_o) {\n        if (bead != 'o') return false;\n    }\n    for (char bead : s_g) {\n        if (bead != 'g') return false;\n    }\n    for (char bead : s_r) {\n        if (bead != 'r') return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60233, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file token-by-token into a vector<string>,\n  where each token is a whitespace-separated word (similar to testlib's readWord).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    // Read all tokens (words) separated by whitespace\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens from correct answer (stdout_path) and participant's output (answer_path).\n  Returns true if all tokens match exactly in sequence and quantity, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> correct_tokens = read_file(stdout_path);   // Corresponds to 'ans' in original\n    vector<string> participant_tokens = read_file(answer_path); // Corresponds to 'ouf' in original\n\n    // Check if token sequences have identical length and content\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Corresponds to 'inf' in original (unused in comparison)\n    const string stdout_path = \"stdout.txt\";  // Corresponds to 'ans' (correct answer)\n    const string answer_path = \"answer.txt\";  // Corresponds to 'ouf' (participant's output)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60249, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from judge's output (stdout_path)\n  and contestant's output (answer_path). Each corresponding pair\n  must satisfy |a-b| <= EPS (absolute) or |a-b|/max(|a|,|b|) <= EPS\n  (relative). Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool doubleCompare(double expected, double result, double EPS) {\n    // Handle special values (NaN, Inf)\n    if (std::isnan(expected)) {\n        return std::isnan(result);\n    }\n    if (std::isinf(expected)) {\n        return std::isinf(result) && ((expected < 0) == (result < 0));\n    }\n    if (std::isnan(result) || std::isinf(result)) {\n        return false;\n    }\n\n    double diff = std::abs(result - expected);\n    if (diff <= EPS) {\n        return true;  // Absolute error check\n    }\n\n    double ind = std::min((std::abs(result) + std::abs(expected)) / 2.0, \n                          std::max(std::abs(result), std::abs(expected)));\n    // Avoid division by near-zero values\n    if (ind < 1e-9) {\n        return diff <= EPS;\n    }\n    return (diff / ind) <= EPS;  // Relative error check\n}\n\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Judge's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Verify both files have same number of lines (each containing one double)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each corresponding double value\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            double judge_val    = stod(stdout_lines[i]);\n            double participant_val = stod(participant_lines[i]);\n\n            if (!doubleCompare(judge_val, participant_val, EPS)) {\n                return false;\n            }\n        } catch (...) {\n            // Non-numeric content or parsing error  invalid\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";  // Corresponds to judge's answer (ans)\n    const string answer_path = \"answer.txt\";  // Corresponds to contestant's output (ouf)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60243, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing contestant's output (from \n  answer.txt) against correct answer (from stdout.txt). \n  Expects both files to contain exactly two lines with \n  integer values. First integers must match (f values), \n  second integers must match (cnt values).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (testlib's 'ans')\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (testlib's 'ouf')\n\n    // Verify both output files have exactly two lines (as expected by original logic)\n    if (stdout_lines.size() != 2 || participant_lines.size() != 2) {\n        return false;\n    }\n\n    try {\n        ll correct_f = stoll(stdout_lines[0]);\n        ll correct_cnt = stoll(stdout_lines[1]);\n        ll out_f = stoll(participant_lines[0]);\n        ll out_cnt = stoll(participant_lines[1]);\n\n        // Check both values match between correct answer and contestant's output\n        if (out_f != correct_f) \n            return false;\n        if (out_cnt != correct_cnt) \n            return false;\n        \n        return true;\n    } catch (...) {\n        // Handle invalid number formats\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60230, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing the jury's answer\n  (from stdout.txt) against the participant's output (from answer.txt),\n  using the input data (stdin.txt) to determine the number of test cases.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file is empty\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse the number of test cases (T) from the first line of stdin\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false; // Invalid T\n    }\n\n    // Ensure T is positive\n    if (T <= 0) {\n        return false;\n    }\n\n    // Check that jury's answer file has at least T lines\n    if (static_cast<int>(stdout_lines.size()) < T) {\n        return false;\n    }\n\n    // Check participant's output has exactly T lines\n    if (static_cast<int>(participant_lines.size()) != T) {\n        return false;\n    }\n\n    // Validate each test case\n    for (int t = 0; t < T; t++) {\n        const string& jury_answer = stdout_lines[t];\n        const string& participant_answer = participant_lines[t];\n\n        // Check jury's answer is valid\n        if (jury_answer != \"Alice\" && jury_answer != \"Bob\") {\n            return false;\n        }\n\n        // Check participant's answer is valid\n        if (participant_answer != \"Alice\" && participant_answer != \"Bob\") {\n            return false;\n        }\n\n        // Check answers match\n        if (jury_answer != participant_answer) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60234, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Number of test cases is read from stdin.txt. Returns true only if all\n  test cases match exactly (integer-by-integer comparison).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files were read successfully\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int t = 0;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;  // Invalid integer format\n    }\n    if (t <= 0) {\n        return false;  // Invalid test case count\n    }\n\n    // Extract all integers from participant's output (answer.txt)\n    vector<int> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            participant_tokens.push_back(num);\n        }\n    }\n\n    // Extract all integers from correct answer (stdout.txt)\n    vector<int> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            stdout_tokens.push_back(num);\n        }\n    }\n\n    // Verify sufficient tokens exist for all test cases\n    if (participant_tokens.size() < static_cast<size_t>(t) || \n        stdout_tokens.size() < static_cast<size_t>(t)) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < t; ++i) {\n        if (participant_tokens[i] != stdout_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60237, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the\n  expected input/output files. Checks:\n  1. Output string matches (\"Yes\"/\"No\")\n  2. For \"Yes\" cases: \n     - p and q arrays are valid permutations of [0, n-1)\n     - r[i] = p[i] ^ q[i] forms a valid permutation\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Tokenize all input files (split lines into whitespace-separated tokens)\n    vector<string> stdin_tokens;\n    vector<string> stdout_tokens;\n    vector<string> answer_tokens;\n\n    auto tokenize = [](const vector<string>& lines, vector<string>& tokens) {\n        for (const string& line : lines) {\n            if (line.empty()) continue;\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n    };\n\n    tokenize(stdin_lines,  stdin_tokens);\n    tokenize(stdout_lines, stdout_tokens);\n    tokenize(answer_lines, answer_tokens);\n\n    // Track current token index for each stream\n    size_t s_idx = 0; // stdin  tokens (input test data)\n    size_t o_idx = 0; // stdout tokens (participant's output)\n    size_t a_idx = 0; // answer tokens (expected output)\n\n    // Read number of test cases (t)\n    if (s_idx >= stdin_tokens.size()) return false;\n    int t = stoi(stdin_tokens[s_idx++]);\n    if (t < 1 || t > 200000) return false;\n\n    for (int i = 0; i < t; i++) {\n        // Read n for current test case\n        if (s_idx >= stdin_tokens.size()) return false;\n        int n = stoi(stdin_tokens[s_idx++]);\n        if (n < 1 || n > 200000) return false;\n\n        // Compare \"Yes\"/\"No\" decision\n        if (o_idx >= stdout_tokens.size() || a_idx >= answer_tokens.size()) \n            return false;\n        string participant_decision = stdout_tokens[o_idx++];\n        string expected_decision = answer_tokens[a_idx++];\n\n        if (participant_decision != expected_decision) \n            return false;\n\n        // Skip further validation for \"No\" cases\n        if (expected_decision == \"No\") \n            continue;\n\n        // Initialize tracking arrays for current test case\n        vector<bool> p_used(n, false);\n        vector<bool> q_used(n, false);\n        vector<bool> r_used(n, false);\n        vector<int> p_array(n, -1);\n\n        // Validate p array: must be permutation of [0, n-1)\n        for (int j = 0; j < n; j++) {\n            if (o_idx >= stdout_tokens.size() || a_idx >= answer_tokens.size())\n                return false;\n            \n            int p_val = stoi(stdout_tokens[o_idx++]);\n            int expected_p = stoi(answer_tokens[a_idx++]);  // Not compared directly (by design)\n\n            // Check range and uniqueness\n            if (p_val < 0 || p_val >= n || p_used[p_val]) \n                return false;\n            \n            p_used[p_val] = true;\n            p_array[j] = p_val;\n        }\n\n        // Validate q array: must be permutation of [0, n-1)\n        for (int j = 0; j < n; j++) {\n            if (o_idx >= stdout_tokens.size() || a_idx >= answer_tokens.size())\n                return false;\n            \n            int q_val = stoi(stdout_tokens[o_idx++]);\n            int expected_q = stoi(answer_tokens[a_idx++]);  // Not compared directly (by design)\n\n            // Check range and uniqueness\n            if (q_val < 0 || q_val >= n || q_used[q_val]) \n                return false;\n            \n            q_used[q_val] = true;\n\n            // Compute r = p ^ q and validate\n            int r_val = p_array[j] ^ q_val;\n            if (r_val < 0 || r_val >= n || r_used[r_val]) \n                return false;\n            \n            r_used[r_val] = true;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60242, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against the correct answer.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> contestant_lines  = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Find first non-empty line in correct answer\n    auto it_correct = find_if(correct_lines.begin(), correct_lines.end(),\n                             [](const string& s) { return !s.empty(); });\n    if (it_correct == correct_lines.end()) {\n        cerr << \"Correct answer is empty\\n\";\n        return false;\n    }\n\n    // Parse integer from correct answer\n    stringstream ss_correct(*it_correct);\n    int correct_num;\n    ss_correct >> correct_num;\n    if (ss_correct.fail()) {\n        cerr << \"Correct answer is not an integer: \" << *it_correct << '\\n';\n        return false;\n    }\n\n    // Check for extra data in correct answer line\n    string rest_correct;\n    getline(ss_correct, rest_correct);\n    if (!rest_correct.empty()) {\n        cerr << \"Extra data in correct answer: \" << *it_correct << '\\n\";\n        return false;\n    }\n\n    // Check remaining lines in correct answer are empty\n    for (auto jt = it_correct + 1; jt != correct_lines.end(); ++jt) {\n        if (!jt->empty()) {\n            cerr << \"Extra lines in correct answer\\n\";\n            return false;\n        }\n    }\n\n    // Find first non-empty line in contestant's output\n    auto it_contestant = find_if(contestant_lines.begin(), contestant_lines.end(),\n                                [](const string& s) { return !s.empty(); });\n    if (it_contestant == contestant_lines.end()) {\n        cerr << \"Contestant output is empty\\n\";\n        return false;\n    }\n\n    // Parse integer from contestant's output\n    stringstream ss_contestant(*it_contestant);\n    int contestant_num;\n    ss_contestant >> contestant_num;\n    if (ss_contestant.fail()) {\n        cerr << \"Contestant output is not an integer: \" << *it_contestant << '\\n';\n        return false;\n    }\n\n    // Check for extra data in contestant's output line\n    string rest_contestant;\n    getline(ss_contestant, rest_contestant);\n    if (!rest_contestant.empty()) {\n        cerr << \"Extra output after answer\\n\";\n        return false;\n    }\n\n    // Check remaining lines in contestant's output are empty\n    for (auto jt = it_contestant + 1; jt != contestant_lines.end(); ++jt) {\n        if (!jt->empty()) {\n            cerr << \"Extra lines in contestant output\\n\";\n            return false;\n        }\n    }\n\n    // Compare the numbers\n    if (contestant_num != correct_num) {\n        cerr << \"Expected \" << correct_num << \", found \" << contestant_num << '\\n';\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60238, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\n/*-----------------------------------------------------------\n  Compare two double values using both absolute and relative\n  error tolerance. Returns true if values are considered equal.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double EPS) {\n    double diff = fabs(a - b);\n    if (diff <= EPS) {\n        return true;\n    }\n    double relError = diff / max({1.0, fabs(a), fabs(b)});\n    return relError <= EPS;\n}\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output (stdout.txt)\n  against jury's answer (answer.txt) as double values. Uses EPS\n  for absolute/relative error tolerance. Returns true if valid.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check both output files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        double participant_answer = stod(stdout_lines[0]);    // Contestant's output\n        double jury_answer        = stod(participant_lines[0]); // Jury's expected answer\n\n        // Compare using absolute and relative error tolerance\n        if (!doubleCompare(jury_answer, participant_answer, EPS)) {\n            return false;\n        }\n        return true;\n    } catch (...) {\n        // Handle conversion errors (non-numeric input)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60226, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer by comparing\n  token-by-token as 64-bit integers. The files:\n    - stdin_path:   problem input (not used in validation)\n    - stdout_path:  jury's expected output (correct answers)\n    - answer_path:  participant's submitted output\n    \n  Returns true if all tokens match exactly (as long long integers),\n  false otherwise (mismatched tokens, size difference, or invalid format).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin is unused but read for completeness)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert jury's output (stdout) to vector of long long\n    vector<ll> jury_numbers;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;  // Skip blank lines (consistent with token-based reading)\n        try {\n            // Convert trimmed line to 64-bit integer\n            jury_numbers.push_back(stoll(line));\n        } catch (...) {\n            // Invalid integer format in jury's answer  reject\n            return false;\n        }\n    }\n\n    // Convert participant's output to vector of long long\n    vector<ll> participant_numbers;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;  // Skip blank lines\n        try {\n            participant_numbers.push_back(stoll(line));\n        } catch (...) {\n            // Invalid integer format in participant's output  reject\n            return false;\n        }\n    }\n\n    // Check if number of test cases matches\n    if (jury_numbers.size() != participant_numbers.size()) {\n        return false;\n    }\n\n    // Verify each test case result matches\n    for (size_t i = 0; i < jury_numbers.size(); i++) {\n        if (jury_numbers[i] != participant_numbers[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60245, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from correct output (stdout.txt) and\n  participant's output (answer.txt), allowing max absolute or relative error = EPS.\n  - Correct output is read from stdout_path (corresponds to 'ans' in original code)\n  - Participant's output is read from answer_path (corresponds to 'ouf' in original code)\n  - Returns true if all values are within EPS tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> correctLines = read_file(stdout_path);   // Correct output (ans)\n    vector<string> participantLines = read_file(answer_path); // Participant's output (ouf)\n\n    // Ensure participant provided at least as many values as correct output\n    if (participantLines.size() < correctLines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < correctLines.size(); ++i) {\n        try {\n            double j = stod(correctLines[i]); // Correct value\n            double p = stod(participantLines[i]); // Participant's value\n            double diff = fabs(j - p);\n\n            // Check absolute error first\n            if (diff <= EPS) continue;\n\n            // If absolute error fails, check relative error\n            double m = max(fabs(j), fabs(p));\n            double rel_diff = diff / m;\n\n            // Fail if both absolute and relative errors exceed EPS\n            if (rel_diff > EPS) {\n                return false;\n            }\n        } catch (...) {\n            // Conversion failure (non-numeric value) = invalid\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60246, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two doubles with tolerance for absolute/relative error.\n  Returns true if values are within EPS tolerance.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double eps)\n{\n    double diff = fabs(a - b);\n    if (diff <= eps) \n        return true;\n    \n    double maxVal = max(fabs(a), fabs(b));\n    return (diff <= maxVal * eps);\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing each output value\n  against jury's answer with EPS tolerance. Uses stdin.txt for \n  input parameters (n, w), stdout.txt as jury's answer, and \n  answer.txt as participant's output. Returns true for accepted.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files were read successfully\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        cerr << \"One or more input files are empty or couldn't be read\\n\";\n        return false;\n    }\n\n    // Parse n (number of test cases) and w from stdin\n    istringstream iss(stdin_lines[0]);\n    int n, w;\n    if (!(iss >> n >> w)) {\n        cerr << \"Failed to parse n and w from stdin\\n\";\n        return false;\n    }\n\n    // Check sufficient lines in output files\n    if (stdout_lines.size() < n || participant_lines.size() < n) {\n        cerr << \"Output files have fewer lines than required (\" << n << \")\\n\";\n        return false;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        try {\n            // Parse jury's answer value\n            size_t pos_ja;\n            double ja = stod(stdout_lines[i], &pos_ja);\n            if (pos_ja != stdout_lines[i].size()) {\n                cerr << \"Invalid format in jury's answer line \" << i+1 << '\\n';\n                return false;\n            }\n\n            // Parse participant's answer value\n            size_t pos_pa;\n            double pa = stod(participant_lines[i], &pos_pa);\n            if (pos_pa != participant_lines[i].size()) {\n                cerr << \"Invalid format in participant's output line \" << i+1 << '\\n';\n                return false;\n            }\n\n            // Validate with tolerance check\n            if (!doubleCompare(ja, pa, EPS)) {\n                cerr << \"Mismatch at line \" << i+1 << \": expected \" << ja \n                     << \", found \" << pa << '\\n';\n                return false;\n            }\n        } catch (...) {\n            cerr << \"Exception while parsing line \" << i+1 << '\\n';\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60278, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's\n  correct output (stdout.txt). Input file (stdin.txt) is \n  available for context if needed.\n  \n  Returns true if outputs match exactly (after stripping),\n  false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Perform strict line-by-line comparison of outputs\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60231, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of signed integers from output files.\n  Returns true if both sequences match exactly in content and length,\n  false otherwise (mismatched values or different sequence lengths).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path); // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path); // Participant's output (ouf)\n\n    // Compare each integer in the sequences\n    size_t i = 0;\n    for (; i < min(stdout_lines.size(), participant_lines.size()); ++i) {\n        try {\n            ll jury_val = stoll(stdout_lines[i]);\n            ll part_val = stoll(participant_lines[i]);\n            \n            if (jury_val != part_val) {\n                return false;  // Value mismatch\n            }\n        } catch (...) {\n            return false;  // Invalid number format\n        }\n    }\n\n    // Check if sequences have different lengths\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    return true;  // All values match and sequences have same length\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60247, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against the jury's answer\n  using the problem input. Checks include:\n  1. Special case handling for \"-1\" outputs\n  2. Output length and character validity\n  3. Consistency with input constraints\n  4. Correctness of N/C/A counting logic\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify required input data exists\n    if (stdin_lines.size() < 2 || participant_lines.empty() || stdout_lines.empty()) {\n        return false;\n    }\n\n    // Parse problem parameters (n, k) from first line of input\n    istringstream iss(stdin_lines[0]);\n    int n, k;\n    if (!(iss >> n >> k)) {\n        return false;\n    }\n\n    // Parse contestant's output (pa) and jury's answer (ja)\n    istringstream pa_iss(participant_lines[0]);\n    istringstream ja_iss(stdout_lines[0]);\n    string pa, ja;\n    if (!(pa_iss >> pa) || !(ja_iss >> ja)) {\n        return false;\n    }\n\n    // Input string (problem constraints)\n    string inp = stdin_lines[1];\n\n    // Handle special case: both outputs are \"-1\"\n    if (ja == \"-1\" && pa == \"-1\") {\n        return true;\n    } \n    // Mismatched \"-1\" cases\n    else if (ja == \"-1\" && pa != \"-1\") {\n        return false;\n    }\n    else if (ja != \"-1\" && pa == \"-1\") {\n        return false;\n    }\n\n    // Verify output length matches problem size\n    if (static_cast<int>(pa.size()) != n) {\n        return false;\n    }\n\n    // Ensure output consists only of uppercase letters\n    for (char c : pa) {\n        if (c < 'A' || c > 'Z') {\n            return false;\n        }\n    }\n\n    // Check output consistency with input constraints\n    if (static_cast<int>(inp.size()) < n) {\n        return false;\n    }\n    for (int i = 0; i < n; i++) {\n        if (inp[i] != '?' && pa[i] != inp[i]) {\n            return false;\n        }\n    }\n\n    // Count occurrences of 'N' from left\n    vector<int> cnt(n, 0);\n    int x = 0;\n    for (int i = 0; i < n; i++) {\n        if (pa[i] == 'N') x++;\n        cnt[i] = x;\n    }\n\n    // Calculate total matches using 'C' and 'A' positions\n    int y = 0;\n    int tot = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (pa[i] == 'C') y++;\n        if (pa[i] == 'A') {\n            tot += cnt[i] * y;\n        }\n        if (tot > k) break;\n    }\n\n    // Verify total matches expected value\n    return (tot == k);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60281, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against correct answer using\n  input data. Compares line-by-line after whitespace trimming.\n  Returns true if outputs match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: check line count and exact content match\n    if (participant_lines.size() != correct_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != correct_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60279, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer:\n  1. Verify line count matches between output and answer\n  2. Check each line's content (after whitespace trimming)\n  3. Return true only if all lines match exactly\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check line count consistency first\n    if (participant_lines.size() != answer_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != answer_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60271, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (answer.txt) against expected output (stdout.txt)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60235, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file is empty\n    if (stdin_lines.empty()) {\n        cerr << \"Error: \" << stdin_path << \" is empty.\\n\";\n        return false;\n    }\n\n    // Parse number of test cases from first line of input\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Error: Failed to parse T from \" << stdin_path << \"\\n\";\n        return false;\n    }\n\n    // Validate sufficient lines in output files\n    if (stdout_lines.size() < T || participant_lines.size() < T) {\n        cerr << \"Error: Output files have insufficient lines. Expected at least \" \n             << T << \" lines.\\n\";\n        return false;\n    }\n\n    for (int tc = 1; tc <= T; ++tc) {\n        try {\n            int ja = stoi(stdout_lines[tc-1]);      // Jury's answer (correct output)\n            int pa = stoi(participant_lines[tc-1]); // Participant's output\n\n            // Check output validity (0  pa  200000)\n            if (pa < 0 || pa > 200000) {\n                cerr << \"Test case \" << tc << \": Output out of bounds: \" << pa << '\\n';\n                return false;\n            }\n\n            // Verify participant's output matches expected answer\n            if (pa != ja) {\n                cerr << \"Test case \" << tc << \": Wrong answer. Expected \" << ja \n                     << \", found \" << pa << '\\n';\n                return false;\n            }\n        } catch (const exception& e) {\n            cerr << \"Test case \" << tc << \": Failed to parse integer from output.\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60284, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (from answer.txt) against expected output (from stdout.txt)\n    // Perform exact line-by-line comparison after whitespace normalization\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60269, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer.\n  Compares line-by-line after whitespace normalization:\n  - Check line count matches\n  - Verify each stripped line is identical\n  Returns true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Check line count consistency first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60248, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare judge's expected output (from stdout.txt) against \n  participant's submission (from answer.txt). \n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (judge)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant)\n\n    // Check if both output files contain at least one line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse first line as integer from both judge and participant outputs\n        int ja = stoi(stdout_lines[0]);\n        int pa = stoi(participant_lines[0]);\n\n        // Compare values (original logic: ja != pa  WA)\n        return (ja == pa);\n    } catch (...) {\n        // Handle non-integer content or conversion errors as WA\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60309, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against jury answer (answer.txt).\n  - First verify line count matches\n  - Then check each line for exact string equality (after whitespace trimming)\n  - Input file (stdin.txt) is available for context if needed in custom checks\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant provided correct number of output lines\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches the expected answer exactly\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60290, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against the correct answer (stdout_path).\n  The input (stdin_path) is available if needed for validation logic.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' in testlib\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic: Compare participant's output with expected output line-by-line\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;  // Different number of lines  reject\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;  // Mismatched line  reject\n        }\n    }\n    \n    return true;  // All lines match  accept\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60291, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against the correct output (stdout.txt).\n  The input (stdin.txt) is available for context but unused in basic comparison.\n  Returns true if outputs match exactly line-by-line (after trimming), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact match\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60311, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against the expected answer (answer.txt).\n  Returns true if outputs match exactly (line-by-line after whitespace trimming), \n  false otherwise. Input file (stdin.txt) is available for context if needed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with expected answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60283, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Uses the problem input (stdin.txt) if needed for validation logic.\n  Returns true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic - adapted from original testlib.h checker:\n    // - stdin_lines corresponds to 'inf' (problem input)\n    // - stdout_lines corresponds to 'ans' (correct output)\n    // - participant_lines corresponds to 'ouf' (participant's output)\n    \n    // Check line count matches\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line strictly (after whitespace trimming)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60312, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output by comparing against correct output.\n  Uses input file for context if needed. Returns true if output matches\n  expected solution (after whitespace normalization), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: participant's output must exactly match\n    // the correct output (with whitespace trimmed per line)\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60313, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (answer.txt) against expected output (stdout.txt)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60314, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (answer_path) against expected output (stdout_path)\n    // Line-by-line exact match after trimming whitespace. Uses vector's equality operator\n    // which checks both size and individual elements (already stripped of whitespace).\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60261, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from expected output (stdout_path)\n  and participant's output (answer_path), allowing maximum absolute\n  or relative error of 1E-9. Return true if all numbers match within\n  tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Unused (corresponds to inf)\n    vector<string> expected_lines    = read_file(stdout_path);      // Corresponds to ans (expected output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to ouf (participant's output)\n\n    // Ensure participant provided at least as many numbers as expected\n    if (participant_lines.size() < expected_lines.size()) {\n        return false;\n    }\n\n    const double EPS = 1E-9;\n\n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        try {\n            double expected_val = stod(expected_lines[i]);\n            double participant_val = stod(participant_lines[i]);\n\n            double diff = fabs(expected_val - participant_val);\n            // Check absolute error tolerance\n            if (diff <= EPS) continue;\n\n            // Check relative error tolerance (using testlib.h's approach)\n            double mres = max(fabs(expected_val), fabs(participant_val));\n            if (mres < 1.0) mres = 1.0;  // Prevent division by very small numbers\n            if (diff / mres > EPS) {\n                return false;\n            }\n        } catch (...) {\n            // Failed to parse double from either expected or participant's output\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60316, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against jury's answer (answer.txt)\n  by checking if all trimmed lines are identical after processing.\n  Note: stdin.txt (problem input) is available but unused in basic comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Core comparison logic: Verify participant's output matches jury's answer\n    // exactly line-by-line (after individual line trimming)\n    if (participant_lines.size() != answer_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != answer_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60259, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare jury's expected answer (from stdout.txt) against participant's output (from answer.txt).\n  Both files must contain exactly one integer value. Returns true only if values match.\n  Prints verification messages to standard output following testlib.h checker conventions.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input file (unused in comparison)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Jury's expected answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Verify both answer files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        printf(\"Each answer file must contain exactly one line.\\n\");\n        return false;\n    }\n\n    try {\n        ll jury_answer      = stoll(stdout_lines[0]);      // Convert jury's answer string to long long\n        ll participant_answer = stoll(participant_lines[0]);  // Convert participant's output to long long\n\n        if (jury_answer != participant_answer) {\n            printf(\"expected %lld, found %lld\\n\", jury_answer, participant_answer);\n            return false;\n        }\n        printf(\"answer is %lld\\n\", jury_answer);\n        return true;\n    } catch (...) {\n        // Handle non-integer content or conversion errors\n        printf(\"Failed to parse integer values from answer files.\\n\");\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60318, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected answer (stdout_path).\n  Return true if correct, else false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (expected answer)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming (already done in read_file)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60256, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by checking against the problem input.\n  Returns true if the participant's output is valid, false otherwise.\n  \n  Note: \n    - stdin_path: contains the problem input (corresponds to 'inf' in original code)\n    - stdout_path: contains the expected output (corresponds to 'ans' in original code) - NOT USED\n    - answer_path: contains the participant's output (corresponds to 'ouf' in original code)\n  \n  The original checker does not use the expected output (ans), so we ignore stdout_path.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files as per template structure (though stdout_path is unused)\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // Ignored (expected output not used in validation)\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Extract tokens from problem input (stdin_lines)\n    vector<string> tokens_in;\n    for (string& line : stdin_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_in.push_back(token);\n        }\n    }\n\n    // Extract tokens from participant's output (answer_lines)\n    vector<string> tokens_ouf;\n    for (string& line : answer_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_ouf.push_back(token);\n        }\n    }\n\n    // Validate participant provided at least one token\n    if (tokens_ouf.empty()) {\n        return false;\n    }\n    string o = tokens_ouf[0];\n\n    // Validate problem input has sufficient tokens (n and 2n operations)\n    if (tokens_in.size() < 1) {\n        return false;\n    }\n    int n = stoi(tokens_in[0]);\n    int m = 2 * n;\n    if (tokens_in.size() < 1 + m) {\n        return false;\n    }\n\n    // Parse operations from problem input\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n        a[i] = stoi(tokens_in[1 + i]);\n    }\n\n    // Track in/out positions for each element (1-indexed)\n    vector<int> in(n + 1, -1);\n    vector<int> out(n + 1, -1);\n    for (int i = 0; i < m; i++) {\n        int x = a[i];\n        int u = abs(x);\n        if (x > 0) {\n            in[u] = i;\n        } else {\n            out[u] = i;\n        }\n    }\n\n    // Case 1: Participant claims no solution exists (\"*\")\n    if (o == \"*\") {\n        // Build conflict graph where edges indicate nested intervals\n        vector<vector<int>> adj(n + 1);\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                if ((in[i] < in[j] && in[j] < out[i] && out[i] < out[j]) ||\n                    (in[j] < in[i] && in[i] < out[j] && out[j] < in[i])) {\n                    adj[i].push_back(j);\n                    adj[j].push_back(i);\n                }\n            }\n        }\n\n        // Check bipartiteness of graph (0/1 coloring)\n        vector<int> col(n + 1, -1);\n        function<bool(int)> bfs = [&](int s) {\n            queue<int> q;\n            col[s] = 0;\n            q.push(s);\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                for (int v : adj[u]) {\n                    if (col[v] < 0) {\n                        col[v] = col[u] ^ 1;\n                        q.push(v);\n                    } else if (col[v] == col[u]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n\n        // If any component is non-bipartite, participant is correct\n        for (int i = 1; i <= n; i++) {\n            if (col[i] < 0 && !bfs(i)) {\n                return true;\n            }\n        }\n        // All components bipartite -> solution exists but participant claimed none\n        return false;\n    } \n    // Case 2: Participant provides assignment string\n    else {\n        // Validate string length and characters\n        if ((int)o.size() != n) {\n            return false;\n        }\n        for (char c : o) {\n            if (c != 'G' && c != 'S') {\n                return false;\n            }\n        }\n\n        // Simulate stack operations\n        vector<int> G, S;\n        for (int i = 0; i < m; i++) {\n            int x = a[i];\n            int u = abs(x);\n            if (x > 0) {  // Push operation\n                if (o[u - 1] == 'G') {\n                    G.push_back(u);\n                } else {\n                    S.push_back(u);\n                }\n            } else {  // Pop operation\n                vector<int>& st = (o[u - 1] == 'G' ? G : S);\n                if (st.empty() || st.back() != u) {\n                    return false;\n                }\n                st.pop_back();\n            }\n        }\n        return true;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60317, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Returns true if both outputs match exactly line-by-line after whitespace trimming.\n  Uses stdin.txt (problem input) if validation logic requires input-dependent checks.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: compare participant's output with expected output\n    if (expected_lines.size() != participant_lines.size()) {\n        return false;  // Different number of lines\n    }\n\n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        // Perform line-by-line comparison (already whitespace-trimmed)\n        if (expected_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60319, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Compares:\n    - participant_lines (answer.txt)    ouf in testlib terms\n    - stdout_lines (stdout.txt)         ans in testlib terms\n  Input (stdin.txt) may be used for problem-specific validation logic.\n  Returns true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with correct answer\n    // Line-by-line comparison after whitespace normalization\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60296, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Uses same logic as original testlib checker:\n  - Check line count matches\n  - Verify each line matches exactly (after whitespace trimming)\n  - Input file (stdin.txt) is unused in simple checkers but read for completeness\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' in testlib\n    vector<string> correct_lines     = read_file(stdout_path);      // Corresponds to 'ans' in testlib\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' in testlib\n\n    // Check line count first\n    if (participant_lines.size() != correct_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != correct_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60320, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected output (stdout_path).\n  Returns true if all lines match exactly after trimming whitespace, false otherwise.\n  The input file (stdin_path) is read but not used in this comparison logic.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60262, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (stdout.txt) against correct answer (answer.txt).\n  Both files must contain exactly one line with a single token (no whitespace).\n  Return true if tokens match, false otherwise (including format errors).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Validate contestant's output format: must be exactly one non-empty line with no whitespace\n    if (stdout_lines.size() != 1 || stdout_lines[0].empty()) {\n        return false;\n    }\n    if (stdout_lines[0].find(' ') != string::npos || \n        stdout_lines[0].find('\\t') != string::npos) {\n        return false;\n    }\n\n    // Validate correct answer format: must be exactly one non-empty line with no whitespace\n    if (answer_lines.size() != 1 || answer_lines[0].empty()) {\n        return false;\n    }\n    if (answer_lines[0].find(' ') != string::npos || \n        answer_lines[0].find('\\t') != string::npos) {\n        return false;\n    }\n\n    // Compare the actual token values\n    return (stdout_lines[0] == answer_lines[0]);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60250, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------------\n  Read an entire text file and split into tokens (by whitespace).\n  Returns a vector of tokens (each token is a string without surrounding whitespace).\n-----------------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------------\n  Compare the judge's answer (from stdout.txt) and the participant's output (from answer.txt)\n  as sequences of long long integers. \n  Return true if they are identical, false otherwise.\n-----------------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                      const string& stdout_path,\n                      const string& answer_path)\n{\n    // Read tokens from all three files (stdin_path is ignored as it's not used in comparison)\n    vector<string> stdin_tokens = read_file(stdin_path);\n    vector<string> stdout_tokens = read_file(stdout_path);\n    vector<string> answer_tokens = read_file(answer_path);\n\n    // Convert judge's answer tokens (stdout) to vector of long long\n    vector<ll> ja;\n    for (string& s : stdout_tokens) {\n        try {\n            ja.push_back(stoll(s));\n        } catch (...) {\n            // Failed to convert token to long long (invalid number format)\n            return false;\n        }\n    }\n\n    // Convert participant's output tokens (answer) to vector of long long\n    vector<ll> pa;\n    for (string& s : answer_tokens) {\n        try {\n            pa.push_back(stoll(s));\n        } catch (...) {\n            // Failed to convert token to long long (invalid number format)\n            return false;\n        }\n    }\n\n    // Check if both sequences have identical size and content\n    if (ja.size() != pa.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < ja.size(); i++) {\n        if (ja[i] != pa[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60287, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against the correct output (stdout_path).\n  The input (stdin_path) may be used for context if needed in advanced checks.\n  Returns true if solution is valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Check if line counts match between participant's output and correct answer\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming (already handled by read_file)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60253, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing the jury's answer\n  (stdout.txt) and participant's output (answer.txt) as double values\n  with absolute error tolerance EPS = 1e-9.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check both output files contain exactly one non-empty line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        double jury_value = stod(stdout_lines[0]);\n        double output_value = stod(participant_lines[0]);\n\n        // Compare with absolute error tolerance\n        if (fabs(jury_value - output_value) > EPS) {\n            return false;\n        }\n        return true;\n    } catch (...) {\n        // Handle conversion errors (non-numeric content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60285, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path).\n  - stdin_path corresponds to problem input (inf)\n  - stdout_path corresponds to correct output (ans)\n  - answer_path corresponds to participant's output (ouf)\n  Returns true if outputs match exactly (after trimming), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Input (inf)\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check line count mismatch\n    if (participant_lines.size() != correct_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != correct_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60257, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert string to uppercase for case-insensitive comparison\n  of expected (correct answer) and actual (contestant) outputs.\n-----------------------------------------------------------*/\nstring upperCase(const string& s) {\n    string res = s;\n    for (char& c : res) {\n        c = toupper(static_cast<unsigned char>(c));\n    }\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing correct answer (stdout.txt) \n  against contestant's output (answer.txt). Expects single-token \n  'Y'/'N' responses (case-insensitive). Returns true for correct \n  solutions, false otherwise with appropriate messages printed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if correct output file is empty\n    if (stdout_lines.empty()) {\n        cout << \"Checker error: Correct output is empty\\n\";\n        return false;\n    }\n    // Check if contestant's output file is empty\n    if (participant_lines.empty()) {\n        cout << \"Wrong answer: Participant output is empty\\n\";\n        return false;\n    }\n\n    string expected = upperCase(stdout_lines[0]);\n    string actual   = upperCase(participant_lines[0]);\n\n    // Validate expected output format (must be 'Y' or 'N')\n    if (expected != \"Y\" && expected != \"N\") {\n        cout << \"Checker error: Expected output must be Y or N, but got '\" << expected << \"'\\n\";\n        return false;\n    }\n    // Validate actual output format (must be 'Y' or 'N')\n    if (actual != \"Y\" && actual != \"N\") {\n        cout << \"Wrong answer: Participant output must be Y or N, but got '\" << actual << \"'\\n\";\n        return false;\n    }\n\n    // Compare normalized outputs\n    if (expected != actual) {\n        cout << \"Wrong answer: expected '\" << expected << \"', found '\" << actual << \"'\\n\";\n        return false;\n    }\n\n    cout << \"Correct answer: '\" << actual << \"'\\n\";\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60252, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path).\n  Validation requires:\n    1. Equal number of lines in both outputs\n    2. Each corresponding line must match exactly after whitespace trimming\n  Input file (stdin_path) is available for context but not used in this simple checker.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches exactly (after trimming handled during read)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60272, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected \n  output (stdout.txt) after normalizing whitespace. Returns \n  true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: verify participant's output matches expected output\n    // (ignoring leading/trailing whitespace per line due to read_file processing)\n    return stdout_lines == participant_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60366, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Uses stdin.txt as input context if needed for validation logic.\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic: Check if participant's output matches expected answer\n    // (After both have been normalized by read_file's whitespace trimming)\n    if (participant_lines.size() != stdout_lines.size()) \n        return false;\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) \n            return false;\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60369, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  The input file (stdin.txt) is available for context if needed.\n  Returns true if outputs match exactly (line count and content after stripping).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify line count matches between participant and expected output\n    if (participant_lines.size() != expected_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison of stripped content\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != expected_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60254, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (from answer.txt) against correct answer (from stdout.txt).\n  Returns true if both outputs contain the same integer value, false otherwise.\n  Note: stdin.txt (input test case) is not used in this particular comparison logic.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Verify both outputs have at least one line\n    if (participant_lines.empty() || stdout_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integer values from first line of each output\n        int participant_value = stoi(participant_lines[0]);\n        int correct_value     = stoi(stdout_lines[0]);\n\n        return participant_value == correct_value;\n    } catch (...) {\n        // Handle non-integer outputs as invalid (WA)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60288, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer using \n  input data. Returns true if solution is accepted.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> input_lines      = read_file(stdin_path);   // Corresponds to 'inf' (problem input)\n    vector<string> jury_answer      = read_file(stdout_path);  // Corresponds to 'ans' (jury's output)\n    vector<string> participant_ouput = read_file(answer_path); // Corresponds to 'ouf' (participant's output)\n\n    // Check line count matches\n    if (jury_answer.size() != participant_ouput.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming (already done during read)\n    for (size_t i = 0; i < jury_answer.size(); ++i) {\n        if (jury_answer[i] != participant_ouput[i]) {\n            return false;\n        }\n    }\n\n    // Additional constraints could be checked here using input_lines if needed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60298, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (read from answer.txt) against \n  the expected answer (read from stdout.txt). The input file \n  (stdin.txt) may be used for additional validation if needed.\n  Returns true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant output matches expected answer line-by-line\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        // Compare each stripped line for exact match\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60353, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output for YES/NO problem:\n  1. Participant's output must be exactly one line containing \"YES\" or \"NO\"\n  2. Must match the jury's answer (case-sensitive)\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input (unused in this problem)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Jury's correct answer\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output\n\n    // Check participant output has exactly one line\n    if (participant_lines.size() != 1) {\n        return false;\n    }\n\n    string pa = participant_lines[0];\n    // Validate participant output is strictly \"YES\" or \"NO\"\n    if (pa != \"YES\" && pa != \"NO\") {\n        return false;\n    }\n\n    // Check jury's answer has exactly one line\n    if (stdout_lines.size() != 1) {\n        return false;\n    }\n\n    string ja = stdout_lines[0];\n    // Compare participant's answer with jury's answer (case-sensitive)\n    return (pa == ja);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60379, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct solution.\n  Compares 'answer.txt' (participant's output) with 'stdout.txt' (correct output),\n  using 'stdin.txt' for input context if needed. Returns true if valid.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);  // Corresponds to 'inf' (input test case)\n    vector<string> stdout_lines      = read_file(stdout_path); // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line exactly (after trimming whitespace)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60293, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt)\n  using input (stdin.txt) for context if needed. \n  Return true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic adapted from original testlib-based checker:\n    // Original would use inf (stdin), ans (stdout), ouf (answer) streams.\n    // Now comparing line vectors after whitespace normalization.\n\n    // Check line count matches\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact content match (already stripped)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60352, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Checker logic for Czech cuisine problem:\n  - stdin.txt contains input (including number of test cases t)\n  - stdout.txt contains jury's expected answers\n  - answer.txt contains participant's output to verify\n  Compares each test case's expected vs found value.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines   = read_file(stdin_path);    // Corresponds to inf in original code\n    vector<string> ans_lines   = read_file(stdout_path);   // Corresponds to ans in original code\n    vector<string> ouf_lines   = read_file(answer_path);   // Corresponds to ouf in original code\n\n    // Check if input file has at least one line (for t)\n    if (inf_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of input\n    int t;\n    try {\n        t = stoi(inf_lines[0]);\n        if (t < 0) {\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n\n    // Verify expected answers exist and participant output has exact count\n    if (ans_lines.size() < t || ouf_lines.size() != t) {\n        return false;\n    }\n\n    // Compare each test case's expected vs found value\n    for (int i = 0; i < t; i++) {\n        try {\n            long long expected = stoll(ans_lines[i]);\n            long long found    = stoll(ouf_lines[i]);\n\n            if (expected != found) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60384, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  The input (stdin.txt) is available for problem-specific validation if needed.\n  Returns true if outputs match line-by-line (after whitespace trimming), \n  false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: participant's output must exactly match expected output\n    // (line count and content after whitespace normalization)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60297, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path).\n  Input file (stdin_path) is available for problem-specific validation if needed.\n  Returns true if solution is valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count equality first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison (already whitespace-stripped)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    // Note: For problems requiring input-aware validation,\n    //        additional checks using stdin_lines would be added here\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60360, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split a vector of lines into tokens by whitespace.\n-----------------------------------------------------------*/\nvector<string> get_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Check if all '*' in the grid are connected (4-directional).\n  Returns true if connected, false otherwise.\n-----------------------------------------------------------*/\nbool is_connected(const vector<string>& grid)\n{\n    int r = grid.size();\n    if (r == 0) return true;\n    int c = grid[0].size();\n\n    // Count total stars and find first star\n    int total_stars = 0;\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            if (grid[i][j] == '*') {\n                total_stars++;\n                if (start_i == -1) {\n                    start_i = i;\n                    start_j = j;\n                }\n            }\n        }\n    }\n\n    // If no stars, consider connected (problem states non-empty body but being safe)\n    if (total_stars == 0) \n        return true;\n\n    vector<vector<bool>> vis(r, vector<bool>(c, false));\n    queue<pair<int, int>> q;\n    q.push({start_i, start_j});\n    vis[start_i][start_j] = true;\n    int count = 1;\n\n    // 4-directional movement: right, left, down, up\n    vector<int> dx = {0, 0, 1, -1};\n    vector<int> dy = {1, -1, 0, 0};\n\n    while (!q.empty()) {\n        auto [x, y] = q.front(); q.pop();\n        for (int d = 0; d < 4; d++) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < r && ny >= 0 && ny < c && \n                !vis[nx][ny] && grid[nx][ny] == '*') {\n                vis[nx][ny] = true;\n                count++;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    return (count == total_stars);\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution against expected output\n  using input, expected output, and participant output files.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> input_lines       = read_file(stdin_path);\n    vector<string> jury_lines        = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse input file: first line has r and c\n    if (input_lines.empty()) {\n        cerr << \"Input file is empty\\n\";\n        return false;\n    }\n    \n    // Parse first line for grid dimensions\n    stringstream ss(input_lines[0]);\n    string token;\n    vector<string> dims;\n    while (ss >> token) {\n        dims.push_back(token);\n    }\n    if (dims.size() < 2) {\n        cerr << \"Invalid input: first line must contain two integers\\n\";\n        return false;\n    }\n    int r = stoi(dims[0]);\n    int c = stoi(dims[1]);\n\n    // Parse grid1 (next r lines)\n    vector<string> grid1;\n    for (int i = 1; i <= r; i++) {\n        if (i >= input_lines.size()) {\n            cerr << \"Input missing grid1 lines\\n\";\n            return false;\n        }\n        grid1.push_back(input_lines[i]);\n    }\n\n    // Parse grid2 (following r lines)\n    vector<string> grid2;\n    for (int i = r + 1; i <= 2 * r; i++) {\n        if (i >= input_lines.size()) {\n            cerr << \"Input missing grid2 lines\\n\";\n            return false;\n        }\n        grid2.push_back(input_lines[i]);\n    }\n\n    // Convert jury and participant outputs to tokens\n    vector<string> jury_tokens = get_tokens(jury_lines);\n    vector<string> part_tokens = get_tokens(participant_lines);\n\n    if (jury_tokens.empty() || part_tokens.empty()) {\n        return false;\n    }\n\n    // First token must match (YES/NO)\n    if (jury_tokens[0] != part_tokens[0]) {\n        return false;\n    }\n\n    // Case 1: Expected \"NO\"\n    if (jury_tokens[0] == \"NO\") {\n        return true;\n    }\n\n    // Case 2: Expected \"YES\" - validate moves\n    if (part_tokens.size() < 2) {\n        return false;\n    }\n\n    // Parse move count\n    int m;\n    try {\n        m = stoi(part_tokens[1]);\n    } catch (...) {\n        return false;\n    }\n    if (m < 0 || m > 10000) {\n        return false;\n    }\n\n    // Check sufficient tokens for moves\n    if (part_tokens.size() < 2 + 4 * m) {\n        return false;\n    }\n\n    // Simulate moves on grid1\n    vector<string> current_grid = grid1;\n    int index = 2;\n    for (int i = 0; i < m; i++) {\n        // Parse move coordinates (1-indexed)\n        int x1, y1, x2, y2;\n        try {\n            x1 = stoi(part_tokens[index]);\n            y1 = stoi(part_tokens[index+1]);\n            x2 = stoi(part_tokens[index+2]);\n            y2 = stoi(part_tokens[index+3]);\n        } catch (...) {\n            return false;\n        }\n        index += 4;\n\n        // Convert to 0-indexed\n        x1--; y1--; x2--; y2--;\n\n        // Check removal cell: must be within grid and contain '*'\n        if (x1 < 0 || x1 >= r || y1 < 0 || y1 >= c || current_grid[x1][y1] != '*') {\n            return false;\n        }\n\n        // Remove star and check connectivity\n        current_grid[x1][y1] = '.';\n        if (!is_connected(current_grid)) {\n            return false;\n        }\n\n        // Check addition cell: must be different and free\n        if (x2 == x1 && y2 == y1) {\n            return false;\n        }\n        if (x2 < 0 || x2 >= r || y2 < 0 || y2 >= c || current_grid[x2][y2] != '.') {\n            return false;\n        }\n\n        // Add star and check connectivity\n        current_grid[x2][y2] = '*';\n        if (!is_connected(current_grid)) {\n            return false;\n        }\n    }\n\n    // Final grid must match grid2\n    return (current_grid == grid2);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60355, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the \n  correct output using the problem's input data. Implements:\n  1. Input parsing (n, k, heights)\n  2. Correct output parsing (xj, yj)\n  3. Participant output parsing (xc, yc)\n  4. Validation of allocation constraints\n  5. Optimality comparison using ceiling division sums\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize stdin to extract problem parameters\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n    if (stdin_tokens.size() < 2) return false;\n    int n = stoi(stdin_tokens[0]);\n    long long k = stoll(stdin_tokens[1]);\n    if (static_cast<int>(stdin_tokens.size()) < 2 + n) return false;\n    \n    vector<long long> h(n);\n    for (int i = 0; i < n; i++) {\n        h[i] = stoll(stdin_tokens[2 + i]);\n    }\n\n    // Tokenize correct output (judge's answer)\n    vector<string> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdout_tokens.push_back(token);\n        }\n    }\n    if (stdout_tokens.size() != 2) return false;\n    int xj = stoi(stdout_tokens[0]);\n    int yj = stoi(stdout_tokens[1]);\n\n    // Tokenize participant's output\n    vector<string> answer_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            answer_tokens.push_back(token);\n        }\n    }\n    if (answer_tokens.size() != 2) return false;  // Ensures no extra tokens\n    int xc = stoi(answer_tokens[0]);\n    int yc = stoi(answer_tokens[1]);\n\n    // Check basic validity of participant's allocation\n    if (xc < 1 || yc < 1 || static_cast<long long>(xc) + yc > k) {\n        return false;\n    }\n\n    // Calculate total jumps using ceiling division: (a + b - 1) / b\n    __int128 sumj = 0, sumc = 0;\n    for (int i = 0; i < n; i++) {\n        sumj += (static_cast<__int128>(h[i]) + xj - 1) / xj;\n        sumc += (static_cast<__int128>(h[i]) + xc - 1) / xc;\n    }\n\n    // Verify optimality condition: participant's solution shouldn't be worse\n    if (sumc * yj > sumj * yc) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60357, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing input,\n  expected output, and participant's output.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Unused in this problem\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Validate input file structure\n    if (stdin_lines.size() < 3) {\n        cerr << \"Input file must contain at least 3 lines (n, c, p)\\n\";\n        return false;\n    }\n\n    // Parse n from first line\n    int n;\n    try {\n        n = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid integer value for n: \" << stdin_lines[0] << '\\n';\n        return false;\n    }\n\n    string c = stdin_lines[1];\n    string p = stdin_lines[2];\n\n    // Ensure c and p have correct length\n    if (static_cast<int>(c.length()) != n || static_cast<int>(p.length()) != n) {\n        cerr << \"Strings c and p must be of length n (\" << n << \")\\n\";\n        return false;\n    }\n\n    // Parse participant's output length\n    if (participant_lines.empty()) {\n        cerr << \"Participant output is empty\\n\";\n        return false;\n    }\n\n    int l;\n    try {\n        l = stoi(participant_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid integer value for l: \" << participant_lines[0] << '\\n';\n        return false;\n    }\n\n    if (static_cast<int>(participant_lines.size()) - 1 != l) {\n        cerr << \"Expected \" << l << \" commands, got \" \n             << participant_lines.size() - 1 << \" commands\\n\";\n        return false;\n    }\n\n    // Initialize building state from initial professor types\n    vector<vector<char>> building(n);\n    for (int i = 0; i < n; ++i) {\n        if (p[i] != '-') {\n            building[i].push_back(p[i]);\n        }\n    }\n\n    set<int> visited;\n    int cur = -1;\n    bool has_prof = false;\n    char carrying = '-';\n    vector<string> last;\n\n    // Process each command in participant's output\n    for (int step = 0; step < l; ++step) {\n        string line = participant_lines[1 + step];\n        istringstream iss(line);\n        vector<string> tokens;\n        string token;\n        \n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n\n        if (tokens.empty()) {\n            cerr << \"Empty command at step \" << step << '\\n';\n            return false;\n        }\n\n        string cmd = tokens[0];\n\n        if (cmd == \"DRIVE\") {\n            // DRIVE must have exactly one argument (x)\n            if (tokens.size() != 2) {\n                cerr << \"DRIVE command requires exactly one argument at step \" \n                     << step << \", got \" << tokens.size() - 1 << '\\n';\n                return false;\n            }\n\n            int x;\n            try {\n                x = stoi(tokens[1]);\n            } catch (...) {\n                cerr << \"Invalid integer value for x: \" << tokens[1] \n                     << \" at step \" << step << '\\n';\n                return false;\n            }\n\n            // Validate x range [1, n]\n            if (x < 1 || x > n) {\n                cerr << \"x must be between 1 and \" << n \n                     << \", got \" << x << \" at step \" << step << '\\n';\n                return false;\n            }\n            x--;  // Convert to 0-based index\n\n            // Check building hasn't been visited before\n            if (visited.find(x) != visited.end()) {\n                cerr << \"Building \" << (x + 1) \n                     << \" visited more than once at step \" << step << '\\n';\n                return false;\n            }\n            visited.insert(x);\n            cur = x;\n            last.clear();\n        }\n        else if (cmd == \"PICKUP\") {\n            // PICKUP must have no arguments\n            if (tokens.size() > 1) {\n                cerr << \"PICKUP command should have no arguments at step \" \n                     << step << '\\n';\n                return false;\n            }\n\n            // Validate preconditions\n            if (cur == -1) {\n                cerr << \"PICKUP before any DRIVE at step \" << step << '\\n';\n                return false;\n            }\n            if (has_prof) {\n                cerr << \"Already carrying a professor when trying to PICKUP at step \" \n                     << step << '\\n';\n                return false;\n            }\n            if (!last.empty() && !(last.size() == 1 && last[0] == \"DROPOFF\")) {\n                cerr << \"Invalid instruction sequence at building \" \n                     << (cur + 1) << \" at step \" << step << '\\n';\n                return false;\n            }\n\n            // Check building has professors to pick up\n            if (building[cur].empty()) {\n                cerr << \"No professor to PICKUP at building \" \n                     << (cur + 1) << \" at step \" << step << '\\n';\n                return false;\n            }\n            carrying = building[cur].back();\n            building[cur].pop_back();\n            has_prof = true;\n            last.emplace_back(\"PICKUP\");\n        }\n        else if (cmd == \"DROPOFF\") {\n            // DROPOFF must have no arguments\n            if (tokens.size() > 1) {\n                cerr << \"DROPOFF command should have no arguments at step \" \n                     << step << '\\n';\n                return false;\n            }\n\n            // Validate preconditions\n            if (cur == -1) {\n                cerr << \"DROPOFF before any DRIVE at step \" << step << '\\n';\n                return false;\n            }\n            if (!has_prof) {\n                cerr << \"No professor to DROPOFF at step \" << step << '\\n';\n                return false;\n            }\n            if (!last.empty()) {\n                cerr << \"Invalid instruction sequence at building \" \n                     << (cur + 1) << \" at step \" << step << '\\n';\n                return false;\n            }\n\n            // Perform dropoff\n            building[cur].insert(building[cur].begin(), carrying);\n            carrying = '-';\n            has_prof = false;\n            last.emplace_back(\"DROPOFF\");\n        }\n        else {\n            cerr << \"Invalid command: \" << cmd << \" at step \" << step << '\\n';\n            return false;\n        }\n    }\n\n    // Final validation: each building must have required professor\n    for (int i = 0; i < n; ++i) {\n        if (c[i] == '-') continue;\n        \n        bool ok = false;\n        for (char prof : building[i]) {\n            if (prof == c[i]) {\n                ok = true;\n                break;\n            }\n        }\n        \n        if (!ok) {\n            cerr << \"Building \" << (i + 1) << \" needs \" << c[i] \n                 << \" class but no such professor found\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60358, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a text file into a vector<string>.\n  Tokens are whitespace-delimited strings (similar to testlib's readToken).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Both files must contain sequences of YES/NO tokens (case-insensitive).\n  Returns true only if:\n    - Both files have identical token count\n    - All tokens are valid (YES/NO)\n    - Corresponding tokens match exactly (after case normalization)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Note: stdin_path (problem input) is unused in this validator but required by template\n    vector<string> correct_tokens = read_file(stdout_path);   // Corresponds to 'ans' (correct answer)\n    vector<string> participant_tokens = read_file(answer_path); // Corresponds to 'ouf' (participant output)\n\n    // Check token count equality first\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    const string YES = \"YES\";\n    const string NO = \"NO\";\n\n    // Process each token pair\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        string ja = toUpper(correct_tokens[i]);      // Jury's answer token (normalized)\n        string pa = toUpper(participant_tokens[i]);   // Participant's token (normalized)\n\n        // Validate correct answer token\n        if (ja != YES && ja != NO) {\n            return false;\n        }\n\n        // Validate participant's token\n        if (pa != YES && pa != NO) {\n            return false;\n        }\n\n        // Verify token match\n        if (ja != pa) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Helper function to convert string to uppercase\nstring toUpper(string s) {\n    for (char &c : s) {\n        c = toupper(static_cast<unsigned char>(c));\n    }\n    return s;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60361, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split a vector of lines into individual tokens (words).\n  Each line is split by whitespace, and all tokens are collected\n  into a single vector.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer and input.\n  Performs these checks for each test case:\n  1. First token must match (\"YES\"/\"NO\" from answer and output)\n  2. For \"YES\" cases:\n     - Verify correct number of elements per group\n     - Ensure all elements exist in input without repetition\n     - Confirm all input elements are used\n     - Validate group sums satisfy triangle inequality\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    vector<string> stdin_tokens  = tokenize(stdin_lines);\n    vector<string> stdout_tokens = tokenize(stdout_lines);\n    vector<string> answer_tokens = tokenize(answer_lines);\n\n    int s_idx = 0; // stdin token index\n    int o_idx = 0; // stdout token index (participant)\n    int a_idx = 0; // answer token index (jury)\n\n    // Read number of test cases\n    if (s_idx >= stdin_tokens.size()) return false;\n    int T = stoi(stdin_tokens[s_idx++]);\n\n    for (int tc = 0; tc < T; tc++) {\n        // Read test case parameters\n        if (s_idx + 4 > stdin_tokens.size()) return false;\n        int n  = stoi(stdin_tokens[s_idx++]);\n        int na = stoi(stdin_tokens[s_idx++]);\n        int nb = stoi(stdin_tokens[s_idx++]);\n        int nc = stoi(stdin_tokens[s_idx++]);\n\n        // Read input array\n        vector<ll> a;\n        for (int i = 0; i < n; i++) {\n            if (s_idx >= stdin_tokens.size()) return false;\n            a.push_back(stoll(stdin_tokens[s_idx++]));\n        }\n\n        // Compare result tokens (jury vs participant)\n        if (a_idx >= answer_tokens.size() || o_idx >= stdout_tokens.size()) \n            return false;\n        \n        string jury_res = answer_tokens[a_idx++];\n        string part_res = stdout_tokens[o_idx++];\n\n        if (jury_res != part_res) \n            return false;\n\n        // Skip validation for \"NO\" cases\n        if (part_res == \"NO\") \n            continue;\n\n        // Skip jury's group elements (not needed for validation)\n        int total_ans_elems = na + nb + nc;\n        if (a_idx + total_ans_elems > answer_tokens.size()) \n            return false;\n        a_idx += total_ans_elems;\n\n        // Read participant's group elements\n        vector<vector<ll>> groups(3);\n        groups[0].reserve(na);\n        groups[1].reserve(nb);\n        groups[2].reserve(nc);\n\n        for (int i = 0; i < 3; i++) {\n            int need = (i == 0 ? na : (i == 1 ? nb : nc));\n            if (o_idx + need > stdout_tokens.size()) \n                return false;\n            \n            for (int j = 0; j < need; j++) {\n                groups[i].push_back(stoll(stdout_tokens[o_idx++]));\n            }\n        }\n\n        // Verify all elements are valid and used exactly once\n        multiset<ll> elements(a.begin(), a.end());\n        for (int i = 0; i < 3; i++) {\n            for (ll x : groups[i]) {\n                auto it = elements.find(x);\n                if (it == elements.end()) \n                    return false;\n                elements.erase(it);\n            }\n        }\n        if (!elements.empty()) \n            return false;\n\n        // Calculate group sums\n        ll sum_a = accumulate(all(groups[0]), 0LL);\n        ll sum_b = accumulate(all(groups[1]), 0LL);\n        ll sum_c = accumulate(all(groups[2]), 0LL);\n\n        // Check triangle inequality\n        if (!(sum_a + sum_b > sum_c && \n              sum_b + sum_c > sum_a && \n              sum_a + sum_c > sum_b)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60260, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from correct output (stdout_path)\n  and participant's output (answer_path). Uses absolute/relative \n  error tolerance EPS. Returns true if all numbers match within EPS.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);   // Corresponds to ans (correct output)\n    vector<string> participant_lines = read_file(answer_path);   // Corresponds to ouf (participant's output)\n\n    // Check if line counts match between correct and participant outputs\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        try {\n            double j = stod(correct_lines[i]);  // Correct value (ans)\n            double p = stod(participant_lines[i]); // Participant's value (ouf)\n\n            // Check if values match within EPS tolerance\n            if (fabs(j - p) > EPS && fabs(j - p) / max(1.0, fabs(j)) > EPS) {\n                return false;\n            }\n        } catch (...) {\n            // Conversion failure indicates invalid numeric format\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60377, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer using:\n  - stdin_lines: Input test data (corresponds to testlib's 'inf')\n  - stdout_lines: Correct output (corresponds to testlib's 'ans')\n  - participant_lines: Participant's output (corresponds to testlib's 'ouf')\n  \n  Implements standard token-based comparison logic similar to testlib checkers:\n  1. Verify line count matches\n  2. Compare stripped lines for exact content\n  3. Additional problem-specific checks can be added using stdin_lines\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count consistency between participant's output and correct answer\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison with whitespace-stripped content\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    // Note: Problem-specific validation logic (e.g., checking numeric values,\n    // verifying output format against input constraints) would be added here\n    // using data from stdin_lines when necessary.\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60380, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) with expected output (stdout_path).\n  Returns true if all lines match exactly after trimming whitespace.\n  Note: stdin_path provides the input test case (used if validation logic requires it).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (expected output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Check line count consistency first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60356, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to lowercase for case-insensitive comparison.\n-----------------------------------------------------------*/\nstring to_lower(string s) {\n    for (char &c : s) {\n        c = tolower(c);\n    }\n    return s;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing against jury's answer\n  using the problem input. Returns true if correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines   = read_file(stdin_path);   // Problem input (corresponds to inf)\n    vector<string> ans_lines   = read_file(stdout_path);  // Jury's answer (corresponds to ans)\n    vector<string> ouf_lines   = read_file(answer_path);  // Participant's output (corresponds to ouf)\n\n    // Convert file contents to stringstreams for token processing\n    stringstream inf_ss, ans_ss, ouf_ss;\n    for (const auto& line : inf_lines) inf_ss << line << '\\n';\n    for (const auto& line : ans_lines) ans_ss << line << '\\n';\n    for (const auto& line : ouf_lines) ouf_ss << line << '\\n';\n\n    // Read jury's verdict (first token of answer file)\n    string jury_verdict;\n    if (!(ans_ss >> jury_verdict)) {\n        cerr << \"Error: failed to read jury verdict from answer file.\\n\";\n        return false;\n    }\n\n    // Read participant's verdict (first token of output file)\n    string participant_verdict_raw;\n    if (!(ouf_ss >> participant_verdict_raw)) {\n        cerr << \"Error: failed to read participant's verdict.\\n\";\n        return false;\n    }\n\n    // Normalize participant's verdict to uppercase (\"yes\"  \"YES\", etc.)\n    string participant_verdict = to_lower(participant_verdict_raw);\n    if (participant_verdict == \"yes\") participant_verdict = \"YES\";\n    if (participant_verdict == \"no\")  participant_verdict = \"NO\";\n\n    // Case 1: Jury says \"NO\" (no solution exists)\n    if (jury_verdict == \"NO\") {\n        if (participant_verdict != \"NO\") {\n            cerr << \"Jury answer is NO, but participant output is '\" << participant_verdict_raw << \"'.\\n\";\n            return false;\n        }\n        string extra;\n        if (ouf_ss >> extra) {\n            cerr << \"Jury answer is NO, but participant printed extra tokens.\\n\";\n            return false;\n        }\n        return true;  // Correctly answered NO with no extra output\n    }\n\n    // Case 2: Participant incorrectly says \"NO\" when solution exists\n    if (participant_verdict == \"NO\") {\n        cerr << \"A solution exists, but participant answered NO.\\n\";\n        return false;\n    }\n\n    // Case 3: Participant must say \"YES\" and provide indices\n    if (participant_verdict != \"YES\") {\n        cerr << \"Expected 'YES' or 'NO' as first token, but found '\" << participant_verdict_raw << \"'.\\n\";\n        return false;\n    }\n\n    // Read proposed user indices from participant's output\n    int u1, u2;\n    if (!(ouf_ss >> u1 >> u2)) {\n        cerr << \"Failed to read user indices from participant output.\\n\";\n        return false;\n    }\n    string extra;\n    if (ouf_ss >> extra) {\n        cerr << \"Extra tokens found after user indices.\\n\";\n        return false;\n    }\n\n    // Read problem parameters from input file\n    int n, m;\n    if (!(inf_ss >> n >> m)) {\n        cerr << \"Failed to read n and m from input file.\\n\";\n        return false;\n    }\n\n    // Validate user indices are within bounds and distinct\n    if (u1 < 1 || u1 > n || u2 < 1 || u2 > n) {\n        cerr << \"User indices out of range [1, \" << n << \"]. Got \" << u1 << \" and \" << u2 << \".\\n\";\n        return false;\n    }\n    if (u1 == u2) {\n        cerr << \"User indices must be different, but got \" << u1 << \" and \" << u2 << \".\\n\";\n        return false;\n    }\n\n    // Read all users' activities from input file\n    vector<set<int>> all_activities(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int k;\n        if (!(inf_ss >> k)) {\n            cerr << \"Failed to read activity count for user \" << i << \".\\n\";\n            return false;\n        }\n        for (int j = 0; j < k; ++j) {\n            int activity;\n            if (!(inf_ss >> activity)) {\n                cerr << \"Failed to read activity for user \" << i << \".\\n\";\n                return false;\n            }\n            all_activities[i].insert(activity);\n        }\n    }\n\n    // Check proposed pair forms a valid solution\n    const auto& s1 = all_activities[u1];\n    const auto& s2 = all_activities[u2];\n    vector<int> intersection, diff1, diff2;\n\n    // Must share at least one common activity\n    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(intersection));\n    if (intersection.empty()) {\n        cerr << \"Proposed pair (\" << u1 << \", \" << u2 << \") shares no common activities.\\n\";\n        return false;\n    }\n\n    // Each user must have unique activities compared to the other\n    set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), back_inserter(diff1));\n    if (diff1.empty()) {\n        cerr << \"User \" << u1 << \" has no unique activities compared to User \" << u2 << \".\\n\";\n        return false;\n    }\n\n    set_difference(s2.begin(), s2.end(), s1.begin(), s1.end(), back_inserter(diff2));\n    if (diff2.empty()) {\n        cerr << \"User \" << u2 << \" has no unique activities compared to User \" << u1 << \".\\n\";\n        return false;\n    }\n\n    return true;  // All validation checks passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60375, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against the correct output (stdout.txt).\n  The input (stdin.txt) is available for context if needed during validation.\n  Returns true if outputs match exactly after whitespace normalization, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Validate that participant's output matches the expected output\n    // (line count and exact content after trimming)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60359, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the first token of the jury's answer (stdout.txt) and \n  participant's output (answer.txt). Return true if equal.\n  This replicates the original testlib's token comparison logic:\n    - Reads first non-empty line from each file\n    - Extracts first whitespace-delimited token\n    - Compares tokens for equality\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (jury answer)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant output)\n\n    string juryToken = \"\";\n    // Find first non-empty line in jury's answer and extract first token\n    for (const auto& line : stdout_lines) {\n        if (!line.empty()) {\n            istringstream iss(line);\n            iss >> juryToken;\n            break;\n        }\n    }\n\n    string participantToken = \"\";\n    // Find first non-empty line in participant's output and extract first token\n    for (const auto& line : participant_lines) {\n        if (!line.empty()) {\n            istringstream iss(line);\n            iss >> participantToken;\n            break;\n        }\n    }\n\n    return juryToken == participantToken;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60381, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Returns true if all lines match exactly after trimming whitespace,\n  false otherwise (including line count mismatch or content difference).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);      // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Check line count consistency\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches exactly (after trimming)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60389, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer \n  (stdout.txt) line-by-line after whitespace normalization. \n  Return true if identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Direct comparison of normalized lines between correct answer and participant's output\n    return (stdout_lines == participant_lines);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60385, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt)\n  by tokenizing both files and checking for exact token-by-token equality.\n  Input file (stdin.txt) is available but unused in this token-based checker.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert correct output (stdout) to token sequence\n    vector<string> ans_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;  // Skip empty lines after trimming\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant's output (answer) to token sequence\n    vector<string> ouf_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;  // Skip empty lines after trimming\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Verify token count and content match\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60391, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against correct answer using \n  input data. Compares line-by-line after trimming whitespace.\n  Returns true if outputs match exactly (line count and content),\n  false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60263, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare correct output (stdout.txt) against participant's output \n  (answer.txt) line-by-line. Requires participant's output to have \n  at least as many lines as correct output, with exact match on \n  all lines from correct output (after trimming whitespace).\n  Returns true   all lines match (accept solution)\n          false  line count mismatch or content difference (reject)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Participant must have at least as many lines as correct output\n    if (participant_lines.size() < stdout_lines.size()) {\n        return false;\n    }\n\n    // Verify each line in correct output matches participant's corresponding line\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60390, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against jury's output \n  (participant_lines). Returns true if outputs match exactly after \n  standardizing whitespace, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Direct comparison between participant's output (stdout_lines) \n    // and jury's expected output (participant_lines)\n    return stdout_lines == participant_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60255, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>\n  without trimming leading/trailing whitespace.\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare judge's answer (stdout.txt) and participant's output (answer.txt)\n  line by line. Return true if all lines in judge's answer match the corresponding\n  lines in participant's output and participant's output has at least as many lines.\n  Otherwise, return false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant's output has sufficient lines\n    if (stdout_lines.size() > participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line between judge's answer and participant's output\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60394, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against jury answer (answer.txt)\n  using the same validation logic as testlib-based checkers:\n  - Verify line count matches\n  - Perform exact string comparison on stripped lines\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines  = read_file(stdin_path);   // Corresponds to testlib's \"inf\"\n    vector<string> ouf_lines  = read_file(stdout_path);  // Corresponds to testlib's \"ouf\" (participant's output)\n    vector<string> ans_lines  = read_file(answer_path);  // Corresponds to testlib's \"ans\" (correct answer)\n\n    // Check line count consistency between participant and jury outputs\n    if (ouf_lines.size() != ans_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line exact comparison (after whitespace stripping)\n    for (size_t i = 0; i < ouf_lines.size(); ++i) {\n        if (ouf_lines[i] != ans_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60388, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Returns true if outputs match exactly (line-by-line after trimming whitespace),\n  false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' in testlib\n    vector<string> expected_lines    = read_file(stdout_path);  // Corresponds to 'ans' in testlib\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' in testlib\n\n    // Core functionality: Compare participant's output with expected output\n    if (expected_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        if (expected_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Test input  -> inf\n    const string stdout_path = \"stdout.txt\";  // Expected output -> ans\n    const string answer_path = \"answer.txt\";  // Participant output -> ouf\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60392, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout) against the correct answer.\n  Returns true if all lines match exactly after whitespace trimming,\n  false otherwise. Uses stdin for context if needed in validation.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with expected answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60386, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Input file (stdin.txt) is available for context if needed during validation.\n  Returns true if outputs match exactly after normalization, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare normalized output lines\n    // (Equivalent to testlib's ouf vs ans comparison)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        // Direct string comparison after whitespace normalization\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60387, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against expected answer (answer.txt).\n  Uses line-by-line comparison after trimming whitespace. Returns true if identical.\n  Note: stdin.txt (problem input) is available but not used in this comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: participant's output must exactly match expected answer\n    // after trimming whitespace from both. Direct vector comparison handles line-by-line.\n    return stdout_lines == participant_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60395, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against jury's answer (answer.txt)\n  using problem input (stdin.txt) for context if needed.\n  Return true if outputs match exactly (line-by-line after trimming), \n  false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Validate participant output matches expected answer line-for-line\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60258, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two doubles using absolute and relative error tolerance.\n  Returns true if values are within EPS tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool doubleCompare(double j, double p)\n{\n    double diff = fabs(j - p);\n    if (diff <= EPS) return true;\n    \n    double maxVal = max(fabs(j), fabs(p));\n    if (maxVal < 1e-9) {\n        // Both values are near zero - use absolute comparison\n        return diff <= EPS;\n    }\n    return (diff <= maxVal * EPS);\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt).\n  Both files should contain same number of lines with floating-point values.\n  Returns true if all values match within EPS tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read correct output (ans) from stdout.txt\n    vector<string> ans_lines = read_file(stdout_path);\n    // Read participant's output (ouf) from answer.txt\n    vector<string> ouf_lines = read_file(answer_path);\n\n    // Check if line counts match\n    if (ans_lines.size() != ouf_lines.size()) {\n        return false;\n    }\n\n    // Compare each corresponding value\n    for (size_t i = 0; i < ans_lines.size(); i++) {\n        try {\n            double jury_val = stod(ans_lines[i]);\n            double part_val = stod(ouf_lines[i]);\n            \n            if (!doubleCompare(jury_val, part_val)) {\n                return false;\n            }\n        } catch (...) {\n            // Non-numeric value or conversion error\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60299, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against expected output (participant_lines)\n  by normalizing all tokens (ignoring line breaks and extra whitespace) and verifying\n  token-by-token equality. This matches standard testlib checker behavior for most problems.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Extract all tokens from participant's output (stdout)\n    vector<string> participant_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Extract all tokens from expected output (answer/ouf)\n    vector<string> expected_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            expected_tokens.push_back(token);\n        }\n    }\n\n    // Verify both token sequences are identical\n    return participant_tokens == expected_tokens;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60396, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected answer:\n  - stdin_lines: problem input (inf), may be unused in standard problems\n  - stdout_lines: expected output (ans/jury answer)\n  - participant_lines: contestant's output (ouf)\n  Returns true if outputs match exactly after whitespace trimming.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check line count mismatch first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line (already stripped of leading/trailing whitespace)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60425, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing their output against\n  the jury's answer using the problem input. The validation checks:\n  1. Jury's maximum value (ja) equals participant's claimed value (pa)\n  2. Participant's string has correct length (n)\n  3. Computed maximum coverage matches participant's claimed value\n  \n  Returns true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> problem_input = read_file(stdin_path);   // Corresponds to inf (problem input)\n    vector<string> jury_answer   = read_file(stdout_path);  // Corresponds to ans (jury's answer)\n    vector<string> participant   = read_file(answer_path);  // Corresponds to ouf (participant's output)\n\n    // Validate input file structure\n    if (problem_input.empty() || jury_answer.empty() || participant.size() < 2) \n        return false;\n\n    // Parse problem input: first line is n, next n lines are intervals\n    int n;\n    try {\n        n = stoi(problem_input[0]);\n    } catch (...) {\n        return false;\n    }\n    \n    vector<pair<int, int>> intervals;\n    for (int i = 0; i < n; i++) {\n        if (problem_input.size() < 1 + i + 1) \n            return false;\n        \n        stringstream ss(problem_input[1 + i]);\n        int a, b;\n        if (!(ss >> a >> b)) \n            return false;\n        intervals.push_back({a, b});\n    }\n\n    // Parse jury's answer (first token of first line)\n    int ja;\n    try {\n        ja = stoi(jury_answer[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Parse participant's output: first token is pa, second line is the string\n    int pa;\n    try {\n        pa = stoi(participant[0]);\n    } catch (...) {\n        return false;\n    }\n    string str = participant[1];\n\n    // Check 1: Jury's value must match participant's claimed value\n    if (ja != pa) \n        return false;\n\n    // Check 2: String must have length n\n    if (static_cast<int>(str.length()) != n) \n        return false;\n\n    // Compute maximum coverage using participant's string\n    vector<int> sum(2 * n + 2, 0);  // 1-indexed up to 2n, +2 for safety\n    \n    for (int i = 0; i < n; i++) {\n        int a = intervals[i].first;\n        int b = intervals[i].second;\n        \n        if (str[i] == '1') {\n            // Apply operation type 1: [a, b]\n            sum[a]++;\n            if (b + 1 <= 2 * n + 1) \n                sum[b + 1]--;\n        } else {\n            // Apply operation type 0: [1, a-1] and [b+1, 2n]\n            if (a > 1) {  // [1, a-1] is valid\n                sum[1]++;\n                sum[a]--;\n            }\n            if (b < 2 * n) {  // [b+1, 2n] is valid\n                sum[b + 1]++;\n                sum[2 * n + 1]--;  // Note: 2n+1 is within our vector bounds\n            }\n        }\n    }\n\n    // Calculate prefix sums and track maximum coverage\n    int maxNum = 0;\n    for (int i = 1; i <= 2 * n; i++) {\n        sum[i] += sum[i - 1];\n        maxNum = max(maxNum, sum[i]);\n    }\n\n    // Check 3: Computed maximum must match participant's claimed value\n    return (maxNum == pa);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60321, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt).\n  Returns true if all stripped lines match exactly, false otherwise.\n  Note: \n    - stdin.txt   inf (input file)\n    - stdout.txt  ans (correct output)\n    - answer.txt  ouf (participant's output)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with correct output\n    // (after both have been stripped of surrounding whitespace)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60397, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against correct answer.\n  Compares 'answer.txt' (participant output) with 'stdout.txt' (correct output)\n  after normalizing whitespace. Input file ('stdin.txt') is available for context\n  if validation logic requires it.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic: strict line-by-line comparison after whitespace normalization\n    // Note: read_file() already trims each line, so comparison ignores leading/trailing whitespace\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60429, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper: Parse all long long tokens from vector of lines.\n  Splits each line into whitespace-separated tokens and converts\n  to numerical values (ignoring empty lines).\n-----------------------------------------------------------*/\nstatic vector<long long> parse_tokens(const vector<string>& lines) {\n    vector<long long> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            tokens.push_back(num);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Helper: Returns English ordinal suffix for a number\n  (e.g., 1 -> \"st\", 2 -> \"nd\", 3 -> \"rd\", 11 -> \"th\").\n-----------------------------------------------------------*/\nstatic string englishEnding(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of signed integers from participant's output\n  and jury's answer. Validates that both sequences are identical in\n  content and length. Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse tokens from both answer and output files\n    auto ans_tokens = parse_tokens(stdout_lines);\n    auto ouf_tokens = parse_tokens(participant_lines);\n\n    size_t min_size = min(ans_tokens.size(), ouf_tokens.size());\n    int n = 0;\n    string firstElems;\n\n    // Compare common elements\n    for (size_t i = 0; i < min_size; ++i) {\n        n++;\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            cerr << n << englishEnding(n) << \" numbers differ - expected: '\"\n                 << ans_tokens[i] << \"', found: '\" << ouf_tokens[i] << \"'\\n\";\n            return false;\n        }\n        // Record first 5 elements for success message\n        if (n <= 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(ans_tokens[i]);\n        }\n    }\n\n    // Check for extra elements in jury's answer\n    if (ans_tokens.size() > min_size) {\n        cerr << \"Answer contains longer sequence [length = \" << ans_tokens.size()\n             << \"], but output contains \" << ouf_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra elements in participant's output\n    if (ouf_tokens.size() > min_size) {\n        cerr << \"Output contains longer sequence [length = \" << ouf_tokens.size()\n             << \"], but answer contains \" << ans_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // All elements match - output success message\n    if (n <= 5) {\n        cout << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60421, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Replacement for testlib.h checker logic. Compares participant's \n  output (read from answer.txt) against correct output (stdout.txt),\n  using input file content (stdin.txt) if needed for validation.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines      = read_file(stdin_path);      // Corresponds to testlib's inf\n    vector<string> ans_lines      = read_file(stdout_path);     // Corresponds to testlib's ans (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to testlib's ouf (participant's output)\n\n    // TODO: Implement actual comparison logic here (e.g., line-by-line check, token comparison, etc.)\n    // Example: return participant_lines == ans_lines;\n\n    return true;   // Placeholder - replace with actual validation logic\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60427, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt)\n  token-by-token as integers. Returns true if all tokens match exactly,\n  false otherwise (mismatched values, count, or non-integer tokens).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Unused (corresponds to problem input)\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct output (jury's answer)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Convert correct output lines into integer tokens\n    vector<int> correct_tokens;\n    for (const string& line : correct_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                correct_tokens.push_back(stoi(token));\n            } catch (...) {\n                return false;  // Non-integer token found\n            }\n        }\n    }\n\n    // Convert participant's output lines into integer tokens\n    vector<int> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                participant_tokens.push_back(stoi(token));\n            } catch (...) {\n                return false;  // Non-integer token found\n            }\n        }\n    }\n\n    // Verify token count and values match exactly\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Corresponds to problem input (inf)\n    const string stdout_path = \"stdout.txt\";  // Correct output (ans)\n    const string answer_path = \"answer.txt\";  // Participant's output (ouf)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60448, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the correct answer (from stdout.txt) and participant's output (from answer.txt).\n  Both files should contain a single integer. Return true if they match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if both answer files have at least one line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integers from the first line of each file (already trimmed)\n        int correct_answer = stoi(stdout_lines[0]);\n        int participant_output = stoi(participant_lines[0]);\n        \n        return (correct_answer == participant_output);\n    } catch (...) {\n        // Handle non-integer values or conversion errors as WA\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60409, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) with correct answer (participant_lines).\n  Return true if they match exactly line by line after trimming.\n  Note: \n    - stdin_lines corresponds to testlib's 'inf' (input test data)\n    - stdout_lines corresponds to testlib's 'ans' (participant's output)\n    - participant_lines corresponds to testlib's 'ouf' (correct output/answer)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    // Compare each line after trimming (already done during file reading)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60433, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against the correct answer\n  (answer.txt). Each file must contain exactly two lines, each with an integer.\n  The first line represents x-coordinate, the second represents y-coordinate.\n  Return true if both coordinates match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if both output files contain at least 2 lines\n    if (stdout_lines.size() < 2 || participant_lines.size() < 2) {\n        return false;\n    }\n\n    try {\n        // Parse coordinates from participant's output (stdout) and correct answer\n        ll x1 = stoll(stdout_lines[0]);\n        ll y1 = stoll(stdout_lines[1]);\n        ll x2 = stoll(participant_lines[0]);\n        ll y2 = stoll(participant_lines[1]);\n\n        // Validate both coordinates match\n        return (x1 == x2) && (y1 == y2);\n    } catch (...) {\n        // Handle conversion errors (non-integer values)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60430, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Determine English ordinal suffix (1st, 2nd, 3rd, etc.).\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) \n        return \"th\";\n    \n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Shorten long strings for error messages (similar to testlib's compress).\n-----------------------------------------------------------*/\nstring compress(const string& s)\n{\n    if (s.length() <= 100) \n        return s;\n    \n    return s.substr(0, 50) + \"...\" + s.substr(s.size() - 40);\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into vector of tokens by splitting\n  on whitespace (mimics testlib's token-by-token reading).\n-----------------------------------------------------------*/\nvector<string> tokenize_lines(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer token-by-token.\n  Returns true if valid, false otherwise with appropriate message.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Corresponds to 'ans' (jury answer)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant output)\n\n    vector<string> correct_tokens     = tokenize_lines(correct_lines);\n    vector<string> participant_tokens = tokenize_lines(participant_lines);\n\n    size_t min_size = min(correct_tokens.size(), participant_tokens.size());\n    for (size_t i = 0; i < min_size; i++) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            int n = i + 1;\n            string ending = englishEnding(n);\n            string expected = compress(correct_tokens[i]);\n            string found = compress(participant_tokens[i]);\n            \n            cerr << n << ending << \" outputs differ - expected: '\" << expected \n                 << \"', found: '\" << found << \"'\" << endl;\n            return false;\n        }\n    }\n\n    if (correct_tokens.size() == participant_tokens.size()) {\n        if (correct_tokens.size() == 1) {\n            cout << \"\\\"\" << compress(correct_tokens[0]) << \"\\\"\" << endl;\n        } else {\n            cout << correct_tokens.size() << \" tokens\" << endl;\n        }\n        return true;\n    } \n    else if (participant_tokens.size() > correct_tokens.size()) {\n        cerr << \"Participant output contains extra tokens\" << endl;\n        return false;\n    } \n    else {\n        cerr << \"Unexpected EOF in the participants output\" << endl;\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60410, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing against the correct answer.\n  Uses:\n    - stdin_lines: problem input (inf)\n    - stdout_lines: correct output (ans)\n    - participant_lines: participant's output (ouf)\n  Return true  accepted, false  rejected.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant's output matches the correct answer line-by-line\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        // Direct comparison after whitespace trimming (already done by read_file)\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60431, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output against the jury's answer.\n  Both files are expected to contain a sequence of \"YES\" or \"NO\"\n  tokens (case-insensitive), one per line. The validation checks:\n    - All tokens must be \"YES\" or \"NO\" (case-insensitive)\n    - Tokens must match exactly between answer and output\n    - Both files must have identical token count\n  Returns true if all conditions met, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files: stdin (input), stdout (jury answer), answer (participant output)\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines   = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> ouf_lines   = read_file(answer_path);  // Participant's output (ouf)\n\n    const string YES = \"YES\";\n    const string NO  = \"NO\";\n\n    // Compare each token pair up to the minimum file length\n    size_t n = min(ans_lines.size(), ouf_lines.size());\n    for (size_t i = 0; i < n; i++) {\n        string ja = ans_lines[i];\n        string pa = ouf_lines[i];\n\n        // Convert to uppercase for case-insensitive comparison\n        for (char& c : ja) c = toupper(c);\n        for (char& c : pa) c = toupper(c);\n\n        // Validate jury's token is YES/NO\n        if (ja != YES && ja != NO) \n            return false;\n\n        // Validate participant's token is YES/NO\n        if (pa != YES && pa != NO) \n            return false;\n\n        // Check token match\n        if (ja != pa) \n            return false;\n    }\n\n    // Verify both files have identical token count\n    if (ans_lines.size() != ouf_lines.size())\n        return false;\n\n    // All validations passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60428, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst string YES = \"YES\";\nconst string NO = \"NO\";\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into a flat vector of tokens by\n  splitting each line on whitespace boundaries.\n-----------------------------------------------------------*/\nvector<string> extract_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validator for the problem's specific comparison logic.\n  Returns true if participant's output matches expected behavior,\n  false otherwise (WA, PE, or other failures).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all files into line-splitted vectors\n    vector<string> stdin_lines    = read_file(stdin_path);    // Corresponds to 'inf' (input test data)\n    vector<string> stdout_lines   = read_file(stdout_path);   // Corresponds to 'ans' (correct answer)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to 'ouf' (participant's output)\n\n    // Convert lines into token streams for processing\n    vector<string> stdin_tokens      = extract_tokens(stdin_lines);\n    vector<string> stdout_tokens     = extract_tokens(stdout_lines);\n    vector<string> participant_tokens = extract_tokens(participant_lines);\n\n    // Track current position in each token stream\n    int stdin_idx = 0, stdout_idx = 0, participant_idx = 0;\n    int index = 0, yesCount = 0, noCount = 0;\n    string pa;\n\n    // Check if input has at least one token for test count 't'\n    if (stdin_idx >= stdin_tokens.size()) \n        return false;\n    \n    int t = stoi(stdin_tokens[stdin_idx++]);\n\n    while (t--) {\n        index++;\n\n        // Read problem parameters: n, k, and array a\n        if (stdin_idx + 2 > stdin_tokens.size()) \n            return false;\n        int n = stoi(stdin_tokens[stdin_idx++]);\n        int k = stoi(stdin_tokens[stdin_idx++]);\n\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            if (stdin_idx >= stdin_tokens.size()) \n                return false;\n            a[i] = stoi(stdin_tokens[stdin_idx++]);\n        }\n\n        // Read jury's answer token and participant's token\n        if (stdout_idx >= stdout_tokens.size() || \n            participant_idx >= participant_tokens.size()) \n            return false;\n        \n        string ja = stdout_tokens[stdout_idx++];\n        pa = participant_tokens[participant_idx++];\n\n        // Validate jury's answer format\n        if (ja != YES && ja != NO) \n            return false;\n\n        // Count participant's YES/NO responses and validate format\n        if (pa == YES)         yesCount++;\n        else if (pa == NO)     noCount++;\n        else                   return false;\n\n        // Check if participant's answer matches jury's answer\n        if (ja != pa) \n            return false;\n\n        // Special validation when answer is YES\n        if (ja == YES) {\n            vector<string> vouf(n);\n            for (int i = 0; i < n; i++) {\n                // Read and ignore jury's tokens (not used in validation)\n                if (stdout_idx >= stdout_tokens.size()) \n                    return false;\n                stdout_idx++;\n\n                // Read participant's key tokens\n                if (participant_idx >= participant_tokens.size()) \n                    return false;\n                vouf[i] = participant_tokens[participant_idx++];\n\n                // Validate token format: must be binary string of length k\n                if ((int)vouf[i].size() != k) \n                    return false;\n                for (char c : vouf[i]) {\n                    if (c != '0' && c != '1') \n                        return false;\n                }\n            }\n\n            // Check circular difference constraints\n            for (int i = 0; i < n; i++) {\n                int difference = 0;\n                for (int j = 0; j < k; j++) {\n                    if (vouf[i][j] != vouf[(i + 1) % n][j]) \n                        difference++;\n                }\n                if (difference != a[i]) \n                    return false;\n            }\n        }\n    }\n\n    // Verify no extra tokens exist in any stream\n    if (stdout_idx != stdout_tokens.size() || \n        participant_idx != participant_tokens.size()) \n        return false;\n\n    // All validations passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60324, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Uses stripped lines for comparison (ignoring surrounding whitespace).\n  Returns true if all lines match exactly after trimming, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60434, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two signed integers from answer.txt (correct solution)\n  and stdout.txt (contestant's output). Return true if they match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // Contestant's output\n    vector<string> answer_lines = read_file(answer_path);  // Correct answer\n\n    // Check if both output files contain exactly one integer\n    if (stdout_lines.size() != 1 || answer_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Parse integers from the trimmed lines\n        int correct_answer = stoi(answer_lines[0]);\n        int contestant_out = stoi(stdout_lines[0]);\n\n        // Compare the two integers\n        return (correct_answer == contestant_out);\n    } catch (...) {\n        // Handle non-integer content\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60432, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing the correct answer (stdout.txt)\n  with the participant's output (answer.txt):\n  1. Parse first integer from each file's first line\n  2. Return false (WA) if integers differ\n  3. Return false (PE) if correct answer ends but participant has extra output\n  4. Otherwise return true (OK)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path); // Input data (unused in this validator)\n    vector<string> stdout_lines = read_file(stdout_path); // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path); // Participant's output (ouf)\n\n    // Check if either file has no content\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    int ja, pa;\n    bool ans_eof = false;\n    bool ouf_eof = false;\n\n    // Parse integer from correct answer's first line\n    try {\n        size_t pos;\n        ja = stoi(stdout_lines[0], &pos);\n        // Check if entire first line consumed and no additional lines exist\n        ans_eof = (pos == stdout_lines[0].size()) && (stdout_lines.size() == 1);\n    } catch (...) {\n        return false; // Failed to parse integer\n    }\n\n    // Parse integer from participant's output first line\n    try {\n        size_t pos;\n        pa = stoi(participant_lines[0], &pos);\n        // Check if entire first line consumed and no additional lines exist\n        ouf_eof = (pos == participant_lines[0].size()) && (participant_lines.size() == 1);\n    } catch (...) {\n        return false; // Failed to parse integer\n    }\n\n    // Check for mismatched integers\n    if (ja != pa) {\n        return false;\n    }\n\n    // Check for extra output in participant's file when correct answer has ended\n    if (ans_eof && !ouf_eof) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60424, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's \n  correct output (stdout.txt) using input (stdin.txt) context.\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input test case)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Core comparison logic: Check if participant's output matches expected output\n    // (Line-by-line comparison after whitespace normalization)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Input test case (inf)\n    const string stdout_path = \"stdout.txt\";  // Correct output (ans)\n    const string answer_path = \"answer.txt\";  // Participant's output (ouf)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60422, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against the correct output (stdout.txt).\n  The input (stdin.txt) is available for context if needed.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if line counts match between participant's output and correct answer\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after stripping whitespace\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60383, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's output using \n  input data. Compares line-by-line after whitespace trimming.\n  Returns true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each corresponding line\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        // Direct string comparison (already stripped by read_file)\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60286, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens from jury's output (stdout.txt) and participant's output (answer.txt).\n  Tokenize each line by whitespace and compare the sequence of tokens.\n  Return true if all tokens match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Extract tokens from jury's answer (stdout_lines)\n    vector<string> jury_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            jury_tokens.push_back(token);\n        }\n    }\n\n    // Extract tokens from participant's output\n    vector<string> output_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            output_tokens.push_back(token);\n        }\n    }\n\n    // Compare token sequences\n    return (jury_tokens == output_tokens);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60437, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by checking participant's output (answer.txt)\n  against correct answer (stdout.txt) using input (stdin.txt)\n  to determine number of test cases. Implements the intuitive\n  elements problem checker logic with case-insensitive comparison\n  of \"YES\"/\"NO\" responses.\n  \n  Returns true   solution accepted\n          false  solution rejected\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files into line vectors\n    vector<string> stdin_lines        = read_file(stdin_path);\n    vector<string> correct_answer_lines = read_file(stdout_path);  // Corresponds to 'ans' in original\n    vector<string> participant_lines  = read_file(answer_path);    // Corresponds to 'ouf' in original\n\n    // Parse number of test cases (t) from first line of stdin\n    if (stdin_lines.empty()) {\n        cerr << \"Error: Input file is empty\\n\";\n        return false;\n    }\n    istringstream iss(stdin_lines[0]);\n    int t;\n    if (!(iss >> t) || t <= 0) {\n        cerr << \"Error: Invalid number of test cases\\n\";\n        return false;\n    }\n\n    // Extract all tokens from correct answer file (ans)\n    vector<string> expected_tokens;\n    for (const string& line : correct_answer_lines) {\n        istringstream line_iss(line);\n        string token;\n        while (line_iss >> token) {\n            expected_tokens.push_back(token);\n        }\n    }\n\n    // Extract all tokens from participant's output file (ouf)\n    vector<string> found_tokens;\n    for (const string& line : participant_lines) {\n        istringstream line_iss(line);\n        string token;\n        while (line_iss >> token) {\n            found_tokens.push_back(token);\n        }\n    }\n\n    // Verify sufficient expected answers exist\n    if (expected_tokens.size() < t) {\n        cerr << \"Error: Expected at least \" << t << \" answers, found \" \n             << expected_tokens.size() << \"\\n\";\n        return false;\n    }\n\n    // Verify participant provided exactly t answers\n    if (found_tokens.size() != t) {\n        if (found_tokens.size() < t) {\n            cerr << \"Error: Expected \" << t << \" answers, output is empty for some test cases\\n\";\n        } else {\n            cerr << \"Error: Expected exactly \" << t << \" answers, found extra content\\n\";\n        }\n        return false;\n    }\n\n    // Process each test case\n    for (int i = 0; i < t; i++) {\n        string expected = expected_tokens[i];\n        string found = found_tokens[i];\n\n        // Normalize to uppercase for case-insensitive comparison\n        transform(expected.begin(), expected.end(), expected.begin(), \n                 [](unsigned char c) { return toupper(c); });\n        transform(found.begin(), found.end(), found.begin(), \n                 [](unsigned char c) { return toupper(c); });\n\n        // Validate response format\n        if (found != \"YES\" && found != \"NO\") {\n            cerr << \"Error: Test case \" << i+1 << \" - found '\" \n                 << found << \"', expected 'YES' or 'NO'\\n\";\n            return false;\n        }\n\n        // Compare against expected answer\n        if (expected != found) {\n            cerr << \"Error: Test case \" << i+1 << \" - expected \" \n                 << expected << \", found \" << found << \"\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60438, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer by:\n  1. Ensuring both contain exactly one valid integer\n  2. Verifying the integers match\n  Returns true if valid, false otherwise with error message to cerr.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Helper: Convert lines to whitespace-separated tokens\n    auto get_tokens = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    // Helper: Check if string represents a valid integer\n    auto is_integer = [](const string& s) -> bool {\n        if (s.empty()) return false;\n        size_t i = 0;\n        if (s[0] == '-') {\n            if (s.size() == 1) return false; // Single '-' invalid\n            i = 1;\n        }\n        for (; i < s.size(); ++i) {\n            if (!isdigit(static_cast<unsigned char>(s[i]))) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // Extract tokens from both outputs\n    vector<string> stdout_tokens = get_tokens(stdout_lines);\n    vector<string> participant_tokens = get_tokens(participant_lines);\n\n    // Validate jury's answer format (should be exactly 1 integer)\n    if (stdout_tokens.size() != 1) {\n        cerr << \"Checker error: expected 1 integer in jury answer, but found \" \n             << stdout_tokens.size() << \" tokens.\\n\";\n        return false;\n    }\n    if (!is_integer(stdout_tokens[0])) {\n        cerr << \"Checker error: invalid integer in jury answer: '\" \n             << stdout_tokens[0] << \"'\\n\";\n        return false;\n    }\n\n    // Validate participant's output format\n    if (participant_tokens.empty()) {\n        cerr << \"Expected 1 integer, but output is empty\\n\";\n        return false;\n    }\n    if (participant_tokens.size() > 1) {\n        cerr << \"Expected exactly 1 integer, but found extra content: '\" \n             << participant_tokens[1] << \"'\\n\";\n        return false;\n    }\n    if (!is_integer(participant_tokens[0])) {\n        cerr << \"Invalid integer in output: '\" << participant_tokens[0] << \"'\\n\";\n        return false;\n    }\n\n    // Compare integer values\n    try {\n        int expected = stoi(stdout_tokens[0]);\n        int found = stoi(participant_tokens[0]);\n        if (expected != found) {\n            cerr << \"Expected \" << expected << \", found \" << found << '\\n';\n            return false;\n        }\n    } catch (...) {\n        cerr << \"Integer conversion error\\n\";\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60451, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct output line-by-line.\n  Returns true if all lines match after trimming, false otherwise.\n  Note: stdin content is read but not used in comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Verify line count matches\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (correct_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60439, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to parse tokens from lines into vector of long long.\n  Processes all whitespace-separated tokens across all lines.\n-----------------------------------------------------------*/\nvector<long long> parse_tokens(const vector<string>& lines) {\n    vector<long long> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                tokens.push_back(stoll(token));\n            } catch (...) {\n                cerr << \"Invalid number format in token: \" << token << endl;\n                exit(1);\n            }\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing expected output (ans) and \n  contestant's output (ouf) as sequences of integers.\n  Returns true if sequences are identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // stdin_path: input test data (inf) - unused in this checker\n    // stdout_path: expected output (ans)\n    // answer_path: contestant's output (ouf)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);\n    vector<string> contestant_lines  = read_file(answer_path);\n\n    auto expected_tokens  = parse_tokens(expected_lines);\n    auto contestant_tokens = parse_tokens(contestant_lines);\n\n    // Check sequence length equality\n    if (expected_tokens.size() != contestant_tokens.size()) {\n        return false;\n    }\n\n    // Verify each element matches\n    for (size_t i = 0; i < expected_tokens.size(); ++i) {\n        if (expected_tokens[i] != contestant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60440, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate by comparing jury's answer (from stdout.txt) and \n  contestant's output (from answer.txt). The stdin.txt content \n  is unused in this particular problem's validation logic.\n  Returns true if integer values match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to ans (jury answer)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to ouf (contestant output)\n\n    // Ensure both files have at least one valid line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integer values from first non-empty line\n        int jury_answer     = stoi(stdout_lines[0]);\n        int contestant_ans  = stoi(participant_lines[0]);\n\n        if (jury_answer != contestant_ans) {\n            return false;\n        }\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60453, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Checker logic for the \"favourite dish\" problem.\n  Validates contestant's output against expected output using \n  problem input constraints. Returns true for accepted, false for WA.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> model_lines       = read_file(stdout_path);\n    vector<string> contestant_lines  = read_file(answer_path);\n\n    // Check if input file is empty\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse n (number of people) and m (number of dishes) from first line\n    istringstream first_line(stdin_lines[0]);\n    int n, m;\n    if (!(first_line >> n >> m)) {\n        return false;\n    }\n\n    // Verify sufficient lines for input data (n + m lines after first line)\n    if (stdin_lines.size() < 1 + (size_t)(n + m)) {\n        return false;\n    }\n\n    // Validate each of the next n + m lines contains exactly two integers\n    for (int i = 0; i < n + m; i++) {\n        istringstream line_stream(stdin_lines[1 + i]);\n        int a, b;\n        string extra;\n        if (!(line_stream >> a) || !(line_stream >> b) || (line_stream >> extra)) {\n            return false;\n        }\n    }\n\n    // Verify model output (expected answers) has exactly m lines\n    if (model_lines.size() != (size_t)m) {\n        return false;\n    }\n\n    // Verify contestant output has exactly m lines\n    if (contestant_lines.size() != (size_t)m) {\n        return false;\n    }\n\n    // Compare each dish selection line-by-line\n    for (int i = 0; i < m; i++) {\n        // Parse expected dish number from model output\n        istringstream model_stream(model_lines[i]);\n        int expected;\n        string extra;\n        if (!(model_stream >> expected) || (model_stream >> extra)) {\n            return false;\n        }\n\n        // Parse contestant's dish selection\n        istringstream ouf_stream(contestant_lines[i]);\n        int found;\n        if (!(ouf_stream >> found) || (ouf_stream >> extra)) {\n            return false;\n        }\n\n        // Validate dish number is within [1, n] for both outputs\n        if (found < 1 || found > n || expected < 1 || expected > n) {\n            return false;\n        }\n\n        // Check if selections match\n        if (expected != found) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60441, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to compress long strings for output.\n  Truncates to 100 characters with \"...\" suffix if needed.\n-----------------------------------------------------------*/\nstring compress(const string& s)\n{\n    if (s.size() <= 100)\n        return s;\n    else\n        return s.substr(0, 100) + \"...\";\n}\n\n/*-----------------------------------------------------------\n  Helper function to get English ordinal suffix for numbers.\n  (e.g., 1  \"st\", 2  \"nd\", 3  \"rd\", 11  \"th\")\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13)\n        return \"th\";\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into a vector of tokens by splitting\n  on whitespace (mimics testlib's token reading behavior).\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer token-by-token.\n  Returns true if valid, false otherwise (with diagnostic output).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files (stdin_path unused for this comparison)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert lines to tokens for comparison\n    vector<string> correct_tokens     = tokenize(correct_lines);\n    vector<string> participant_tokens = tokenize(participant_lines);\n\n    // Compare tokens one-by-one\n    size_t n = 0;\n    const size_t min_size = min(correct_tokens.size(), participant_tokens.size());\n    \n    for (; n < min_size; n++) {\n        if (correct_tokens[n] != participant_tokens[n]) {\n            // Token mismatch found\n            cout << n+1 << englishEnding(n+1).c_str() \n                 << \" words differ - expected: '\" \n                 << compress(correct_tokens[n]) << \"', found: '\" \n                 << compress(participant_tokens[n]) << \"'\\n\";\n            return false;\n        }\n    }\n\n    // Check for EOF consistency\n    if (correct_tokens.size() == participant_tokens.size()) {\n        // Both files exhausted simultaneously\n        if (n == 1)\n            cout << \"\\\"\" << compress(correct_tokens[0]) << \"\\\"\\n\";\n        else\n            cout << n << \" tokens\\n\";\n        return true;\n    }\n    else {\n        // One file has extra tokens\n        if (correct_tokens.size() > participant_tokens.size())\n            cout << \"Unexpected EOF in the participants output\\n\";\n        else\n            cout << \"Participant output contains extra tokens\\n\";\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60452, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to split lines into individual tokens\n  by treating all whitespace as delimiters.\n-----------------------------------------------------------*/\nstatic vector<string> tokenize_lines(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Helper function to safely parse a string as integer.\n  Returns true if the entire string is a valid integer.\n-----------------------------------------------------------*/\nstatic bool try_parse_int(const string& s, int& out)\n{\n    try {\n        size_t pos;\n        out = stoi(s, &pos);\n        return (pos == s.size());\n    } catch (...) {\n        return false;\n    }\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected output.\n  Compares token pairs (string, integer) sequentially.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify critical files were read successfully\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    auto ans_tokens = tokenize_lines(stdout_lines);      // Expected output tokens\n    auto ouf_tokens = tokenize_lines(participant_lines); // Participant's output tokens\n\n    // Must have matching token counts and even number of tokens (pairs)\n    if (ans_tokens.size() != ouf_tokens.size() || ans_tokens.size() % 2 != 0) {\n        return false;\n    }\n\n    // Process token pairs: [string, integer] for both streams\n    for (size_t i = 0; i < ans_tokens.size(); i += 2) {\n        // Compare string tokens\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n\n        // Compare integer tokens\n        int expected_int, participant_int;\n        if (!try_parse_int(ans_tokens[i+1], expected_int) || \n            !try_parse_int(ouf_tokens[i+1], participant_int) ||\n            expected_int != participant_int) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60450, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from correct answer\n  (stdout.txt) and participant's output (answer.txt). Return true\n  if sequences are identical in both length and element values.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines   = read_file(stdout_path);  // Correct answer (corresponds to 'ans' in original)\n    vector<string> ouf_lines   = read_file(answer_path);  // Participant's output (corresponds to 'ouf' in original)\n\n    // Convert answer lines to individual tokens (numbers)\n    vector<string> ans_tokens;\n    for (const string& line : ans_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant's output lines to individual tokens\n    vector<string> ouf_tokens;\n    for (const string& line : ouf_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Check if token counts differ (extra elements in either stream)\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token as numeric values\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        try {\n            ll j = stoll(ans_tokens[i]);\n            ll p = stoll(ouf_tokens[i]);\n            if (j != p) {\n                return false;\n            }\n        } catch (...) {\n            return false;  // Invalid number format\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60455, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate contestant's solution by comparing model answer \n  (from stdout.txt) against contestant's output (from answer.txt).\n  The stdin.txt is unused in this problem but maintained for \n  structural consistency with the template.\n\n  Returns true if:\n    1. Contestant's output is exactly \"ALICE\", \"BOB\", or \"TIED\"\n    2. Contestant's output matches the model answer\n    \n  Otherwise returns false (indicating WA or PE).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read model answer (corresponds to 'ans' in testlib) from stdout.txt\n    vector<string> model_lines = read_file(stdout_path);\n    // Read contestant's output (corresponds to 'ouf' in testlib) from answer.txt\n    vector<string> contestant_lines = read_file(answer_path);\n\n    // Fail if either file is empty\n    if (model_lines.empty() || contestant_lines.empty()) {\n        return false;\n    }\n\n    // Extract first word from first line (mimics testlib's readWord)\n    auto get_first_word = [](const string& s) {\n        size_t pos = s.find(' ');\n        return (pos == string::npos) ? s : s.substr(0, pos);\n    };\n\n    string model_word = get_first_word(model_lines[0]);\n    string contestant_word = get_first_word(contestant_lines[0]);\n\n    // Check contestant output is one of the allowed strings (PE check)\n    if (contestant_word != \"ALICE\" && \n        contestant_word != \"BOB\" && \n        contestant_word != \"TIED\") {\n        return false;\n    }\n\n    // Check contestant output matches model answer (WA check)\n    if (contestant_word != model_word) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60460, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  without modifying the lines (no trimming).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected \n  output (stdout_path) line by line. Return true if all lines \n  match and no extra lines exist; false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all expected lines match participant's output\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        // Participant's output has fewer lines than expected\n        if (i >= participant_lines.size()) {\n            return false;\n        }\n        // Current line content differs\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    // Check for any extra lines in participant's output\n    if (participant_lines.size() > stdout_lines.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60449, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (from answer.txt) against correct answer (from stdout.txt).\n  If correct answer starts with 'n', exact string match is required.\n  Otherwise, floating-point values are compared within EPS=1e-4.\n-----------------------------------------------------------*/\nconst double EPS = 1e-4;\n\nbool doubleCompare(double a, double b, double eps) {\n    return fabs(a - b) <= eps;\n}\n\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if both answer files have at least one line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    string jury_line   = stdout_lines[0];      // Correct answer (maps to ans in original code)\n    string participant_line = participant_lines[0]; // Participant's output (maps to ouf in original code)\n\n    // Case 1: Expected answer starts with 'n' (e.g., \"no solution\")\n    if (!jury_line.empty() && jury_line[0] == 'n') {\n        if (jury_line != participant_line) {\n            return false;\n        }\n        return true;\n    }\n    // Case 2: Floating-point comparison\n    else {\n        try {\n            double expected = stod(jury_line);\n            double found    = stod(participant_line);\n            if (!doubleCompare(expected, found, EPS)) {\n                return false;\n            }\n            return true;\n        } catch (...) {\n            // Conversion failed (non-numeric input when expecting number)\n            return false;\n        }\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60447, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against the correct answer (answer.txt)\n  by reading the first line of each as a signed 64-bit integer.\n  Return true if values match, false otherwise (including format errors).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Ensure both output files contain exactly one line\n    if (stdout_lines.size() != 1 || answer_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Convert trimmed lines to 64-bit integers\n        long long jury_ans    = stoll(answer_lines[0]);\n        long long participant_ans = stoll(stdout_lines[0]);\n\n        return jury_ans == participant_ans;\n    }\n    catch (...) {\n        // Handle conversion errors (non-integer content, out-of-range values)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60413, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against expected answer using:\n  - stdin_lines:  corresponds to testlib's 'inf' (input)\n  - stdout_lines: corresponds to testlib's 'ans' (expected output)\n  - participant_lines: corresponds to testlib's 'ouf' (participant's output)\n  Returns true for accepted solutions, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic adapted from testlib checker:\n    // Compare participant's output (answer.txt) with expected output (stdout.txt)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        // Perform line-by-line comparison (whitespace already trimmed)\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60457, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (answer.txt) against jury's output (stdout.txt).\n  Validates:\n    1. Both files have same number of integer answers\n    2. Each integer matches expected value\n  Returns true if all checks pass, false otherwise with error details on cerr.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdout_lines = read_file(stdout_path);   // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path); // Contestant's output\n\n    vector<int> jury_answers;\n    vector<int> contestant_answers;\n\n    // Convert jury's output lines to integers with validation\n    for (const string& line : stdout_lines) {\n        if (line.empty()) {\n            cerr << \"Empty line in stdout.txt\\n\";\n            return false;\n        }\n        try {\n            size_t pos;\n            int num = stoi(line, &pos);\n            if (pos != line.size()) {\n                cerr << \"Trailing characters in stdout.txt line: '\" << line << \"'\\n\";\n                return false;\n            }\n            jury_answers.push_back(num);\n        } catch (...) {\n            cerr << \"Invalid integer in stdout.txt: '\" << line << \"'\\n\";\n            return false;\n        }\n    }\n\n    // Convert contestant's output lines to integers with validation\n    for (const string& line : participant_lines) {\n        if (line.empty()) {\n            cerr << \"Empty line in answer.txt\\n\";\n            return false;\n        }\n        try {\n            size_t pos;\n            int num = stoi(line, &pos);\n            if (pos != line.size()) {\n                cerr << \"Trailing characters in answer.txt line: '\" << line << \"'\\n\";\n                return false;\n            }\n            contestant_answers.push_back(num);\n        } catch (...) {\n            cerr << \"Invalid integer in answer.txt: '\" << line << \"'\\n\";\n            return false;\n        }\n    }\n\n    // Check answer count matches\n    if (contestant_answers.size() != jury_answers.size()) {\n        cerr << \"Wrong number of answers: expected \" << jury_answers.size()\n             << \", found \" << contestant_answers.size() << '\\n';\n        return false;\n    }\n\n    // Check individual answers\n    for (int i = 0; i < (int)jury_answers.size(); i++) {\n        if (contestant_answers[i] != jury_answers[i]) {\n            cerr << \"Answer \" << (i + 1) << \": expected \" << jury_answers[i]\n                 << \", found \" << contestant_answers[i] << '\\n';\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60472, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compares participant's output against expected output line-by-line.\n  Returns true if all lines match (after whitespace trimming), false otherwise.\n  Note: Input file (stdin) content is available but typically unused in standard checkers.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line (already whitespace-stripped by read_file)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60461, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against jury's answer.\n  Correct answer is read from stdout_path (expected output),\n  participant's output is read from answer_path.\n  Returns true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Must have exactly one line in both answer and participant output\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    string jury = stdout_lines[0];\n    string participant = participant_lines[0];\n\n    // Case 1: Jury answer is \"infinity\"\n    if (jury == \"infinity\") {\n        return participant == \"infinity\";\n    } \n    // Case 2: Jury answer is a number\n    else {\n        // Participant must not be \"infinity\" or empty\n        if (participant == \"infinity\" || participant.empty()) {\n            return false;\n        }\n        \n        // Validate all characters are digits\n        for (char c : participant) {\n            if (!isdigit(c)) {\n                return false;\n            }\n        }\n        \n        // Strip leading zeros (except for \"0\" itself)\n        string p = participant;\n        while (p.size() > 1 && p[0] == '0') {\n            p.erase(p.begin());\n        }\n        \n        // Final comparison after normalization\n        return (p == jury);\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60458, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate trophy placement solution by checking:\n  1. All pieces 1..K are used exactly once\n  2. No overlapping cells\n  3. Each piece forms a rectangle of dimensions matching A[k-1]x B[k-1] or vice versa\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse problem input (K, N, A, B)\n    if (stdin_lines.size() < 3) \n        return false;\n\n    // Parse first line: K N\n    istringstream iss(stdin_lines[0]);\n    int K, N;\n    if (!(iss >> K >> N) || K <= 0 || N <= 0) \n        return false;\n\n    // Parse A array (must have exactly K positive integers)\n    vector<int> A(K), B(K);\n    iss = istringstream(stdin_lines[1]);\n    for (int i = 0; i < K; i++) {\n        if (!(iss >> A[i]) || A[i] <= 0) \n            return false;\n    }\n    // Verify no extra data in A line\n    int extra;\n    if (iss >> extra) \n        return false;\n\n    // Parse B array (must have exactly K positive integers)\n    iss = istringstream(stdin_lines[2]);\n    for (int i = 0; i < K; i++) {\n        if (!(iss >> B[i]) || B[i] <= 0) \n            return false;\n    }\n    if (iss >> extra) \n        return false;\n\n    // Parse participant's grid output (must be exactly 3 lines)\n    if (participant_lines.size() != 3) \n        return false;\n\n    vector<vector<int>> grid(3, vector<int>(N));\n    vector<vector<pair<int, int>>> pos(K + 1);  // 1-based indexing\n\n    for (int i = 0; i < 3; i++) {\n        istringstream row_iss(participant_lines[i]);\n        for (int j = 0; j < N; j++) {\n            int id;\n            if (!(row_iss >> id) || id < 1 || id > K) \n                return false;\n            grid[i][j] = id;\n            pos[id].emplace_back(i, j);\n        }\n        // Verify no extra numbers in grid row\n        if (row_iss >> extra) \n            return false;\n    }\n\n    // Track used cells to detect overlaps\n    vector<vector<bool>> used(3, vector<bool>(N, false));\n\n    // Validate each trophy piece\n    for (int k = 1; k <= K; k++) {\n        // Check piece is used\n        if (pos[k].empty()) \n            return false;\n\n        // Check for overlaps and compute bounding box\n        int min_i = 3, max_i = -1;\n        int min_j = N, max_j = -1;\n        \n        for (const auto& [i, j] : pos[k]) {\n            if (used[i][j]) \n                return false;\n            used[i][j] = true;\n            \n            min_i = min(min_i, i);\n            max_i = max(max_i, i);\n            min_j = min(min_j, j);\n            max_j = max(max_j, j);\n        }\n\n        // Verify piece forms a solid rectangle\n        int h = max_i - min_i + 1;\n        int w = max_j - min_j + 1;\n        if (static_cast<int>(pos[k].size()) != h * w) \n            return false;\n\n        // Verify dimensions match required A/B\n        if (!((h == A[k-1] && w == B[k-1]) || \n              (h == B[k-1] && w == A[k-1]))) \n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60464, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the first token from stdout.txt (judge's expected output) \n  and answer.txt (participant's output). Return true if they match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Extract first token from judge's expected output (stdout.txt)\n    string j_token = \"\";\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        size_t start = line.find_first_not_of(' ');\n        if (start != string::npos) {\n            size_t end = line.find(' ', start);\n            j_token = (end == string::npos) ? line.substr(start) : line.substr(start, end - start);\n            break;\n        }\n    }\n\n    // Extract first token from participant's output (answer.txt)\n    string p_token = \"\";\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        size_t start = line.find_first_not_of(' ');\n        if (start != string::npos) {\n            size_t end = line.find(' ', start);\n            p_token = (end == string::npos) ? line.substr(start) : line.substr(start, end - start);\n            break;\n        }\n    }\n\n    // Compare tokens and report mismatch\n    if (j_token != p_token) {\n        cerr << \"Expected: \" << j_token << \", Found: \" << p_token << '\\n';\n        return false;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60462, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing the contestant's output (stdout.txt)\n  with the correct answer (answer.txt). The input file (stdin.txt) is not used\n  in this specific checker but is included for interface consistency.\n  Returns true if values match, false otherwise (with error details on cerr).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path); // Unused in this checker\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Verify both files contain exactly one line\n    if (answer_lines.size() != 1 || stdout_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        ll jury_value = stoll(answer_lines[0]);\n        ll output_value = stoll(stdout_lines[0]);\n\n        if (jury_value != output_value) {\n            cerr << \"Expected: \" << jury_value << \", Found: \" << output_value << '\\n';\n            return false;\n        }\n    } catch (...) {\n        // Handle conversion errors (invalid format or out-of-range values)\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60476, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against correct answer (answer.txt).\n  Returns true if outputs match exactly (after whitespace trimming), false otherwise.\n  Note: stdin.txt content is available but unused in basic comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: check if participant's output matches expected answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60465, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of signed integers from participant's output\n  and correct answer files. Return true if sequences match exactly\n  (same length, same elements in order), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (though stdin is unused for comparison)\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> correct_lines  = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> output_lines   = read_file(answer_path);  // Participant's output (ouf)\n\n    // Helper function to extract all long long tokens from lines\n    auto extract_tokens = [](const vector<string>& lines) -> vector<long long> {\n        vector<long long> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            long long num;\n            while (ss >> num) {\n                tokens.push_back(num);\n            }\n        }\n        return tokens;\n    };\n\n    vector<long long> correct_tokens = extract_tokens(correct_lines);\n    vector<long long> output_tokens  = extract_tokens(output_lines);\n\n    int n = 0;\n    string firstElems;\n\n    // Compare token-by-token until one sequence ends\n    while (n < correct_tokens.size() && n < output_tokens.size()) {\n        if (correct_tokens[n] != output_tokens[n]) {\n            // Format position suffix (1st, 2nd, etc.)\n            auto get_suffix = [](int num) -> string {\n                if (num % 100 >= 11 && num % 100 <= 13) return \"th\";\n                switch (num % 10) {\n                    case 1: return \"st\";\n                    case 2: return \"nd\";\n                    case 3: return \"rd\";\n                    default: return \"th\";\n                }\n            };\n\n            cout << \"wa \" << (n+1) << get_suffix(n+1) \n                 << \" numbers differ - expected: '\" << correct_tokens[n]\n                 << \"', found: '\" << output_tokens[n] << \"'\\n\";\n            return false;\n        }\n        // Collect first 5 elements for OK message\n        if (n < 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(correct_tokens[n]);\n        }\n        n++;\n    }\n\n    int extraInCorrect = correct_tokens.size() - n;\n    int extraInOutput  = output_tokens.size() - n;\n\n    if (extraInCorrect > 0) {\n        cout << \"wa Answer contains longer sequence [length = \" << n + extraInCorrect\n             << \"], but output contains \" << n << \" elements\\n\";\n        return false;\n    }\n    if (extraInOutput > 0) {\n        cout << \"wa Output contains longer sequence [length = \" << n + extraInOutput\n             << \"], but answer contains \" << n << \" elements\\n\";\n        return false;\n    }\n\n    // Successful validation - format OK message\n    if (n <= 5) {\n        cout << \"ok \" << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << \"ok \" << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60470, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the first line of stdout.txt (correct answer) and \n  answer.txt (participant's output). Return true if they match,\n  false otherwise. This replicates the original testlib's \n  string comparison logic for single-line outputs.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if either file is empty or comparison fails\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n    \n    // Compare the first line (trimmed) of both files\n    // This matches testlib's readString() behavior for single-token outputs\n    return stdout_lines[0] == participant_lines[0];\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60467, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from correct answer\n  (stdout_path) and participant's output (answer_path). Returns true\n  if all numbers match and sequences are of same length; otherwise,\n  returns false and prints reason to cerr.\n-----------------------------------------------------------*/\nstring englishEnding(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Tokenize correct answer (stdout_lines)\n    vector<string> correct_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize participant's output (answer_lines)\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    int n = 0;\n    // Compare each token as long long\n    while (n < correct_tokens.size() && n < participant_tokens.size()) {\n        try {\n            ll j = stoll(correct_tokens[n]);\n            ll p = stoll(participant_tokens[n]);\n            if (j != p) {\n                cerr << (n+1) << englishEnding(n+1) \n                     << \" numbers differ - expected: '\" << j \n                     << \"', found: '\" << p << \"'\\n\";\n                return false;\n            }\n        } catch (...) {\n            cerr << \"Token '\" << (n < correct_tokens.size() ? correct_tokens[n] : participant_tokens[n])\n                 << \"' is not a valid integer\\n\";\n            return false;\n        }\n        n++;\n    }\n\n    // Check for extra tokens in correct answer\n    if (correct_tokens.size() > participant_tokens.size()) {\n        cerr << \"Answer contains longer sequence [length = \" << correct_tokens.size()\n             << \"], but output contains \" << participant_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra tokens in participant's output\n    if (participant_tokens.size() > correct_tokens.size()) {\n        cerr << \"Output contains longer sequence [length = \" << participant_tokens.size()\n             << \"], but answer contains \" << correct_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // All tokens match - prepare success message\n    if (n <= 5) {\n        string firstElems;\n        for (int i = 0; i < n; i++) {\n            if (i > 0) firstElems += \" \";\n            firstElems += correct_tokens[i];\n        }\n        cout << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60463, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate that participant's output (answer_path) matches \n  expected answer (stdout_path). Checks:\n  1. Both files contain exactly one valid integer\n  2. Values are equal\n  3. No extra output in participant's file\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected answer (ans)\n    vector<string> answer_lines      = read_file(answer_path);  // Participant's output (ouf)\n\n    // Expected answer must have exactly one non-empty line\n    if (stdout_lines.size() != 1 || stdout_lines[0].empty()) {\n        return false;\n    }\n\n    // Participant must have at least one line\n    if (answer_lines.empty()) {\n        return false;\n    }\n\n    try {\n        ll expected = stoll(stdout_lines[0]);\n        ll participant = stoll(answer_lines[0]);\n\n        // Value mismatch  WA\n        if (expected != participant) {\n            return false;\n        }\n\n        // Extra output in participant's file  PE\n        if (answer_lines.size() > 1) {\n            return false;\n        }\n\n        return true;\n    } catch (...) {\n        // Failed to parse numbers\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60483, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (answer_path) against correct output (stdout_path)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60474, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected \n  output (stdout.txt) line-by-line. Input file (stdin.txt) is \n  available but not used in this basic comparison checker.\n  Returns true if outputs match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each stripped line for exact match\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60419, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected answer (stdout.txt).\n  Input file (stdin.txt) may be used for context if needed.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);  // Expected answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Core comparison logic: Check if participant's output matches expected answer\n    // after trimming whitespace from each line\n    return participant_lines == expected_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60412, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compares participant's output (answer_path) against correct answer (stdout_path).\n  Returns true if all lines match exactly after whitespace trimming, false otherwise.\n  Note: stdin_path (problem input) is available but not used in simple equality check.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation: compare participant's output with jury's answer line-by-line\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60485, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing their output \n  (from answer.txt/ouf) against expected answer (stdout.txt/ans),\n  using input file context (stdin.txt/inf) if needed.\n  Returns true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (expected output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic: Compare participant's output with expected answer line-by-line\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60475, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected output (stdout_path).\n  The input (stdin_path) may be used for additional checks if needed.\n  Return true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch between participant's output and expected output\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison after whitespace normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60481, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's expected output (stdout.txt).\n  Input file (stdin.txt) may provide context for validation if required by problem.\n  Returns true if outputs match exactly line-by-line (after trimming), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count consistency first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform exact line-by-line comparison (whitespace-trimmed)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    // Additional context-specific validation could use stdin_lines here\n    // (e.g., parsing input constraints to verify output validity)\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60411, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against jury's answer (answer.txt).\n  Return true  accept, false  reject.\n  Note: stdin.txt (problem input) may be used for context if needed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path);\n    vector<string> jury_answer_lines = read_file(answer_path);\n\n    // Check if line counts match\n    if (participant_lines.size() != jury_answer_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != jury_answer_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60486, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Compares stripped lines from correct output (stdout.txt) and \n  participant's submission (answer.txt). Returns true only if\n  all lines match exactly after whitespace normalization.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60489, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  by tokenizing both files and checking for exact token-by-token equality.\n  Input file (stdin.txt) is read but typically unused in standard checkers.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert correct answer (stdout) to token sequence\n    vector<string> correct_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Convert participant's output (answer) to token sequence\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Token count must match\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches exactly\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60325, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer.\n  Compares line-by-line after whitespace normalization:\n  - Input: stdin.txt (problem input)\n  - Jury's expected output: stdout.txt\n  - Participant's submission: answer.txt\n  Returns true if outputs match exactly (line count and content).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content (already whitespace-trimmed by read_file)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60471, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-4;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two double values with given precision tolerance.\n  Returns true if values match within absolute or relative error.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double eps) {\n    if (std::isnan(a) || std::isnan(b)) \n        return false;\n    if (std::isinf(a) || std::isinf(b)) \n        return (a == b);\n    double diff = fabs(a - b);\n    if (diff <= eps) \n        return true;\n    double m = max(fabs(a), fabs(b));\n    return (diff / m) <= eps;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing contestant's output against \n  correct answer using double precision comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Check if both output files contain at least one line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse the first line as double values\n    auto parse_double = [](const string& s, double& value) -> bool {\n        stringstream ss(s);\n        ss >> value;\n        return !ss.fail() && ss.eof();\n    };\n\n    double ja, pa;\n    if (!parse_double(stdout_lines[0], ja) || !parse_double(participant_lines[0], pa)) {\n        return false;\n    }\n\n    // Perform precision-sensitive comparison\n    return doubleCompare(ja, pa, EPS);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60492, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected \n  output (stdout.txt) line-by-line. Input file (stdin.txt) \n  is available for context if needed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Check if participant's output matches expected output\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60501, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output by comparing against expected output.\n  Reads stdin.txt for number of queries (q), then verifies that each integer\n  in participant's output (answer.txt) matches corresponding integer in \n  expected output (stdout.txt) for all q queries.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to inf (input)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to ans (expected output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to ouf (participant's output)\n\n    // Extract all tokens from stdin_lines to get query count\n    vector<string> tokens_stdin;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_stdin.push_back(token);\n        }\n    }\n    if (tokens_stdin.empty()) return false;\n    \n    // Parse query count (q)\n    int q;\n    try {\n        q = stoi(tokens_stdin[0]);\n    } catch (...) {\n        return false;\n    }\n    if (q <= 0) return false;\n\n    // Extract tokens from participant's output\n    vector<string> tokens_ouf;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_ouf.push_back(token);\n        }\n    }\n\n    // Extract tokens from expected output\n    vector<string> tokens_ans;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens_ans.push_back(token);\n        }\n    }\n\n    // Verify sufficient tokens exist for all queries\n    if (tokens_ouf.size() < static_cast<size_t>(q) || \n        tokens_ans.size() < static_cast<size_t>(q)) {\n        return false;\n    }\n\n    // Compare each query result\n    for (int i = 0; i < q; ++i) {\n        try {\n            ll participant_val = stoll(tokens_ouf[i]);\n            ll expected_val    = stoll(tokens_ans[i]);\n            if (participant_val != expected_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60482, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt).\n  Performs strict line-by-line comparison after whitespace normalization.\n  Returns true if all lines match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input)\n    vector<string> correct_lines     = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch\n    if (participant_lines.size() != correct_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches after normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != correct_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60469, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Check if the string represents an impossible solution.\n-----------------------------------------------------------*/\nbool isImpossible(const string& s) {\n    return s == \"impossible\";\n}\n\n/*-----------------------------------------------------------\n  Compare two floating-point values within a given epsilon.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double eps) {\n    return fabs(a - b) <= eps;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution against jury's answer.\n  Returns true if solutions match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Problem input (unused in this checker)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Ensure both answer files contain exactly one line\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    string ja = stdout_lines[0];       // Jury's answer\n    string pa = participant_lines[0];   // Participant's output\n    const double EPS = 1e-6;\n\n    // Case 1: Jury says \"impossible\"\n    if (isImpossible(ja)) {\n        return isImpossible(pa);  // Participant must also say \"impossible\"\n    }\n\n    // Case 2: Participant says \"impossible\" but jury has a valid answer\n    if (isImpossible(pa)) {\n        return false;\n    }\n\n    // Case 3: Both have numeric answers - compare with tolerance\n    double jury = atof(ja.c_str());\n    double user = atof(pa.c_str());\n    \n    return doubleCompare(jury, user, EPS);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60423, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  using line-by-line comparison of trimmed content. Input file (stdin.txt)\n  is available for context if needed in more complex validations.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if line counts match\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact content match (after trimming)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60479, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output (stdout.txt)\n  against correct answer (answer.txt), using input data (stdin.txt)\n  for any necessary context. Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> input_lines      = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path);\n    vector<string> jury_answer_lines = read_file(answer_path);\n\n    // Check if line counts match between participant and jury outputs\n    if (participant_lines.size() != jury_answer_lines.size()) {\n        return false;\n    }\n\n    // Compare each line between participant and jury outputs\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        // Skip empty lines in both outputs (if any remain after trimming)\n        if (participant_lines[i].empty() && jury_answer_lines[i].empty()) \n            continue;\n        \n        // Actual content comparison\n        if (participant_lines[i] != jury_answer_lines[i]) {\n            return false;\n        }\n    }\n    \n    // Additional validation could use input_lines here if problem requires\n    // (e.g., checking output validity against input constraints)\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60504, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output against the expected answer.\n  Compares token-by-token after reading all three files:\n  - stdin.txt      : problem input (contains number of queries)\n  - stdout.txt     : expected answers (jury's output)\n  - answer.txt     : participant's output\n  \n  Returns true if all checks pass, false otherwise with error messages.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);\n    vector<string> contestant_lines  = read_file(answer_path);\n\n    // Convert line-based content to token streams\n    vector<string> stdin_tokens;\n    vector<string> expected_tokens;\n    vector<string> contestant_tokens;\n\n    // Tokenize stdin_lines (problem input)\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize expected_lines (jury's expected answers)\n    for (const string& line : expected_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            expected_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize contestant_lines (participant's output)\n    for (const string& line : contestant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            contestant_tokens.push_back(token);\n        }\n    }\n\n    // Check if input file is empty\n    if (stdin_tokens.empty()) {\n        cerr << \"Input file is empty\\n\";\n        return false;\n    }\n\n    // Parse number of queries from first token\n    int q = stoi(stdin_tokens[0]);\n\n    // Verify expected output has sufficient tokens\n    if (static_cast<int>(expected_tokens.size()) < q) {\n        cerr << \"Jury output has fewer than \" << q << \" tokens\\n\";\n        return false;\n    }\n\n    // Verify participant provided sufficient output\n    if (static_cast<int>(contestant_tokens.size()) < q) {\n        cerr << \"Missing output for query \" << q << \"\\n\";\n        return false;\n    }\n\n    // Compare each query's answer\n    for (int i = 0; i < q; i++) {\n        if (expected_tokens[i] != contestant_tokens[i]) {\n            cerr << \"For query \" << (i+1) << \": expected \" \n                 << expected_tokens[i] << \", found \" \n                 << contestant_tokens[i] << \"\\n\";\n            return false;\n        }\n    }\n\n    // Check for extra output beyond required queries\n    if (static_cast<int>(contestant_tokens.size()) > q) {\n        cerr << \"Extra output after \" << q << \" queries\\n\";\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60505, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct output.\n  Input file (stdin.txt) provides 'n', correct output in stdout.txt,\n  participant's output in answer.txt. Returns true if valid.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files were read successfully\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        cerr << \"One or more required files are empty or unreadable\\n\";\n        return false;\n    }\n\n    // Parse n from first line of input\n    int n;\n    try {\n        n = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid value for n in input: \" << stdin_lines[0] << '\\n';\n        return false;\n    }\n\n    // Check output structure: must have exactly n+1 lines (x + n values)\n    if (participant_lines.size() != n + 1 || stdout_lines.size() != n + 1) {\n        return false;\n    }\n\n    // Compare first value (x vs y)\n    int x, y;\n    try {\n        x = stoi(participant_lines[0]);\n        y = stoi(stdout_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (x != y) {\n        return false;\n    }\n\n    // Compare subsequent n values line by line\n    for (int i = 1; i <= n; i++) {\n        int participant_val, correct_val;\n        try {\n            participant_val = stoi(participant_lines[i]);\n            correct_val     = stoi(stdout_lines[i]);\n        } catch (...) {\n            return false;\n        }\n        if (participant_val != correct_val) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60487, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing their output \n  (from answer.txt/ouf) against jury's correct output \n  (from stdout.txt/ans). Input file (stdin.txt/inf) is read \n  but may be unused depending on problem requirements.\n  Returns true if outputs match line-by-line after stripping \n  whitespace, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line (already stripped by read_file)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60508, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer.\n  - Jury's answer is read from answer_path (corresponds to 'ans' in original code)\n  - Participant's output is read from stdout_path (corresponds to 'ouf' in original code)\n  - Input file (stdin_path) is read but unused for this specific checker\n\n  Validation steps:\n  1. Both files must contain exactly one non-empty line\n  2. Each line must contain exactly one integer token\n  3. Values must match numerically\n  4. No extra tokens or whitespace allowed after the answer\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check single-line requirement for both files\n    if (answer_lines.size() != 1 || stdout_lines.size() != 1) {\n        return false;\n    }\n\n    // Process jury's answer (answer.txt)\n    istringstream jury_stream(answer_lines[0]);\n    string jury_token;\n    if (!(jury_stream >> jury_token)) {\n        // Empty answer file\n        return false;\n    }\n    // Verify no trailing content in answer\n    string extra;\n    if (jury_stream >> extra) {\n        return false;\n    }\n\n    // Process participant's output (stdout.txt)\n    istringstream output_stream(stdout_lines[0]);\n    string output_token;\n    if (!(output_stream >> output_token)) {\n        // Empty participant output\n        return false;\n    }\n    // Check for extra content after answer (PE)\n    if (output_stream >> extra) {\n        return false;\n    }\n\n    // Convert and compare numerical values\n    try {\n        ll jury_val = stoll(jury_token);\n        ll output_val = stoll(output_token);\n        return (jury_val == output_val);\n    } catch (...) {\n        // Non-integer content\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60420, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Extract all tokens from vector of lines by splitting on whitespace.\n  Used to simulate testlib's token-based reading for comparison.\n-----------------------------------------------------------*/\nvector<string> extract_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing token sequences against\n  expected output. Input file (stdin) is available for context if\n  needed by problem-specific logic, but this implementation only\n  requires direct token-by-token comparison of output files.\n  Returns true if outputs match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);   // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);   // Participant's output (ouf)\n\n    // Convert both outputs to token sequences for comparison\n    vector<string> expected_tokens = extract_tokens(stdout_lines);\n    vector<string> participant_tokens = extract_tokens(participant_lines);\n\n    // Verify token count and sequence match\n    if (expected_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < expected_tokens.size(); ++i) {\n        if (expected_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60497, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two signed 64-bit integers from the jury's answer file \n  (stdout.txt) and participant's output file (answer.txt). \n  Returns true if equal, false otherwise.\n  \n  Note: \n    - stdout.txt contains jury's expected answer (corresponds to 'ans' in testlib)\n    - answer.txt contains participant's output (corresponds to 'ouf' in testlib)\n    - stdin.txt is read but not used in comparison (corresponds to 'inf' in testlib)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Find first non-empty line in jury's answer\n    string jury_line = \"\";\n    for (const string& line : stdout_lines) {\n        if (!line.empty()) {\n            jury_line = line;\n            break;\n        }\n    }\n    if (jury_line.empty()) return false;\n\n    // Find first non-empty line in participant's output\n    string participant_line = \"\";\n    for (const string& line : participant_lines) {\n        if (!line.empty()) {\n            participant_line = line;\n            break;\n        }\n    }\n    if (participant_line.empty()) return false;\n\n    try {\n        long long ja = stoll(jury_line);\n        long long pa = stoll(participant_line);\n        return (ja == pa);\n    } catch (...) {\n        // Failed to parse as 64-bit integer\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60496, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming trailing space characters only (not tabs or other whitespace).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Trim trailing spaces only (preserve leading spaces and other whitespace)\n        while (!line.empty() && line.back() == ' ') {\n            line.pop_back();\n        }\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing against correct output.\n  Uses first line of stdin to determine number of test cases (t).\n  For each test case, compares corresponding lines after trimming trailing spaces.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if stdin provides valid test case count\n    if (stdin_lines.empty()) {\n        cerr << \"Error: stdin.txt is empty\\n\";\n        return false;\n    }\n\n    // Parse number of test cases from first line of stdin\n    int t;\n    try {\n        size_t pos;\n        t = stoi(stdin_lines[0], &pos);\n        if (pos != stdin_lines[0].length()) {\n            cerr << \"Error: Non-numeric characters in test case count\\n\";\n            return false;\n        }\n    } catch (...) {\n        cerr << \"Error: Failed to parse test case count\\n\";\n        return false;\n    }\n\n    // Validate sufficient line counts in output files\n    if (t < 0) {\n        cerr << \"Error: Negative test case count: \" << t << '\\n';\n        return false;\n    }\n    if (stdout_lines.size() < static_cast<size_t>(t) || \n        participant_lines.size() < static_cast<size_t>(t)) {\n        cerr << \"Error: Insufficient lines in output files. Expected at least \" \n             << t << \" lines\\n\";\n        return false;\n    }\n\n    // Compare each test case line-by-line\n    for (int i = 0; i < t; ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            cerr << \"Mismatch at test case \" << (i+1) << \":\\n\"\n                 << \"Participant: \\\"\" << participant_lines[i] << \"\\\"\\n\"\n                 << \"Correct:     \\\"\" << stdout_lines[i] << \"\\\"\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60500, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output against jury's answer.\n  Both files should contain exactly one integer value.\n  Return true if values match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify both output files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    const string& correct_line = stdout_lines[0];\n    const string& got_line     = participant_lines[0];\n\n    // Parse and validate both lines as single integers\n    size_t pos1, pos2;\n    try {\n        ll jury_val = stoll(correct_line, &pos1);\n        if (pos1 != correct_line.length()) {\n            return false;  // Extra characters after number\n        }\n        \n        ll got_val = stoll(got_line, &pos2);\n        if (pos2 != got_line.length()) {\n            return false;  // Extra characters after number\n        }\n        \n        return (jury_val == got_val);\n    } catch (...) {\n        return false;  // Failed to parse as integer\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60498, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing participant's output against\n  expected answers, using the problem input to determine the number\n  of queries (q) that need verification.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // 1) Parse problem input to get number of queries (q)\n    if (stdin_lines.empty()) {\n        return false;  // Invalid input file\n    }\n\n    istringstream iss(stdin_lines[0]);\n    int n, q;\n    if (!(iss >> n >> q) || q < 0) {\n        return false;  // Failed to parse n/q or invalid q\n    }\n\n    // 2) Verify expected output has at least q lines\n    if (static_cast<int>(stdout_lines.size()) < q) {\n        return false;\n    }\n\n    // 3) Verify participant output has at least q lines\n    if (static_cast<int>(participant_lines.size()) < q) {\n        return false;\n    }\n\n    // 4) Compare each query's answer (exactly q lines)\n    for (int i = 0; i < q; i++) {\n        try {\n            // Parse expected answer (jury)\n            size_t pos_jury;\n            long long jury = stoll(stdout_lines[i], &pos_jury);\n            if (pos_jury != stdout_lines[i].size()) {\n                return false;  // Extra characters in expected answer\n            }\n\n            // Parse participant's answer\n            size_t pos_user;\n            long long user = stoll(participant_lines[i], &pos_user);\n            if (pos_user != participant_lines[i].size()) {\n                return false;  // Extra characters in participant's answer\n            }\n\n            // Verify numerical equality\n            if (user != jury) {\n                return false;\n            }\n        } catch (...) {\n            return false;  // Failed to parse numbers\n        }\n    }\n\n    // 5) Check for extra output lines from participant\n    if (static_cast<int>(participant_lines.size()) > q) {\n        return false;  // Extra lines constitute Presentation Error\n    }\n\n    return true;  // All checks passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60376, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (stdout_lines) against official \n  answer (participant_lines) line by line. Input (stdin_lines) \n  may be used for problem-specific validation if required.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count consistency between output and answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches exactly (after whitespace trimming)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60491, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct \n  answer (stdout.txt) line-by-line. Returns true if all lines \n  match exactly after trimming whitespace, false otherwise.\n  Note: stdin.txt (input test) is read but typically unused \n  in standard output validators.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Early termination if line counts differ\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact match (after trimming)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60507, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer token by token.\n  Extract all integer tokens from both outputs and verify:\n  1. Both contain exactly the same number of tokens\n  2. Each corresponding token has identical integer value\n  Returns true only if both conditions are satisfied.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct answer)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Extract all integer tokens from correct answer\n    vector<int> correct_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        int token;\n        while (ss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Extract all integer tokens from participant's output\n    vector<int> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        int token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Verify both outputs have identical token count\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches in sequence\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60516, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to get ordinal suffix (e.g., \"st\", \"nd\").\n-----------------------------------------------------------*/\nstring englishEnding(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Convert long long to string.\n-----------------------------------------------------------*/\nstring vtos(long long x) {\n    return to_string(x);\n}\n\n/*-----------------------------------------------------------\n  Compress string (placeholder - returns original since input is small).\n-----------------------------------------------------------*/\nstring compress(const string& s) {\n    return s;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers between correct answer\n  (stdout.txt) and participant's output (answer.txt).\n  Return true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin unused for comparison logic)\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines = read_file(stdout_path);  // Correct answer\n    vector<string> ouf_lines = read_file(answer_path);  // Participant's output\n\n    // Extract tokens from correct answer file\n    vector<long long> ans_tokens;\n    for (string line : ans_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                ans_tokens.push_back(stoll(token));\n            } catch (...) {\n                cerr << \"Invalid number in answer file: \" << token << endl;\n                return false;\n            }\n        }\n    }\n\n    // Extract tokens from participant's output file\n    vector<long long> ouf_tokens;\n    for (string line : ouf_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                ouf_tokens.push_back(stoll(token));\n            } catch (...) {\n                cerr << \"Invalid number in output file: \" << token << endl;\n                return false;\n            }\n        }\n    }\n\n    int n = 0;\n    string firstElems = \"\";\n\n    // Compare tokens one-by-one\n    int min_size = min(ans_tokens.size(), ouf_tokens.size());\n    for (int i = 0; i < min_size; i++) {\n        n++;\n        long long j = ans_tokens[i];\n        long long p = ouf_tokens[i];\n        if (j != p) {\n            cerr << n << englishEnding(n) << \" numbers differ - expected: '\" \n                 << vtos(j) << \"', found: '\" << vtos(p) << \"'\" << endl;\n            return false;\n        }\n        if (n <= 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += vtos(j);\n        }\n    }\n\n    int extraInAns = ans_tokens.size() - min_size;\n    int extraInOuf = ouf_tokens.size() - min_size;\n\n    if (extraInAns > 0) {\n        cerr << \"Answer contains longer sequence [length = \" << ans_tokens.size()\n             << \"], but output contains \" << ouf_tokens.size() << \" elements\" << endl;\n        return false;\n    }\n\n    if (extraInOuf > 0) {\n        cerr << \"Output contains longer sequence [length = \" << ouf_tokens.size()\n             << \"], but answer contains \" << ans_tokens.size() << \" elements\" << endl;\n        return false;\n    }\n\n    // Output success message for valid case\n    if (n <= 5) {\n        cerr << n << \" number(s): \\\"\" << compress(firstElems) << \"\\\"\" << endl;\n    } else {\n        cerr << n << \" numbers\" << endl;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60473, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's solution by comparing their output \n  (answer.txt) against the correct output (stdout.txt) \n  line-by-line after stripping whitespace. The input (stdin.txt) \n  is available for additional validation if required.\n  Returns true  solution accepted, false  solution rejected.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if participant's output matches correct output in line count\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content (already stripped by read_file)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60510, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into a vector of long long tokens\n  by splitting each line on whitespace and parsing integers.\n-----------------------------------------------------------*/\nvector<long long> extract_tokens(const vector<string>& lines) {\n    vector<long long> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        long long x;\n        while (ss >> x) {\n            tokens.push_back(x);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare sequences of signed integers in jury's answer \n  (stdout.txt) and contestant's output (answer.txt).\n  Input test (stdin.txt) is unused for this checker.\n  Returns true if sequences are identical (same numbers, \n  same order, same length), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin unused for validation)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert lines to token sequences\n    vector<long long> jury_tokens = extract_tokens(stdout_lines);\n    vector<long long> cont_tokens = extract_tokens(participant_lines);\n\n    // Check common elements\n    size_t min_size = min(jury_tokens.size(), cont_tokens.size());\n    for (size_t i = 0; i < min_size; i++) {\n        if (jury_tokens[i] != cont_tokens[i]) {\n            return false;\n        }\n    }\n\n    // Verify sequences have identical length\n    return (jury_tokens.size() == cont_tokens.size());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60506, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nconst double EPS = 1e-6;\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer using\n  relative error tolerance (EPS = 1e-6). Returns true if valid.\n  Checks:\n    1. Both files contain exactly one valid floating-point number\n    2. No trailing data after the number\n    3. Relative error  EPS (using max(1.0, correct) as denominator)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // participant's output\n    vector<string> answer_lines = read_file(answer_path);  // correct answer\n\n    // Filter out empty lines from answer and output files\n    vector<string> non_empty_ans;\n    for (const auto& line : answer_lines) {\n        if (!line.empty()) non_empty_ans.push_back(line);\n    }\n    vector<string> non_empty_ouf;\n    for (const auto& line : stdout_lines) {\n        if (!line.empty()) non_empty_ouf.push_back(line);\n    }\n\n    // Must have exactly one non-empty line in both files\n    if (non_empty_ans.size() != 1 || non_empty_ouf.size() != 1) {\n        return false;\n    }\n\n    // Helper: Parse double and verify no trailing data\n    auto parseDouble = [](const string& s, double& value) -> bool {\n        stringstream ss(s);\n        ss >> value;\n        if (ss.fail()) return false;  // Failed to parse number\n        ss >> ws;                    // Skip trailing whitespace\n        return ss.eof();             // True only if nothing remains\n    };\n\n    double correct;\n    if (!parseDouble(non_empty_ans[0], correct)) {\n        return false;\n    }\n\n    double given;\n    if (!parseDouble(non_empty_ouf[0], given)) {\n        return false;\n    }\n\n    // Compute relative error with safe denominator\n    double relErr = fabs(given - correct) / max(1.0, correct);\n\n    // Check against tolerance threshold\n    if (relErr > EPS) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60513, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer by comparing tokens\n  up to the length of the correct answer. Return true if all tokens match\n  within the correct answer's length, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> ans_lines = read_file(stdout_path); // Correct answer (ans)\n    vector<string> ouf_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Extract all integer tokens from correct answer\n    vector<int> ans_tokens;\n    for (string& line : ans_lines) {\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            ans_tokens.push_back(num);\n        }\n    }\n\n    // Extract all integer tokens from participant's output\n    vector<int> ouf_tokens;\n    for (string& line : ouf_lines) {\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            ouf_tokens.push_back(num);\n        }\n    }\n\n    // Check if participant provided enough tokens\n    if (ouf_tokens.size() < ans_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token up to correct answer's length\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60502, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a vector of lines into a vector of tokens by splitting \n  each line by whitespace and collecting all tokens.\n-----------------------------------------------------------*/\nvector<string> get_tokens(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against the expected output\n  using the problem's input specification.\n  \n  Steps:\n    1. Parse stdin.txt to get problem parameters (n, k) and array a\n    2. Parse answer.txt to get expected output sequence\n    3. Parse stdout.txt to get contestant's output sequence\n    4. Verify both sequences have same length and identical values\n    5. Validate contestant's values are within [0, n] range\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Convert file contents to token streams\n    vector<string> stdin_tokens  = get_tokens(stdin_lines);\n    vector<string> stdout_tokens = get_tokens(stdout_lines);\n    vector<string> answer_tokens = get_tokens(answer_lines);\n\n    // Parse problem parameters from stdin tokens\n    if (stdin_tokens.size() < 2) return false;\n    int n, k;\n    try {\n        n = stoi(stdin_tokens[0]);\n        k = stoi(stdin_tokens[1]);\n    } catch (...) {\n        return false;  // Invalid integer format\n    }\n    \n    // Validate n constraints (1-20) as per original problem\n    if (n < 1 || n > 20) return false;\n    \n    int N = (1 << n);\n    if (static_cast<int>(stdin_tokens.size()) < 2 + N) return false;\n\n    // Parse array a (size N) from stdin tokens\n    vector<int> a;\n    for (int i = 0; i < N; ++i) {\n        try {\n            int num = stoi(stdin_tokens[2 + i]);\n            // Validate a[i] constraints (1 to N)\n            if (num < 1 || num > N) return false;\n            a.push_back(num);\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Parse expected output sequence from answer tokens\n    vector<int> expected;\n    for (const string& token : answer_tokens) {\n        try {\n            int num = stoi(token);\n            expected.push_back(num);\n        } catch (...) {\n            return false;  // Invalid token in expected output\n        }\n    }\n\n    // Parse and validate contestant's output sequence\n    vector<int> output;\n    for (const string& token : stdout_tokens) {\n        try {\n            int num = stoi(token);\n            // Validate contestant's output is within [0, n] range\n            if (num < 0 || num > n) return false;\n            output.push_back(num);\n        } catch (...) {\n            return false;  // Invalid token in contestant output\n        }\n    }\n\n    // Final comparison: must have same length and identical values\n    if (output.size() != expected.size()) return false;\n    for (size_t i = 0; i < expected.size(); ++i) {\n        if (expected[i] != output[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60468, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst long double eps = 1.005e-6;\nconst long double pi = 2 * acosl(0);\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Normalizes an angle to the range [-pi,pi).\n-----------------------------------------------------------*/\nvoid normalize(long double &alpha) {\n    while (alpha >= pi) alpha -= 2*pi;\n    while (alpha < -pi) alpha += 2*pi;\n}\n\n/*-----------------------------------------------------------\n  Computes the area of the union of some given circular disks using\n  Green's theorem. A good explanation of the method can be found here:\n  https://discuss.codechef.com/t/chefpc-editorial/12282\n-----------------------------------------------------------*/\nlong double union_area(const vector<ll> &x, const vector<ll>& y, const vector<ll> &r) {\n    int n = x.size();\n    // Find which parts of the boundary of circle i are part of the boundary\n    // of the overall figure using an angular sweep.\n    long double res = 0;\n    for (int i = 0; i < n; i++) {\n        int count = 0; // Number of other circles we are currently in.\n        vector<pair<long double, int>> events;\n        // Loop over the other circles and for each of them find\n        // the interval of angles covered by that circle.\n        for (int j = 0; j < n; j++) if (j != i) {\n            long double dist = hypotl(x[j]-x[i], y[j]-y[i]);\n            // If dist is near-integer, round it to the closest integer.\n            // This is safe, as the coordinates are small.\n            if (abs(dist-round(dist)) < 1e-9) dist = round(dist);\n            if (dist >= r[i] + r[j]) continue;\n            if (r[j] + dist <= r[i]) continue;\n            // If circle i is inside circle j, increment the count.\n            if (r[i] + dist <= r[j]) {\n                count++;\n                continue; \n            }\n\n            // Intersection points are at angles alpha-beta and alpha+beta.\n            // Note that beta is always in [0,pi] by definition of acos. In\n            // fact, as the case of touching circles was eliminated above, we\n            // know that beta must be strictly inside this interval.\n            long double alpha = atan2l(y[j]-y[i], x[j]-x[i]);\n            long double num = dist*dist + r[i]*r[i] - r[j]*r[j];\n            long double denom = 2 * dist * r[i];\n            long double beta = acosl(num/denom);\n\n            // Compute the covered interval, and add a +1 event for the start\n            // of the interval and a -1 event for the end of the interval.\n            long double gamma1 = alpha - beta;\n            long double gamma2 = alpha + beta;\n            normalize(gamma1), normalize(gamma2);\n            events.emplace_back(gamma1, 1);\n            events.emplace_back(gamma2, -1);\n\n            // We start the sweep at -pi, and we need to increment the\n            // count when this starting point is inside circle j.\n            if (gamma1 > gamma2) count++;\n        }\n\n        // Add a \"sentinel\" event to cover the final stretch of the boundary\n        // back to the starting point.\n        events.emplace_back(pi, 0);\n\n        // Now go over the event queue in sorted order. Whenever the count\n        // drops to 0, this part of the boundary is also part of the boundary\n        // of the overall shape.\n        sort(all(events));\n        long double alpha = -pi;\n        for (auto [beta, add]: events) {\n            if (count == 0) {\n                complex<long double> c(x[i], y[i]);\n                complex<long double> a = polar((long double) r[i], alpha);\n                complex<long double> b = polar((long double) r[i], beta);\n                // Add the signed area of the circular sector and two\n                // triangles, where for the latter we use complex number\n                // multiplication to compute the relevant cross products.\n                res += 0.5 * (r[i]*r[i]*(beta-alpha) + imag(conj(c+a)*(c+b) - conj(a)*b));\n            }\n            count += add;\n            alpha = beta;\n        }\n    }\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validates the participant's solution by:\n  1. Parsing problem input from stdin_path (n, x, y, h)\n  2. Parsing participant's output from answer_path (r values)\n  3. Computing maximum possible area (rmax) and participant's area\n  4. Checking if error is within acceptable limits (eps)\n  5. Verifying r values are within [1, rmax[i]]\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Unused per problem note\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse problem input (stdin)\n    if (stdin_lines.empty()) return false;\n    int n;\n    try {\n        n = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (n < 0 || (int)stdin_lines.size() - 1 != n) {\n        return false;\n    }\n\n    vector<ll> x(n), y(n), h(n);\n    for (int i = 0; i < n; i++) {\n        stringstream ss(stdin_lines[1 + i]);\n        if (!(ss >> x[i] >> y[i] >> h[i])) {\n            return false;\n        }\n        string extra;\n        if (ss >> extra) return false;  // No extra data allowed\n    }\n\n    // Parse participant's output (answer_path)\n    if ((int)participant_lines.size() != n) {\n        return false;\n    }\n    vector<ll> r(n);\n    for (int i = 0; i < n; i++) {\n        try {\n            r[i] = stoll(participant_lines[i]);\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Compute maximum allowed radius (rmax) for each circle\n    vector<ll> rmax(n);\n    for (int i = 0; i < n; i++) {\n        ll r2max = h[i] * h[i];\n        for (int j = 0; j < n; j++) {\n            if (h[j] <= h[i]) continue;\n            ll dx = x[j] - x[i];\n            ll dy = y[j] - y[i];\n            ll dist_sq = dx*dx + dy*dy;\n            if (dist_sq < r2max) {\n                r2max = dist_sq;\n            }\n        }\n        rmax[i] = sqrt(r2max);\n        // Verify rmax[i] is correctly computed (floor of sqrt)\n        if (rmax[i] * rmax[i] > r2max || (rmax[i] + 1) * (rmax[i] + 1) <= r2max) {\n            return false;\n        }\n    }\n\n    // Validate participant's radii are within [1, rmax[i]]\n    for (int i = 0; i < n; i++) {\n        if (r[i] < 1 || r[i] > rmax[i]) {\n            return false;\n        }\n    }\n\n    // Calculate areas and check error tolerance\n    long double max_area = union_area(x, y, rmax);\n    long double area = union_area(x, y, r);\n    long double error = abs(area - max_area) / max(1.0L, max_area);\n    \n    return (error <= eps);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60477, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer using \n  input data for context if needed. Returns true if correct.\n  \n  Logic:\n  1. Compare line counts between participant's output and jury answer\n  2. Verify each line matches exactly (after whitespace trimming)\n  3. Special handling for problems requiring numeric tolerance\n     (not needed here as problem uses exact string matching)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if line counts match\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line exactly (case-sensitive, whitespace-stripped)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    // Additional input-based validation could happen here\n    // (e.g., check output format constraints using stdin_lines)\n    // For this problem, exact line matching is sufficient\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60518, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output with jury's answer.\n  The stdin.txt contains three integers (n, m, q); stdout.txt contains q integers\n  (jury's expected values), and answer.txt contains q integers (participant's output).\n  Returns true if all q integers match within valid ranges, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files were successfully read\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Tokenize stdin content to extract n, m, q\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize both output files for comparison\n    vector<string> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdout_tokens.push_back(token);\n        }\n    }\n\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Must have at least 3 tokens (n, m, q) in stdin\n    if (stdin_tokens.size() < 3) {\n        return false;\n    }\n\n    // Parse and validate input constraints\n    int n, m, q;\n    try {\n        n = stoi(stdin_tokens[0]);\n        m = stoi(stdin_tokens[1]);\n        q = stoi(stdin_tokens[2]);\n    } catch (...) {\n        return false;  // Non-integer values encountered\n    }\n\n    // Check n, m, q against problem constraints\n    if (n < 1 || n > 500000) return false;\n    if (m < 0 || m > 1000000) return false;\n    if (q < 1 || q > 1000000) return false;\n\n    // Verify both outputs contain sufficient tokens\n    if (stdout_tokens.size() < q || participant_tokens.size() < q) {\n        return false;\n    }\n\n    // Compare each corresponding value in outputs\n    for (int i = 0; i < q; i++) {\n        try {\n            int expected = stoi(stdout_tokens[i]);\n            int actual   = stoi(participant_tokens[i]);\n            if (expected != actual) {\n                return false;  // Mismatch found\n            }\n        } catch (...) {\n            return false;  // Non-integer values in output\n        }\n    }\n\n    return true;  // All values match\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60522, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Checker for test cases with one long long output per line.\n  No prefixes like \"Case n:\". Just plain numbers.\n  - Reads expected output from stdout_path (correct answers)\n  - Reads participant output from answer_path (submission answers)\n  - Validates:\n      1. Same number of output lines\n      2. Each line contains exactly one valid long long\n      3. Values match exactly\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> expected_lines = read_file(stdout_path); // Correct output (ans)\n    vector<string> received_lines = read_file(answer_path); // Participant's output (ouf)\n\n    // Check line count consistency first\n    if (expected_lines.size() != received_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        try {\n            size_t pos1 = 0, pos2 = 0;\n            ll expected = stoll(expected_lines[i], &pos1);\n            ll received = stoll(received_lines[i], &pos2);\n\n            // Verify entire string was consumed during conversion\n            // (no extra characters after number) and values match\n            if (pos1 != expected_lines[i].size() || \n                pos2 != received_lines[i].size() ||\n                expected != received) {\n                return false;\n            }\n        } catch (...) {\n            // Handle conversion errors (invalid format or out-of-range)\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60514, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against the correct output line-by-line.\n  The first line of stdin.txt specifies the number of test cases (t).\n  For each test case, verify that both outputs contain matching \n  long long integers. Returns true only if all t lines match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if stdin has at least one line (for t)\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse t from the first line of stdin with strict range validation\n    int t;\n    try {\n        size_t pos;\n        t = stoi(stdin_lines[0], &pos);\n        // Ensure entire line is consumed and t is within [1, 1000000]\n        if (pos != stdin_lines[0].size() || t < 1 || t > 1000000) {\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n\n    // Verify both output files contain at least t lines\n    if (stdout_lines.size() < t || participant_lines.size() < t) {\n        return false;\n    }\n\n    // Compare each of the t lines for numeric value equality\n    for (int i = 0; i < t; ++i) {\n        try {\n            size_t pos_j, pos_p;\n            long long j = stoll(stdout_lines[i], &pos_j);\n            long long p = stoll(participant_lines[i], &pos_p);\n\n            // Check entire strings were parsed correctly and values match\n            if (pos_j != stdout_lines[i].size() || \n                pos_p != participant_lines[i].size() ||\n                j != p) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60509, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a text file into a vector<string>.\n  Tokens are separated by whitespace (space, tab, newline).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from correct answer\n  (stdout_path) and participant's output (answer_path).\n  Return true if sequences are identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> correct_tokens  = read_file(stdout_path);\n    vector<string> participant_tokens = read_file(answer_path);\n\n    // Check if the sequences have different lengths.\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token as a long long integer.\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        try {\n            long long correct_val = stoll(correct_tokens[i]);\n            long long participant_val = stoll(participant_tokens[i]);\n            if (correct_val != participant_val) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-integer tokens as invalid.\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60520, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer using \n  input constraints. Reads stdin.txt for n/q values, then \n  verifies each query result in answer.txt (participant) \n  matches stdout.txt (correct answer).\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answers\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Validate input file structure\n    if (stdin_lines.empty()) \n        return false;\n    \n    // Parse n and q from first line of input\n    istringstream iss(stdin_lines[0]);\n    int n, q;\n    if (!(iss >> n >> q) || q < 0) \n        return false;\n    \n    // Check line counts match query count\n    if (stdout_lines.size() != (size_t)q || \n        participant_lines.size() != (size_t)q) \n        return false;\n\n    // Verify each query result\n    for (int i = 0; i < q; i++) {\n        try {\n            int participant_ans = stoi(participant_lines[i]);\n            int correct_ans     = stoi(stdout_lines[i]);\n            \n            if (participant_ans != correct_ans) \n                return false;\n        } catch (...) {\n            return false;  // Non-integer values or conversion errors\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60517, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst string YES = \"YES\";\nconst string NO = \"NO\";\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to uppercase for case-insensitive comparison.\n-----------------------------------------------------------*/\nstring toUpperCase(const string& s) {\n    string result = s;\n    for (char& c : result) {\n        c = toupper(static_cast<unsigned char>(c));\n    }\n    return result;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing tokens from expected answer\n  (stdout.txt) and participant output (answer.txt). Checks:\n  - All tokens must be \"YES\" or \"NO\" (case-insensitive)\n  - Participant tokens must match expected tokens\n  - Both files must have same number of tokens\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to inf (input)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to ans (expected answer)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to ouf (participant output)\n\n    // Split expected answer (stdout_lines) into tokens\n    vector<string> expectedTokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            expectedTokens.push_back(token);\n        }\n    }\n\n    // Split participant output (participant_lines) into tokens\n    vector<string> participantTokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participantTokens.push_back(token);\n        }\n    }\n\n    // Process tokens sequentially\n    int index = 0;\n    int yesCount = 0;\n    int noCount = 0;\n    string pa;\n\n    // Process tokens while both streams have content\n    while (index < expectedTokens.size() && index < participantTokens.size()) {\n        string ja = toUpperCase(expectedTokens[index]);\n        pa = toUpperCase(participantTokens[index]);\n\n        // Validate expected token is YES/NO\n        if (ja != YES && ja != NO) {\n            return false;\n        }\n\n        // Count participant's valid tokens\n        if (pa == YES) {\n            yesCount++;\n        } else if (pa == NO) {\n            noCount++;\n        } else {\n            return false;  // Invalid token in participant output\n        }\n\n        // Verify token matches expected\n        if (ja != pa) {\n            return false;\n        }\n\n        index++;\n    }\n\n    // Check for extra tokens in expected answer\n    if (expectedTokens.size() > index) {\n        return false;\n    }\n\n    // Check for extra tokens in participant output\n    if (participantTokens.size() > index) {\n        return false;\n    }\n\n    // All validations passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60494, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  using input (stdin.txt) if needed. Returns true for accepted, false for wrong answer.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input file)\n    vector<string> correct_lines     = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Core comparison logic - line-by-line exact match after whitespace stripping\n    if (participant_lines.size() != correct_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (participant_lines[i] != correct_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60530, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's solution by comparing against the\n  expected output. Processes T test cases with specific input\n  structure: n points followed by nn cost matrix. Checks all\n  input values are within constraints before comparing results.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify all files have content\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    int current_line = 0;\n    // Read number of test cases (T)\n    if (current_line >= stdin_lines.size()) return false;\n    int T = 0;\n    try {\n        T = stoi(stdin_lines[current_line++]);\n    } catch (...) {\n        return false;\n    }\n    if (T < 1 || T > 70) return false;\n\n    for (int tc = 1; tc <= T; tc++) {\n        // Read n (number of points)\n        if (current_line >= stdin_lines.size()) return false;\n        int n = 0;\n        try {\n            n = stoi(stdin_lines[current_line++]);\n        } catch (...) {\n            return false;\n        }\n        if (n < 3 || n > 18) return false;\n\n        // Process n points (x, y coordinates)\n        for (int i = 0; i < n; i++) {\n            if (current_line >= stdin_lines.size()) return false;\n            string line = stdin_lines[current_line++];\n            stringstream ss(line);\n            string token;\n            vector<string> tokens;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n            if (tokens.size() != 2) return false;\n            try {\n                ll x = stoll(tokens[0]);\n                ll y = stoll(tokens[1]);\n                if (x < 0 || x > 1000000 || y < 0 || y > 1000000) {\n                    return false;\n                }\n            } catch (...) {\n                return false;\n            }\n        }\n\n        // Process nn cost matrix\n        for (int i = 0; i < n; i++) {\n            if (current_line >= stdin_lines.size()) return false;\n            string line = stdin_lines[current_line++];\n            stringstream ss(line);\n            string token;\n            vector<string> tokens;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n            if (tokens.size() != n) return false;\n            for (const string& t : tokens) {\n                try {\n                    ll w = stoll(t);\n                    if (w < 0 || w > 1000000) {\n                        return false;\n                    }\n                } catch (...) {\n                    return false;\n                }\n            }\n        }\n\n        // Read expected cost and count from stdout (jury's answer)\n        int ans_idx = 2 * (tc - 1);\n        if (ans_idx + 1 >= stdout_lines.size()) return false;\n        ll expCost, expCount;\n        try {\n            expCost  = stoll(stdout_lines[ans_idx]);\n            expCount = stoll(stdout_lines[ans_idx + 1]);\n        } catch (...) {\n            return false;\n        }\n\n        // Read contestant's cost and count from answer file\n        int ouf_idx = 2 * (tc - 1);\n        if (ouf_idx + 1 >= participant_lines.size()) return false;\n        ll userCost, userCount;\n        try {\n            userCost  = stoll(participant_lines[ouf_idx]);\n            userCount = stoll(participant_lines[ouf_idx + 1]);\n        } catch (...) {\n            return false;\n        }\n\n        // Verify results match expected values\n        if (userCost != expCost) {\n            return false;\n        }\n        if (userCount != expCount) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60523, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare correct answer (stdout_path) and participant's output (answer_path)\n  line-by-line. Each line is split into words (ignoring whitespace differences),\n  and sequences of words are verified for equality. Also checks line count.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);  // Unused (input)\n    vector<string> ans_lines         = read_file(stdout_path); // Correct answer\n    vector<string> participant_lines = read_file(answer_path); // Participant's output\n\n    // Line count must match\n    if (ans_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line's word sequence\n    for (size_t i = 0; i < ans_lines.size(); i++) {\n        if (!compareWords(ans_lines[i], participant_lines[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*-----------------------------------------------------------\n  Split both strings into word sequences (by whitespace) and\n  compare the resulting vectors. Used for line-normalized comparison.\n-----------------------------------------------------------*/\nbool compareWords(const string& a, const string& b) {\n    vector<string> va, vb;\n    stringstream sa(a);\n    string cur;\n\n    while (sa >> cur) {\n        va.push_back(cur);\n    }\n\n    stringstream sb(b);\n    while (sb >> cur) {\n        vb.push_back(cur);\n    }\n\n    return (va == vb);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60484, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare expected output (stdout_lines = ans) with participant's output (participant_lines = ouf)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60542, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare judge's output (stdout.txt) and contestant's output (answer.txt)\n  by reading a single integer from each file. Returns true if they match.\n  Handles cases with invalid format or multiple lines as validation failure.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check both files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Parse integers from trimmed lines\n        int ja = stoi(stdout_lines[0]);\n        int pa = stoi(participant_lines[0]);\n        return ja == pa;\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60551, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n// Helper function to split lines into tokens for stream-like processing\nvector<string> tokenize(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate contestant's output against correct answer using \n  problem's input. Compares:\n    1. Main answer (ck_ouf vs ck_ans)\n    2. Additional sequence values when ck_ans != -1\n  Returns true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files: stdin  problem input, stdout  correct answer, answer  contestant output\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> ans_lines    = read_file(stdout_path);\n    vector<string> ouf_lines    = read_file(answer_path);\n\n    // Convert all lines into token streams for sequential processing\n    vector<string> stdin_tokens = tokenize(stdin_lines);\n    vector<string> ans_tokens   = tokenize(ans_lines);\n    vector<string> ouf_tokens   = tokenize(ouf_lines);\n\n    int s_idx = 0; // Current token index for stdin (problem input)\n    int a_idx = 0; // Current token index for ans (correct answer)\n    int o_idx = 0; // Current token index for ouf (contestant output)\n\n    // Helper to parse next integer from token stream\n    auto readInt = [](vector<string>& tokens, int& idx) -> int {\n        return stoi(tokens[idx++]);\n    };\n\n    // Read number of test cases from problem input\n    int T = readInt(stdin_tokens, s_idx);\n\n    while (T--) {\n        // Read problem parameters (n, k) from input\n        int n = readInt(stdin_tokens, s_idx);\n        int k = readInt(stdin_tokens, s_idx);\n\n        // Skip n integers from problem input (ignored in validation)\n        for (int i = 0; i < n; i++) {\n            readInt(stdin_tokens, s_idx);\n        }\n\n        // Compare main answer values\n        int ck_ouf = readInt(ouf_tokens, o_idx);\n        int ck_ans = readInt(ans_tokens, a_idx);\n        if (ck_ouf != ck_ans) {\n            return false;\n        }\n\n        // Verify additional sequence values when answer is valid\n        if (ck_ans != -1) {\n            for (int i = 0; i < n - 1; i++) {\n                int expected = readInt(ans_tokens, a_idx);\n                int actual   = readInt(ouf_tokens, o_idx);\n                if (actual != expected) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60531, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper to split lines into individual tokens (whitespace-separated)\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing stdout.txt against\n  the expected behavior computed from stdin.txt.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    // Note: answer_path is unused here since expected output is computed from input\n\n    auto stdin_tokens  = tokenize(stdin_lines);\n    auto stdout_tokens = tokenize(stdout_lines);\n    int idx_stdin = 0;\n    int idx_stdout = 0;\n\n    // Check if we have enough tokens for T\n    if (stdin_tokens.empty()) return false;\n    int T = stoi(stdin_tokens[idx_stdin++]);\n\n    const int MAXN = 100000 + 5;\n    vector<int> fa(MAXN), fb(MAXN), fc(MAXN);\n    vector<vector<int>> A(MAXN), B(MAXN), C(MAXN);\n    vector<int> siz(MAXN, 0);\n    vector<unsigned long long> fval(MAXN, 0);\n    map<unsigned long long, int> cnt;\n\n    // Hash function H as defined in original code\n    auto H = [](unsigned long long x) -> unsigned long long {\n        auto _ = [](unsigned long long z) -> unsigned long long {\n            return z*z*z + z*z*5 + 9*z + 8;\n        };\n        return _(x >> 32) + _(x & (unsigned)(-1u));\n    };\n\n    // DFS1: Process tree C to compute sizes and hash values\n    function<void(int)> dfs1;\n    dfs1 = [&](int u) {\n        siz[u] = 1;\n        fval[u] = 0;\n        for (int v : C[u]) {\n            dfs1(v);\n            siz[u] += siz[v];\n        }\n        // Sort children by size for hashing consistency\n        sort(C[u].begin(), C[u].end(), [&](int x, int y) {\n            return siz[x] < siz[y];\n        });\n        cnt[fval[u]]++;\n        for (int v : C[u]) {\n            fval[u] += H(fval[v]);\n            cnt[fval[u]]++;\n        }\n    };\n\n    // DFS2: Compute hash for tree A with initial value w\n    function<unsigned long long(int, unsigned long long)> dfs2;\n    dfs2 = [&](int u, unsigned long long w) -> unsigned long long {\n        unsigned long long z = w;\n        for (int v : A[u]) {\n            z += H(dfs2(v, w));\n        }\n        return z;\n    };\n\n    // DFS3: Compute hash for tree B with initial value w\n    function<unsigned long long(int, unsigned long long)> dfs3;\n    dfs3 = [&](int u, unsigned long long w) -> unsigned long long {\n        unsigned long long z = w;\n        for (int v : B[u]) {\n            z += H(dfs3(v, w));\n        }\n        return z;\n    };\n\n    // Process each test case\n    for (int t = 0; t < T; ++t) {\n        if (idx_stdin + 3 > stdin_tokens.size()) \n            return false;  // Missing na, nb, nc\n\n        int na = stoi(stdin_tokens[idx_stdin++]);\n        int nb = stoi(stdin_tokens[idx_stdin++]);\n        int nc = stoi(stdin_tokens[idx_stdin++]);\n\n        // Clear data structures for current test case\n        for (int i = 0; i <= na; ++i) A[i].clear();\n        for (int i = 0; i <= nb; ++i) B[i].clear();\n        for (int i = 0; i <= nc; ++i) C[i].clear();\n\n        // Read tree A (fa)\n        for (int i = 1; i <= na; ++i) {\n            if (idx_stdin >= stdin_tokens.size()) return false;\n            fa[i] = stoi(stdin_tokens[idx_stdin++]);\n            A[fa[i]].push_back(i);\n        }\n        // Read tree B (fb)\n        for (int i = 1; i <= nb; ++i) {\n            if (idx_stdin >= stdin_tokens.size()) return false;\n            fb[i] = stoi(stdin_tokens[idx_stdin++]);\n            B[fb[i]].push_back(i);\n        }\n        // Read tree C (fc)\n        for (int i = 1; i <= nc; ++i) {\n            if (idx_stdin >= stdin_tokens.size()) return false;\n            fc[i] = stoi(stdin_tokens[idx_stdin++]);\n            C[fc[i]].push_back(i);\n        }\n\n        // Compute hash counts for tree C\n        cnt.clear();\n        if (!C[0].empty()) {\n            dfs1(C[0][0]);  // Root is first child of dummy node 0\n        }\n\n        // Build hash maps for trees A and B\n        map<unsigned long long, unsigned long long> ha, hb;\n        for (const auto& it : cnt) {\n            unsigned long long hv = it.first;\n            int w = it.second;\n            if (w >= na - 1) ha[dfs2(A[0][0], hv)] = hv;\n            if (w >= nb - 1) hb[dfs3(B[0][0], hv)] = hv;\n        }\n\n        // Check if solution exists\n        bool possible = false;\n        int ex = -1, ey = -1;\n        int ex_size = 0, ey_size = 0;\n        for (const auto& it : ha) {\n            unsigned long long need = fval[C[0][0]] - it.first;\n            if (hb.find(need) != hb.end()) {\n                unsigned long long tx = it.second, ty = hb[need];\n                for (int i = 1; i <= nc; ++i) {\n                    if (fval[i] == tx) ex = i;\n                    if (fval[i] == ty) ey = i;\n                }\n                if (ex != -1 && ey != -1) {\n                    ex_size = siz[ex];\n                    ey_size = siz[ey];\n                    possible = true;\n                    break;\n                }\n            }\n        }\n\n        // Validate participant's output\n        if (idx_stdout >= stdout_tokens.size()) return false;\n        string tok = stdout_tokens[idx_stdout++];\n\n        if (possible) {\n            if (tok == \"Impossible\") return false;\n            if (idx_stdout + 1 >= stdout_tokens.size()) return false;\n            \n            int sx = 0, sy = 0;\n            try {\n                sx = stoi(tok);\n                sy = stoi(stdout_tokens[idx_stdout++]);\n            } catch (...) { \n                return false; \n            }\n            \n            bool ok = (sx == ex_size && sy == ey_size) || \n                      (sx == ey_size && sy == ex_size);\n            if (!ok) return false;\n            \n            int total = sx + sy;\n            if (idx_stdout + total > stdout_tokens.size()) return false;\n            idx_stdout += total;\n        } else {\n            if (tok != \"Impossible\") return false;\n        }\n    }\n\n    // All test cases passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60524, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers between correct \n  answer (from stdout.txt) and participant's output (from answer.txt).\n  Returns true if sequences match exactly (same numbers in order), \n  false otherwise (mismatched numbers or different lengths).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines   = read_file(stdin_path);\n    vector<string> correct_lines = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> output_lines  = read_file(answer_path);  // Participant's output (ouf)\n\n    // If either file reading failed, consider it invalid\n    if (correct_lines.empty() || output_lines.empty()) {\n        return false;\n    }\n\n    // Compare corresponding elements in both sequences\n    size_t min_size = min(correct_lines.size(), output_lines.size());\n    for (size_t i = 0; i < min_size; ++i) {\n        try {\n            ll correct_num = stoll(correct_lines[i]);\n            ll output_num  = stoll(output_lines[i]);\n            \n            if (correct_num != output_num) {\n                return false;  // Mismatched numbers\n            }\n        } catch (...) {\n            return false;  // Invalid number format\n        }\n    }\n\n    // Verify both sequences have identical lengths\n    return (correct_lines.size() == output_lines.size());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60555, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper: Convert lines into tokens by splitting on whitespace\n-----------------------------------------------------------*/\nvector<string> extract_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Helper: Get English ordinal suffix (1st, 2nd, 3rd, 4th, etc.)\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    // Handle special cases for 11-13\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    \n    // Regular cases based on last digit\n    switch (n % 10) {\n        case 1:  return \"st\";\n        case 2:  return \"nd\";\n        case 3:  return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Helper: Compress long strings (simplified for this context)\n  Since we only show first 5 numbers, no actual compression needed\n-----------------------------------------------------------*/\nstring compress(const string& s)\n{\n    return s; // No compression needed for small token counts\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing tokens from correct answer \n  (stdout.txt) and participant output (answer.txt)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant output (ouf)\n\n    // Convert lines to tokens for comparison\n    vector<string> correct_tokens = extract_tokens(stdout_lines);\n    vector<string> participant_tokens = extract_tokens(participant_lines);\n\n    int n = 0;\n    string firstElems;\n\n    // Compare tokens until one sequence ends\n    while (n < (int)correct_tokens.size() && n < (int)participant_tokens.size()) {\n        try {\n            long long j = stoll(correct_tokens[n]);\n            long long p = stoll(participant_tokens[n]);\n            \n            if (j != p) {\n                cerr << n+1 << englishEnding(n+1) << \" numbers differ - expected: '\" \n                     << j << \"', found: '\" << p << \"'\\n\";\n                return false;\n            }\n            \n            if (n + 1 <= 5) {\n                if (!firstElems.empty()) firstElems += \" \";\n                firstElems += to_string(j);\n            }\n        } catch (...) {\n            cerr << \"Token conversion error at position \" << n+1 << \"\\n\";\n            return false;\n        }\n        n++;\n    }\n\n    // Check for extra tokens in correct answer\n    if ((int)correct_tokens.size() > n) {\n        int extra = (int)correct_tokens.size() - n;\n        cerr << \"Answer contains longer sequence [length = \" << correct_tokens.size() \n             << \"], but output contains \" << n << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra tokens in participant output\n    if ((int)participant_tokens.size() > n) {\n        int extra = (int)participant_tokens.size() - n;\n        cerr << \"Output contains longer sequence [length = \" << participant_tokens.size() \n             << \"], but answer contains \" << n << \" elements\\n\";\n        return false;\n    }\n\n    // Output success message\n    if (n <= 5) {\n        cout << n << \" number(s): \\\"\" << compress(firstElems) << \"\\\"\\n\";\n    } else {\n        cout << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60534, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert lines of text into a flat list of tokens by splitting\n  on whitespace (similar to testlib's tokenization behavior).\n-----------------------------------------------------------*/\nvector<string> tokenize_lines(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected output by:\n  1. Converting both outputs into token sequences\n  2. Checking token count equality\n  3. Verifying each token matches exactly\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin unused for validation)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Convert expected and participant outputs to token streams\n    vector<string> expected_tokens = tokenize_lines(stdout_lines);\n    vector<string> participant_tokens = tokenize_lines(participant_lines);\n\n    // Check if token counts differ (equivalent to !ans.seekEof() || !ouf.seekEof())\n    if (expected_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token sequentially\n    for (size_t i = 0; i < expected_tokens.size(); i++) {\n        if (expected_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60490, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against correct answer (participant_lines).\n  Returns true if all lines match exactly after trimming, false otherwise.\n  Note: stdin_lines is unused in basic checkers but kept for potential extensions.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Participant's output\n    vector<string> participant_lines = read_file(answer_path);  // Correct answer\n\n    // Check line count mismatch first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact content match (after trimming)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60540, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare expected output (ans) from stdout.txt with\n  participant's output (ouf) from answer.txt.\n  - First, parse all integer tokens from both files\n  - Check if token counts match\n  - Verify each corresponding integer matches\n  Return true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Note: stdin_path (inf) is unused in this checker but required by template\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // ans (expected output)\n    vector<string> participant_lines = read_file(answer_path);  // ouf (participant's output)\n\n    // Parse integer tokens from expected output (stdout_lines)\n    vector<int> expected_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            expected_tokens.push_back(num);\n        }\n    }\n\n    // Parse integer tokens from participant's output (participant_lines)\n    vector<int> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        int num;\n        while (ss >> num) {\n            participant_tokens.push_back(num);\n        }\n    }\n\n    // Check token count mismatch (both missing and extra tokens)\n    if (expected_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each corresponding integer token\n    for (size_t i = 0; i < expected_tokens.size(); ++i) {\n        if (expected_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60526, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer by:\n  1. Reading input test data (stdin) to get number of test cases\n  2. Comparing each participant's output value with expected answer\n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input test data (inf)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Correct answers (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Check if any file reading failed\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from first line of input\n    ll t;\n    try {\n        t = stoll(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Validate test case count matches expected\n    if (t < 0 || stdout_lines.size() != t || participant_lines.size() != t) {\n        return false;\n    }\n\n    // Compare each test case value\n    for (ll i = 0; i < t; ++i) {\n        try {\n            ll correct = stoll(stdout_lines[i]);     // Expected value from jury\n            ll output  = stoll(participant_lines[i]);// Participant's output value\n\n            if (correct != output) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60553, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to compare two doubles with given precision.\n  Returns true if absolute error <= EPS or relative error <= EPS.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double eps) {\n    if (std::isnan(a) || std::isnan(b))\n        return false;\n    if (std::isinf(a) || std::isinf(b))\n        return (a == b);\n    double diff = fabs(a - b);\n    double maxVal = fmax(fabs(a), fabs(b));\n    return diff <= eps || diff <= eps * maxVal;\n}\n\n/*-----------------------------------------------------------\n  Helper function to compute absolute difference between two doubles.\n-----------------------------------------------------------*/\ndouble doubleDelta(double a, double b) {\n    return fabs(a - b);\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against jury's output (stdout_path),\n  ensuring each corresponding double matches within EPS tolerance.\n  Returns true if all numbers match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if both output files have same number of lines\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            double jury_val = stod(stdout_lines[i]);\n            double part_val = stod(participant_lines[i]);\n\n            if (!doubleCompare(jury_val, part_val, EPS)) {\n                return false;\n            }\n        } catch (...) {\n            // Handle conversion errors (non-numeric lines)\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60525, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  DSU (Disjoint Set Union) data structure helper functions.\n  Maintains parent, size, and permutation tracking arrays.\n-----------------------------------------------------------*/\nconst int N = 1e5 + 5;\nint perm[N], sz[N], par[N];\n\nint find_par(int u) {\n    if (u == par[u]) return u;\n    return par[u] = find_par(par[u]);\n}\n\nvoid union_sets(int u, int v) {\n    u = find_par(u);\n    v = find_par(v);\n    if (u == v) return;\n    if (sz[u] < sz[v]) swap(u, v);\n    sz[u] += sz[v];\n    sz[v] = 0;\n    par[v] = u;\n}\n\nbool is_connected(int u, int v) { return (find_par(u) == find_par(v)); }\n\n/*-----------------------------------------------------------\n  Main validation logic for graph generation problem.\n  Compares participant's output against jury's answer using \n  input constraints and graph connectivity rules.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines = read_file(stdin_path);    // Corresponds to original 'inf' (input test data)\n    vector<string> ans_lines = read_file(stdout_path);   // Corresponds to original 'ans' (correct answer)\n    vector<string> ouf_lines = read_file(answer_path);   // Corresponds to original 'ouf' (participant's output)\n\n    // Tokenize all input streams (split lines into whitespace-separated tokens)\n    auto tokenize = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    vector<string> inf_tokens = tokenize(inf_lines);\n    vector<string> ans_tokens = tokenize(ans_lines);\n    vector<string> ouf_tokens = tokenize(ouf_lines);\n\n    int inf_idx = 0, ans_idx = 0, ouf_idx = 0;\n\n    // Helper to safely retrieve next token with bounds checking\n    auto next_token = [&](vector<string>& tokens, int& idx) -> string {\n        if (idx >= tokens.size()) {\n            return \"\";\n        }\n        return tokens[idx++];\n    };\n\n    // Convert string token to integer with basic error handling\n    auto to_int = [](const string& s) -> int {\n        try {\n            return stoi(s);\n        } catch (...) {\n            return INT_MAX;\n        }\n    };\n\n    // Read number of test cases from input\n    if (inf_idx >= inf_tokens.size()) return false;\n    int t = to_int(next_token(inf_tokens, inf_idx));\n    if (t < 0) return false;\n\n    for (int test = 0; test < t; test++) {\n        // Read graph parameters (n nodes, m edges)\n        if (inf_idx + 1 >= inf_tokens.size()) return false;\n        int n = to_int(next_token(inf_tokens, inf_idx));\n        int m = to_int(next_token(inf_tokens, inf_idx));\n        if (n < 1 || m < 0) return false;\n\n        // Initialize DSU structures for current test case\n        for (int i = 1; i <= n; i++) {\n            perm[i] = 0;\n            sz[i] = 1;\n            par[i] = i;\n        }\n\n        // Store input edges in normalized form (min, max)\n        map<pair<int, int>, int> edges;\n        for (int i = 0; i < m; i++) {\n            if (inf_idx + 1 >= inf_tokens.size()) return false;\n            int u = to_int(next_token(inf_tokens, inf_idx));\n            int v = to_int(next_token(inf_tokens, inf_idx));\n            if (u < 1 || u > n || v < 1 || v > n) return false;\n            edges[{min(u, v), max(u, v)}] = 1;\n        }\n\n        // Read jury's answer (ja) and participant's output (pa)\n        if (ans_idx >= ans_tokens.size() || ouf_idx >= ouf_tokens.size()) return false;\n        string ja = next_token(ans_tokens, ans_idx);\n        string pa = next_token(ouf_tokens, ouf_idx);\n\n        // Standardize to uppercase for comparison\n        transform(ja.begin(), ja.end(), ja.begin(), ::toupper);\n        transform(pa.begin(), pa.end(), pa.begin(), ::toupper);\n\n        // Validate format of participant's output\n        if (pa != \"YES\" && pa != \"NO\") {\n            return false;\n        }\n        // Validate format of jury's answer\n        if (ja != \"YES\" && ja != \"NO\") {\n            return false;\n        }\n        // Check answer consistency\n        if (ja != pa) {\n            return false;\n        }\n\n        if (ja == \"YES\") {\n            // Verify participant's graph construction matches requirements\n            for (int i = 0; i < n; i++) {\n                if (ans_idx + 1 >= ans_tokens.size()) return false;\n                int q = to_int(next_token(ans_tokens, ans_idx));\n                int s = to_int(next_token(ans_tokens, ans_idx));\n                if (q < 1 || q > n || s < 0 || s > n) {\n                    return false;\n                }\n                for (int j = 0; j < s; j++) {\n                    if (ans_idx >= ans_tokens.size()) return false;\n                    int node = to_int(next_token(ans_tokens, ans_idx));\n                    if (node < 1 || node > n) {\n                        return false;\n                    }\n                }\n            }\n\n            // Process and validate participant's output structure\n            for (int i = 0; i < n; i++) {\n                if (ouf_idx + 1 >= ouf_tokens.size()) return false;\n                int q = to_int(next_token(ouf_tokens, ouf_idx));\n                int s = to_int(next_token(ouf_tokens, ouf_idx));\n                if (q < 1 || q > n || s < 0 || s > n) {\n                    return false;\n                }\n                if (perm[q]) {\n                    return false;  // q must form a permutation\n                }\n                perm[q] = 1;\n                map<int, int> components;\n                vector<int> nodes;\n                for (int j = 0; j < s; j++) {\n                    if (ouf_idx >= ouf_tokens.size()) return false;\n                    int node = to_int(next_token(ouf_tokens, ouf_idx));\n                    if (node < 1 || node > n) {\n                        return false;\n                    }\n                    nodes.push_back(node);\n                    int component = find_par(node);\n                    if (components[component]) {\n                        return false;  // No two nodes from same component allowed\n                    }\n                    components[component] = 1;\n                }\n                for (int node : nodes) {\n                    union_sets(node, q);\n                    pair<int, int> edge = {min(node, q), max(node, q)};\n                    if (edges.find(edge) == edges.end() || edges[edge] == 0) {\n                        return false;  // Edge must exist in input graph\n                    }\n                    edges[edge] = 1;  // Mark edge as used\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60529, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Check if a string represents a valid signed integer without leading zeros\n  (except for \"0\" itself). Matches pattern: \"0\" or \"-?[1-9][0-9]*\".\n-----------------------------------------------------------*/\nbool isNumeric(const string& s) {\n    static const regex pattern(\"^(0$|-?[1-9][0-9]*)$\");\n    return regex_match(s, pattern);\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output against jury's answer.\n  stdin.txt contains input (with 't' test cases), stdout.txt contains jury's\n  correct answers, and answer.txt contains participant's output. Each test case\n  expects an integer result; they must match exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);     // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);    // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);    // Corresponds to 'ouf' (participant's output)\n\n    // Verify stdin isn't empty\n    if (stdin_lines.empty()) {\n        cerr << \"Error: \" << stdin_path << \" is empty\\n\";\n        return false;\n    }\n\n    // Parse number of test cases (t) from first line of stdin\n    const string& t_str = stdin_lines[0];\n    if (!isNumeric(t_str)) {\n        cerr << \"Invalid test case count: '\" << t_str << \"'\\n\";\n        return false;\n    }\n    int t = stoi(t_str);\n    if (t < 1 || t > 10000) {\n        cerr << \"Test case count out of range [1, 10000]: \" << t << \"\\n\";\n        return false;\n    }\n\n    // Verify sufficient lines in output files\n    if (stdout_lines.size() < t || participant_lines.size() < t) {\n        cerr << \"Output files missing lines. Expected \" << t << \" test cases.\\n\";\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < t; ++i) {\n        const string& ja_str = stdout_lines[i];      // Jury's answer (correct)\n        const string& pa_str = participant_lines[i];  // Participant's output\n\n        // Validate numeric format\n        if (!isNumeric(ja_str) || !isNumeric(pa_str)) {\n            cerr << \"Non-numeric value in test #\" << (i+1) << \":\\n\";\n            cerr << \"  Jury: '\" << ja_str << \"'\\n\";\n            cerr << \"  You : '\" << pa_str << \"'\\n\";\n            return false;\n        }\n\n        // Convert and compare values\n        try {\n            int ja = stoi(ja_str);\n            int pa = stoi(pa_str);\n            if (ja != pa) {\n                cerr << \"Test case \" << (i+1) << \" failed:\\n\";\n                cerr << \"  Expected: \" << ja << \"\\n\";\n                cerr << \"  Found:    \" << pa << \"\\n\";\n                return false;\n            }\n        } catch (...) {\n            cerr << \"Conversion error in test case \" << (i+1) << \"\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Corresponds to 'inf' (input)\n    const string stdout_path = \"stdout.txt\";  // Corresponds to 'ans' (correct output)\n    const string answer_path = \"answer.txt\";  // Corresponds to 'ouf' (participant's output)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60533, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Split lines into tokens (whitespace-separated values).\n  Skips empty lines and handles multiple spaces between tokens.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (answer_path) against jury's answer (stdout_path).\n  Input test (stdin_path) is unused in this comparison.\n\n  Steps:\n  1. Read all three files\n  2. Tokenize jury and contestant outputs\n  3. Convert tokens to numbers and compare sequentially\n  4. Return true only if all tokens match and token counts are equal\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files (stdin_path unused for comparison)\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> jury_lines     = read_file(stdout_path);   // Jury's answer (correct output)\n    vector<string> contestant_lines = read_file(answer_path); // Contestant's output\n\n    // Convert lines to tokens\n    vector<string> jury_tokens = tokenize(jury_lines);\n    vector<string> contestant_tokens = tokenize(contestant_lines);\n\n    // Compare token counts first (early exit)\n    if (jury_tokens.size() != contestant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token as numbers\n    for (size_t i = 0; i < jury_tokens.size(); ++i) {\n        try {\n            // Convert tokens to numbers\n            ll jury_num = stoll(jury_tokens[i]);\n            ll contestant_num = stoll(contestant_tokens[i]);\n            \n            // Check for mismatch\n            if (jury_num != contestant_num) {\n                return false;\n            }\n        } catch (...) {\n            // Conversion failed (non-numeric token)\n            return false;\n        }\n    }\n    \n    // All tokens match\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60322, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt).\n  Uses trimmed lines for comparison. Returns true if identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60532, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from the correct output\n  (stdout.txt) and participant's output (answer.txt). Return true if\n  sequences are identical in length and each corresponding element,\n  otherwise false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    vector<long long> correct_nums;\n    vector<long long> participant_nums;\n\n    // Parse correct output (stdout_lines) into numerical sequence\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos = 0;\n                long long num = stoll(token, &pos);\n                // Verify entire token was consumed during conversion\n                if (pos != token.size()) \n                    return false;\n                correct_nums.push_back(num);\n            } catch (...) {\n                return false;  // Invalid number format\n            }\n        }\n    }\n\n    // Parse participant's output (participant_lines) into numerical sequence\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos = 0;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    return false;\n                participant_nums.push_back(num);\n            } catch (...) {\n                return false;\n            }\n        }\n    }\n\n    // Check if sequences have identical length\n    if (correct_nums.size() != participant_nums.size()) \n        return false;\n\n    // Compare each corresponding element\n    for (size_t i = 0; i < correct_nums.size(); ++i) {\n        if (correct_nums[i] != participant_nums[i]) \n            return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60528, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens in expected output (stdout.txt) and participant's output (answer.txt)\n  as sequences of tokens in lines. Each line is split into tokens by whitespace.\n  Returns true if all tokens match in sequence, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Collect all tokens from expected output (stdout.txt)\n    vector<string> expected_tokens;\n    for (const string& line : expected_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            expected_tokens.push_back(token);\n        }\n    }\n\n    // Collect all tokens from participant's output (answer.txt)\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Compare token sequences\n    return (expected_tokens == participant_tokens);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60480, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) with expected output (stdout.txt).\n  Validates line count and exact string matching after whitespace trimming.\n  Uses stdin.txt only if problem requires input-dependent validation.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Input may not be used in all validation logic\n    (void)stdin_lines;\n\n    // Check line count mismatch first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact content match\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60539, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the correct answer (from stdout.txt) with the contestant's\n  output (from answer.txt). Return true if they match, false otherwise.\n  Prints appropriate result message to standard output.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Verify both output files contain exactly one line\n    if (stdout_lines.size() != 1) {\n        cout << \"jury answer file should contain exactly one integer\\n\";\n        return false;\n    }\n    if (participant_lines.size() != 1) {\n        cout << \"contestant output file should contain exactly one integer\\n\";\n        return false;\n    }\n\n    try {\n        int ja = stoi(stdout_lines[0]);      // Judge's answer from stdout.txt (correct)\n        int pa = stoi(participant_lines[0]); // Participant's answer from answer.txt\n\n        if (ja != pa) {\n            cout << \"expected \" << ja << \", found \" << pa << \"\\n\";\n            return false;\n        }\n        cout << \"answer is \" << ja << \"\\n\";\n        return true;\n    }\n    catch (const exception& e) {\n        cout << \"failed to parse integer: \" << e.what() << \"\\n\";\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60545, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (contestant's output)\n\n    // Check both files contain exactly one line with a number\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Parse the single value from each file\n        ll jury_value = stoll(stdout_lines[0]);\n        ll ouf_value  = stoll(participant_lines[0]);\n\n        return jury_value == ouf_value;\n    } catch (...) {\n        // Handle conversion errors (non-numeric content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60549, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing query responses\n  against expected answers:\n  1. Parse problem parameters (n, q) from stdin.txt\n  2. For each query, verify participant's output matches\n     expected answer from stdout.txt\n  3. Return true only if all queries match\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answers (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse n and q from first line of stdin\n    if (stdin_lines.empty()) {\n        return false;\n    }\n    \n    stringstream ss(stdin_lines[0]);\n    int n, q;\n    if (!(ss >> n >> q)) {\n        return false;\n    }\n\n    // Verify sufficient lines in both output files\n    if (stdout_lines.size() < q || participant_lines.size() < q) {\n        return false;\n    }\n\n    // Check each query response\n    for (int i = 0; i < q; i++) {\n        try {\n            int expected = stoi(stdout_lines[i]);\n            int actual   = stoi(participant_lines[i]);\n            \n            if (expected != actual) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60547, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare expected output (stdout_path) and participant's output (answer_path)\n  as sequences of long long integers. Return true if they match exactly in\n  both content and length, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Unused (problem input)\n    vector<string> expected_lines    = read_file(stdout_path);      // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Check if sequence lengths differ\n    if (expected_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each number in the sequences\n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        try {\n            ll expected_num = stoll(expected_lines[i]);\n            ll participant_num = stoll(participant_lines[i]);\n            \n            if (expected_num != participant_num) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-numeric values or conversion errors\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60541, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the \n  jury's output using the input test case.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize all input streams by splitting lines into whitespace-separated tokens\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    vector<string> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdout_tokens.push_back(token);\n        }\n    }\n\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Early termination if essential tokens are missing\n    if (stdin_tokens.size() < 3 || stdout_tokens.empty() || participant_tokens.empty()) {\n        return false;\n    }\n\n    // Parse input test case (stdin)\n    int idx = 0;\n    int n = stoi(stdin_tokens[idx++]);\n    int m = stoi(stdin_tokens[idx++]);\n    int k = stoi(stdin_tokens[idx++]);\n\n    set<int> busy;\n    for (int i = 0; i < k; i++) {\n        if (k > 0) {\n            if (idx >= stdin_tokens.size()) return false;\n            int x = stoi(stdin_tokens[idx++]);\n            if (x < 1 || x > n) return false;\n            busy.insert(x);\n        }\n    }\n\n    vector<set<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        if (idx + 1 >= stdin_tokens.size()) return false;\n        int u = stoi(stdin_tokens[idx++]);\n        int v = stoi(stdin_tokens[idx++]);\n        if (u < 1 || u > n || v < 1 || v > n) return false;\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Parse jury's output (stdout)\n    string juryResult = stdout_tokens[0];\n\n    // Parse participant's output (answer)\n    string contResult = participant_tokens[0];\n\n    // Case 1: Jury states no solution exists\n    if (juryResult == \"No\") {\n        // Participant must also state \"No\" with no additional output\n        return (contResult == \"No\" && participant_tokens.size() == 1);\n    }\n\n    // Case 2: Jury states solution exists\n    if (contResult != \"Yes\") {\n        return false;\n    }\n\n    // Parse the number of steps (t) from participant's output\n    if (participant_tokens.size() < 2) return false;\n    int t = stoi(participant_tokens[1]);\n    if (t < 1 || t > n) return false;\n\n    // State tracking for meeting validation\n    vector<bool> joined(n + 1, false);\n    vector<bool> invited(n + 1, false);\n    vector<bool> inviterInvited(n + 1, false);\n    int token_idx = 2;  // Position after \"Yes\" and t\n\n    // Validate each step of the meeting plan\n    for (int step = 0; step < t; step++) {\n        // Read inviter ID\n        if (token_idx >= participant_tokens.size()) return false;\n        int inviter = stoi(participant_tokens[token_idx++]);\n        if (inviter < 1 || inviter > n) return false;\n        if (inviterInvited[inviter]) return false;  // Inviter already used\n        inviterInvited[inviter] = true;\n\n        // Read number of invitees (y)\n        if (token_idx >= participant_tokens.size()) return false;\n        int y = stoi(participant_tokens[token_idx++]);\n        if (y < 0 || y > n - 1) return false;\n\n        // Validate each invitee\n        vector<int> invitees;\n        for (int j = 0; j < y; j++) {\n            if (token_idx >= participant_tokens.size()) return false;\n            int z = stoi(participant_tokens[token_idx++]);\n            if (z < 1 || z > n) return false;\n            if (adj[inviter].find(z) == adj[inviter].end()) return false;  // No connection\n            invitees.push_back(z);\n        }\n\n        // Validate step-specific constraints\n        if (step == 0) {\n            if (busy.find(inviter) != busy.end()) return false;  // First inviter busy\n        } else {\n            if (!joined[inviter]) return false;  // Inviter not in meeting\n            if (busy.find(inviter) != busy.end()) return false;  // Inviter busy\n        }\n        if (joined[inviter] && step == 0) return false;  // Inviter already joined\n\n        joined[inviter] = true;\n        for (int z : invitees) {\n            if (invited[z]) return false;  // Invitee invited twice\n            invited[z] = true;\n            joined[z] = true;\n        }\n    }\n\n    // Ensure all tokens consumed and all participants joined\n    if (token_idx != participant_tokens.size()) return false;\n    for (int i = 1; i <= n; i++) {\n        if (!joined[i]) return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60536, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper: Returns ordinal suffix for a number (1st, 2nd, etc.)\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Helper: Compresses long strings by replacing middle with \"...\"\n  (e.g., \"1234567890\" becomes \"123...890\" if exceeding max_len)\n-----------------------------------------------------------*/\nstring compress(const string& s, int max_len = 100)\n{\n    if (s.length() <= max_len) \n        return s;\n    \n    int half = max_len / 2;\n    return s.substr(0, half) + \"...\" + s.substr(s.length() - half);\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of numbers from correct answer \n  (stdout_path) and participant's output (answer_path).\n  Prints result message to stdout and returns true if valid.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Input file (unused)\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    int n = 0;\n    string firstElems;\n\n    // Compare element-by-element up to the shorter sequence length\n    int min_size = min(correct_lines.size(), participant_lines.size());\n    for (int i = 0; i < min_size; i++) {\n        n++;\n        try {\n            long long j = stoll(correct_lines[i]);\n            long long p = stoll(participant_lines[i]);\n            \n            if (j != p) {\n                char msg[500];\n                snprintf(msg, sizeof(msg), \n                         \"%d%s numbers differ - expected: '%lld', found: '%lld'\", \n                         n, englishEnding(n).c_str(), j, p);\n                cout << \"wa \" << msg << endl;\n                return false;\n            }\n            \n            // Record first 5 elements for OK message\n            if (n <= 5) {\n                if (!firstElems.empty()) \n                    firstElems += \" \";\n                firstElems += to_string(j);\n            }\n        } catch (...) {\n            cout << \"wa Line \" << (i+1) << \" contains non-numeric value\" << endl;\n            return false;\n        }\n    }\n\n    // Check for extra elements in correct answer\n    if (correct_lines.size() > min_size) {\n        int total = correct_lines.size();\n        cout << \"wa Answer contains longer sequence [length = \" << total \n             << \"], but output contains \" << participant_lines.size() << \" elements\" << endl;\n        return false;\n    }\n\n    // Check for extra elements in participant's output\n    if (participant_lines.size() > min_size) {\n        int total = participant_lines.size();\n        cout << \"wa Output contains longer sequence [length = \" << total \n             << \"], but answer contains \" << correct_lines.size() << \" elements\" << endl;\n        return false;\n    }\n\n    // All checks passed - output OK message\n    if (n <= 5) {\n        cout << \"ok \" << n << \" number(s): \\\"\" << compress(firstElems) << \"\\\"\" << endl;\n    } else {\n        cout << \"ok \" << n << \" numbers\" << endl;\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60567, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n#define EPS 1E-6\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two doubles using maximum absolute or relative error tolerance.\n  Returns true if values match within EPS tolerance.\n-----------------------------------------------------------*/\nbool doubleCompare(double expected, double found)\n{\n    double diff = fabs(expected - found);\n    if (diff <= EPS) {\n        return true;\n    }\n    double maxVal = max(fabs(expected), fabs(found));\n    // Handle near-zero values where relative error becomes meaningless\n    if (maxVal < 1e-9) {\n        return diff <= EPS;\n    }\n    return (diff / maxVal) <= EPS;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from jury's output (stdout.txt) and \n  participant's output (answer.txt). Checks line count and value tolerance.\n  Returns true if all numbers match within EPS tolerance.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path);  // Participant's actual output\n\n    // Verify both files have identical line count\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each corresponding line as double values\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            double jury_val = stod(stdout_lines[i]);\n            double part_val = stod(participant_lines[i]);\n\n            if (!doubleCompare(jury_val, part_val)) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-numeric values or parsing errors\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60552, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens (64-bit signed integers) from a text file.\n  Tokens are separated by whitespace and may span multiple lines.\n  Returns a vector containing all parsed integers.\n-----------------------------------------------------------*/\nvector<ll> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<ll> tokens;\n    ll num;\n\n    while (fin >> num) {\n        tokens.push_back(num);\n    }\n\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare sequences of 64-bit integers from correct answer \n  (stdout_path) and participant's output (answer_path).\n  Returns true if both sequences are identical in content and order,\n  false otherwise (mismatched elements or different lengths).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // stdin_path is unused for this comparison problem\n    (void)stdin_path;\n\n    vector<ll> correct_tokens = read_file(stdout_path);\n    vector<ll> participant_tokens = read_file(answer_path);\n\n    return (correct_tokens == participant_tokens);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60535, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates the contestant's output against the problem input.\n  Reads L and R from stdin_path, processes the contestant's output from answer_path.\n  Returns true if all checks pass (contestant's solution is correct), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Parse L and R from stdin (problem input)\n    vector<string> stdin_lines = read_file(stdin_path);\n    if (stdin_lines.empty()) {\n        return false;\n    }\n    istringstream iss(stdin_lines[0]);\n    int L, R;\n    if (!(iss >> L >> R) || L > R) {\n        return false;\n    }\n\n    // Tokenize contestant's output (answer_path)\n    vector<string> participant_lines = read_file(answer_path);\n    vector<string> tokens;\n    for (string& line : participant_lines) {\n        istringstream line_stream(line);\n        string token;\n        while (line_stream >> token) {\n            tokens.push_back(token);\n        }\n    }\n    int token_idx = 0;\n\n    // Helper: Read integer with range validation\n    auto readInt = [&](int min_val, int max_val) -> optional<int> {\n        if (token_idx >= tokens.size()) {\n            return nullopt;\n        }\n        try {\n            int val = stoi(tokens[token_idx]);\n            if (val < min_val || val > max_val) {\n                return nullopt;\n            }\n            token_idx++;\n            return val;\n        } catch (...) {\n            return nullopt;\n        }\n    };\n\n    // Read number of nodes (1-100)\n    auto n_opt = readInt(1, 100);\n    if (!n_opt) return false;\n    int n = *n_opt;\n\n    // Initialize graph structures\n    vector<vector<pair<int, int>>> adj(n + 1);\n    vector<int> in_degree(n + 1, 0);\n    vector<int> ending_nodes;\n\n    // Process each node's outgoing edges\n    for (int i = 1; i <= n; i++) {\n        auto k_opt = readInt(0, 200);\n        if (!k_opt) return false;\n        int k = *k_opt;\n        if (k == 0) {\n            ending_nodes.push_back(i);\n        }\n        for (int j = 0; j < k; j++) {\n            auto to_opt = readInt(1, n);\n            auto v_opt = readInt(0, 1);\n            if (!to_opt || !v_opt) return false;\n            int to = *to_opt;\n            int v = *v_opt;\n            in_degree[to]++;\n            adj[i].push_back({to, v});\n            if (i == to) {\n                return false;  // Self-loop invalid\n            }\n        }\n    }\n\n    // Check exactly one ending node (outdegree 0)\n    if (ending_nodes.size() != 1) {\n        return false;\n    }\n\n    // Check exactly one start node (indegree 0)\n    int nodes_with_z_in_degree = 0;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            nodes_with_z_in_degree++;\n        }\n    }\n    if (nodes_with_z_in_degree != 1) {\n        return false;\n    }\n\n    // Locate start node\n    int start_node = 0;\n    for (int i = 1; i <= n; i++) {\n        if (in_degree[i] == 0) {\n            start_node = i;\n            break;\n        }\n    }\n\n    // Check binary sequence doesn't start with 0\n    for (auto e : adj[start_node]) {\n        if (e.second == 0) {\n            return false;\n        }\n    }\n\n    // DFS to validate all numbers in [L, R] are covered exactly once\n    vector<bool> vis(R + 1, false);\n    function<int(int, int)> dfs = [&](int node, int val) -> int {\n        if (val > R) {\n            return -1;  // Value exceeds R\n        }\n        if (adj[node].empty()) {\n            if (val < L) {\n                return -1;  // Value below L\n            }\n            if (vis[val]) {\n                return -1;  // Duplicate value\n            }\n            vis[val] = true;\n            return 1;\n        }\n        int cnt = 0;\n        for (auto e : adj[node]) {\n            int res = dfs(e.first, val * 2 + e.second);\n            if (res == -1) {\n                return -1;\n            }\n            cnt += res;\n        }\n        return cnt;\n    };\n\n    int pans = dfs(start_node, 0);\n    if (pans == -1 || pans != R - L + 1) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60546, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function: returns the English ordinal suffix for a number.\n-----------------------------------------------------------*/\nstring englishEnding(int n) {\n    if (n % 100 >= 11 && n % 100 <= 13) return \"th\";\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Helper function: compress a string (simplified version).\n  For this problem, since we only handle up to 5 numbers, just return as-is.\n-----------------------------------------------------------*/\nstring compress(const string& s) {\n    return s;\n}\n\n/*-----------------------------------------------------------\n  Compare sequences of integers from correct answer (stdout.txt) and \n  contestant's output (answer.txt). Print result message to stdout and \n  return true for AC, false for WA.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines   = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> ouf_lines   = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Parse all tokens (long long) from correct answer file\n    vector<long long> correct_tokens;\n    for (const string& line : ans_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            correct_tokens.push_back(num);\n        }\n    }\n\n    // Parse all tokens (long long) from contestant's output file\n    vector<long long> contestant_tokens;\n    for (const string& line : ouf_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            contestant_tokens.push_back(num);\n        }\n    }\n\n    // Compare token sequences element by element\n    size_t i = 0;\n    size_t n = 0;\n    string firstElems;\n\n    while (i < correct_tokens.size() && i < contestant_tokens.size()) {\n        n++;\n        long long j = correct_tokens[i];\n        long long p = contestant_tokens[i];\n\n        if (j != p) {\n            cout << \"wrong answer \" << n << englishEnding(n) << \" numbers differ - expected: '\" << j << \"', found: '\" << p << \"'\\n\";\n            return false;\n        } else if (n <= 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(j);\n        }\n        i++;\n    }\n\n    // Check for extra elements in correct answer\n    if (correct_tokens.size() > i) {\n        cout << \"wrong answer Answer contains longer sequence [length = \" << correct_tokens.size() << \"], but output contains \" << i << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra elements in contestant's output\n    if (contestant_tokens.size() > i) {\n        cout << \"wrong answer Output contains longer sequence [length = \" << contestant_tokens.size() << \"], but answer contains \" << i << \" elements\\n\";\n        return false;\n    }\n\n    // All tokens match - output acceptance message\n    if (n <= 5) {\n        cout << \"ok \" << n << \" number(s): \\\"\" << compress(firstElems) << \"\\\"\\n\";\n    } else {\n        cout << \"ok \" << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60559, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution for the percentile problem.\n  The problem input (stdin_path) provides three integers: \n    a (50th percentile expected value), \n    b (95th percentile), \n    c (99th percentile).\n  The contestant's output (answer_path) must contain:\n    - integer n (number of elements) in [100, 100000] and divisible by 100,\n    - followed by n integers in [1, 10^9].\n  After sorting the n integers, we check:\n    - Value at position p50 = n*50/100 must satisfy: arr[p50] <= a < arr[p50+1]\n    - Similarly for p95 (with b) and p99 (with c).\n  The second file (stdout_path) is unused as the checker doesn't require jury's output.\n  Returns true if all conditions are satisfied, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path); // Unused (jury's output not needed)\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse problem input (a, b, c) from stdin_lines\n    vector<string> input_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            input_tokens.push_back(token);\n        }\n    }\n    if (input_tokens.size() < 3) return false;\n    \n    int a, b, c;\n    try {\n        a = stoi(input_tokens[0]);\n        b = stoi(input_tokens[1]);\n        c = stoi(input_tokens[2]);\n    } catch (...) {\n        return false;\n    }\n\n    // Parse contestant's output (n and array) from participant_lines\n    vector<string> output_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            output_tokens.push_back(token);\n        }\n    }\n    if (output_tokens.empty()) return false;\n    \n    int n;\n    try {\n        n = stoi(output_tokens[0]);\n    } catch (...) {\n        return false;\n    }\n\n    const int mxval = 1000000000; // 1e9\n    // Check n range\n    if (n < 100 || n > 100000) return false;\n    // Must have exactly n+1 tokens (n and n numbers)\n    if (output_tokens.size() < (size_t)(n + 1)) return false;\n\n    // Read and validate the n integers\n    vector<int> arr(n + 2, 0); // 1-indexed array (indices 1..n)\n    for (int i = 1; i <= n; i++) {\n        try {\n            int num = stoi(output_tokens[i]);\n            if (num < 1 || num > mxval) return false;\n            arr[i] = num;\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Sort the array segment (1 to n) and set sentinel\n    sort(arr.begin() + 1, arr.begin() + n + 1);\n    arr[n + 1] = mxval + 1; // Sentinel value\n\n    // Check n divisible by 100 (required for percentile positions)\n    if (n % 100 != 0) return false;\n\n    // Calculate percentile positions (integer division is exact since n divisible by 100)\n    int p50 = (n * 50) / 100;\n    int p95 = (n * 95) / 100;\n    int p99 = (n * 99) / 100;\n\n    // Validate 50th percentile condition: arr[p50] <= a < arr[p50+1]\n    if (arr[p50] > a || arr[p50 + 1] <= a) return false;\n    // Validate 95th percentile\n    if (arr[p95] > b || arr[p95 + 1] <= b) return false;\n    // Validate 99th percentile\n    if (arr[p99] > c || arr[p99 + 1] <= c) return false;\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60560, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two double values using both absolute and relative \n  error tolerance (EPS = 1e-4). Returns true if values match.\n-----------------------------------------------------------*/\nbool doubleCompare(double a, double b, double eps) {\n    double diff = fabs(a - b);\n    if (diff <= eps) return true;\n    double base = max(fabs(a), fabs(b));\n    return (diff <= base * eps);\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Both files should contain sequences of doubles. Checks:\n  1. Same number of lines\n  2. Each double matches within EPS = 1e-4 tolerance\n  Returns true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // stdout_path contains correct answer (ans in original code)\n    // answer_path contains participant's output (ouf in original code)\n    vector<string> correct_lines = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Different line counts  invalid\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    const double EPS = 1E-4;\n\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        try {\n            double judge_val = stod(correct_lines[i]);\n            double part_val = stod(participant_lines[i]);\n            \n            if (!doubleCompare(judge_val, part_val, EPS)) {\n                return false;\n            }\n        } catch (...) {\n            // Failed to parse double  invalid\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60544, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct answer (stdout_path).\n  Returns true if all tokens match, false otherwise with error message on cerr.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse all tokens from correct answer\n    vector<long long> correct_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            correct_tokens.push_back(num);\n        }\n    }\n\n    // Parse all tokens from participant's output\n    vector<long long> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            participant_tokens.push_back(num);\n        }\n    }\n\n    // Check if token counts match\n    if (correct_tokens.size() != participant_tokens.size()) {\n        if (correct_tokens.size() > participant_tokens.size()) {\n            cerr << \"Participant output has fewer lines than expected\\n\";\n        } else {\n            cerr << \"Participant output has more lines than expected\\n\";\n        }\n        return false;\n    }\n\n    // Compare each token\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            cerr << \"Mismatch on test case \" << (i + 1)\n                 << \": expected \" << correct_tokens[i]\n                 << \", found \" << participant_tokens[i] << '\\n';\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60554, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output by comparing the first integer value\n  in answer.txt (participant's output) against stdout.txt (jury's expected answer).\n  Returns true if values match, false otherwise (including file/read errors).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to inf (input, unused here)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to ans (jury's expected output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to ouf (participant's output)\n\n    // Verify both output files contain at least one line\n    if (participant_lines.empty() || stdout_lines.empty()) {\n        return false;\n    }\n\n    const string& part_line = participant_lines[0];\n    const string& jury_line = stdout_lines[0];\n\n    // Ensure lines contain actual content after trimming\n    if (part_line.empty() || jury_line.empty()) {\n        return false;\n    }\n\n    try {\n        ll participant_val = stoll(part_line);\n        ll jury_val        = stoll(jury_line);\n        return participant_val == jury_val;\n    } catch (...) {\n        // Handle non-integer values or conversion failures\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60576, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from expected answer\n  (stdout.txt) and participant's output (answer.txt). Return true \n  if sequences match exactly, false otherwise.\n  \n  Steps:\n  1. Parse both files into sequences of numbers by splitting all lines\n     into whitespace-separated tokens\n  2. Verify both sequences have identical length\n  3. Verify each corresponding number matches\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read expected answer (stdout.txt) and participant output (answer.txt)\n    vector<string> expected_lines = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse all tokens into numerical sequences\n    vector<ll> expected_numbers;\n    vector<ll> participant_numbers;\n\n    // Convert expected answer lines to numbers\n    for (const string& line : expected_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            expected_numbers.push_back(num);\n        }\n    }\n\n    // Convert participant output lines to numbers\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            participant_numbers.push_back(num);\n        }\n    }\n\n    // Check sequence length mismatch\n    if (expected_numbers.size() != participant_numbers.size()) {\n        return false;\n    }\n\n    // Verify element-wise equality\n    for (size_t i = 0; i < expected_numbers.size(); ++i) {\n        if (expected_numbers[i] != participant_numbers[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60561, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check if line counts match between participant's output and expected answer\n    if (stdout_lines.size() != answer_lines.size()) {\n        return false;\n    }\n\n    // Compare each integer value line by line\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            int participant_val = stoi(stdout_lines[i]);\n            int expected_val    = stoi(answer_lines[i]);\n            if (participant_val != expected_val) {\n                return false;\n            }\n        } catch (...) {\n            // Handle conversion errors (non-integer values)\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60557, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct output using \n  problem's input format. Returns true if valid, false otherwise.\n  - stdin.txt  : contains input test cases (corresponds to 'inf')\n  - stdout.txt : contains correct output (corresponds to 'ans')\n  - answer.txt : contains participant's output (corresponds to 'ouf')\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    size_t stdin_idx = 0;\n    size_t ans_idx   = 0;\n    size_t ouf_idx   = 0;\n\n    // Read number of test cases (t)\n    if (stdin_idx >= stdin_lines.size()) \n        return false;\n    int t;\n    {\n        stringstream ss(stdin_lines[stdin_idx++]);\n        if (!(ss >> t)) \n            return false;\n    }\n\n    for (int i = 0; i < t; ++i) {\n        // Parse n, m, q from input\n        if (stdin_idx >= stdin_lines.size())\n            return false;\n        string line = stdin_lines[stdin_idx++];\n        stringstream ss(line);\n        int n, m, q;\n        if (!(ss >> n >> m >> q))\n            return false;\n\n        // Skip q lines in input\n        stdin_idx += q;\n        if (stdin_idx > stdin_lines.size())\n            return false;\n\n        // Compare m output lines per test case\n        for (int j = 0; j < m; ++j) {\n            // Read correct output values\n            if (ans_idx >= correct_lines.size())\n                return false;\n            line = correct_lines[ans_idx++];\n            stringstream ans_ss(line);\n            ll jid, jp;\n            if (!(ans_ss >> jid >> jp))\n                return false;\n\n            // Read participant's output values\n            if (ouf_idx >= participant_lines.size())\n                return false;\n            line = participant_lines[ouf_idx++];\n            stringstream ouf_ss(line);\n            ll pid, pp;\n            if (!(ouf_ss >> pid >> pp))\n                return false;\n\n            // Validate output matches\n            if (jid != pid || jp != pp) {\n                return false;\n            }\n        }\n    }\n\n    // Ensure no extra output from participant\n    if (ouf_idx != participant_lines.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60556, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected output.\n  Parses stdin.txt to determine test structure (T test cases),\n  then checks q+1 output lines per test case from stdout.txt\n  (expected) and answer.txt (participant's output).\n  Returns true if all outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Validate file contents were read properly\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        cerr << \"Error: One or more input files are empty\\n\";\n        return false;\n    }\n\n    int stdin_idx = 0;\n    int stdout_idx = 0;\n    int participant_idx = 0;\n\n    // Parse total test cases (T)\n    if (stdin_idx >= stdin_lines.size()) return false;\n    int T;\n    istringstream t_ss(stdin_lines[stdin_idx++]);\n    if (!(t_ss >> T) || T < 0) return false;\n\n    for (int tc = 0; tc < T; tc++) {\n        // Parse n and q for current test case\n        if (stdin_idx >= stdin_lines.size()) return false;\n        istringstream iss(stdin_lines[stdin_idx++]);\n        int n, q;\n        if (!(iss >> n >> q) || n < 0 || q < 0) return false;\n\n        // Skip n input values and q queries in stdin\n        stdin_idx += n;\n        stdin_idx += q;\n        if (stdin_idx > stdin_lines.size()) return false;\n\n        // Check q+1 output lines for this test case\n        for (int i = 0; i <= q; i++) {\n            if (stdout_idx >= stdout_lines.size() || \n                participant_idx >= participant_lines.size()) {\n                return false;\n            }\n\n            // Parse expected and actual values\n            istringstream exp_ss(stdout_lines[stdout_idx]);\n            istringstream got_ss(participant_lines[participant_idx]);\n            long long exp, got;\n            if (!(exp_ss >> exp) || !(got_ss >> got)) return false;\n\n            // Verify no trailing characters\n            char extra;\n            if (exp_ss.get(extra) || got_ss.get(extra)) return false;\n\n            // Compare values\n            if (exp != got) {\n                cerr << \"test \" << (tc+1) << \" line \" << (i+1)\n                     << \": expected \" << exp << \", found \" << got << '\\n';\n                return false;\n            }\n\n            stdout_idx++;\n            participant_idx++;\n        }\n    }\n\n    // Ensure all output lines were consumed\n    return (stdout_idx == stdout_lines.size() && \n            participant_idx == participant_lines.size());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60537, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing against problem input.\n  Returns true if solution is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Problem input (inf)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Model answer (ans) - unused\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Skip leading empty lines in problem input\n    int idx_in = 0;\n    while (idx_in < stdin_lines.size() && stdin_lines[idx_in].empty()) \n        idx_in++;\n    if (idx_in >= stdin_lines.size()) \n        return false;  // No valid input found\n\n    // Parse number of test cases (T)\n    int T;\n    try {\n        T = stoi(stdin_lines[idx_in++]);\n    } catch (...) {\n        return false;\n    }\n    if (T < 1 || T > 10000) \n        return false;\n\n    // Skip leading empty lines in participant's output\n    int idx_out = 0;\n    while (idx_out < participant_lines.size() && participant_lines[idx_out].empty()) \n        idx_out++;\n\n    // Process each test case\n    for (int tc = 0; tc < T; ++tc) {\n        // Skip empty lines and parse n (number of commands)\n        while (idx_in < stdin_lines.size() && stdin_lines[idx_in].empty()) \n            idx_in++;\n        if (idx_in >= stdin_lines.size()) \n            return false;\n        \n        int n;\n        try {\n            n = stoi(stdin_lines[idx_in++]);\n        } catch (...) {\n            return false;\n        }\n        if (n < 1 || n > 10) \n            return false;\n\n        // Calculate target position from problem input\n        int targetX = 0, targetY = 0;\n        for (int i = 0; i < n; ++i) {\n            while (idx_in < stdin_lines.size() && stdin_lines[idx_in].empty()) \n                idx_in++;\n            if (idx_in >= stdin_lines.size()) \n                return false;\n            \n            const string& line = stdin_lines[idx_in++];\n            if (line.empty()) \n                return false;\n            \n            // Parse direction character and distance\n            char d = line[0];\n            size_t pos = line.find(' ');\n            if (pos == string::npos) \n                return false;\n            \n            int x;\n            try {\n                x = stoi(line.substr(pos + 1));\n            } catch (...) {\n                return false;\n            }\n            if (x < 1 || x > 10) \n                return false;\n\n            // Update target position\n            if (d == 'N') targetY += x;\n            else if (d == 'S') targetY -= x;\n            else if (d == 'E') targetX += x;\n            else if (d == 'W') targetX -= x;\n            else \n                return false;  // Invalid direction\n        }\n\n        // Parse participant's output for this test case\n        while (idx_out < participant_lines.size() && participant_lines[idx_out].empty()) \n            idx_out++;\n        if (idx_out >= participant_lines.size()) \n            return false;\n        \n        const string& first_line = participant_lines[idx_out++];\n        pos = first_line.find(' ');\n        if (pos == string::npos) \n            return false;\n        \n        int m;\n        try {\n            m = stoi(first_line.substr(0, pos));\n        } catch (...) {\n            return false;\n        }\n        if (m < 1 || m > 20) \n            return false;\n        \n        char facing = first_line[pos + 1];\n        if (facing != 'N' && facing != 'S' && facing != 'E' && facing != 'W') \n            return false;\n\n        // Simulate participant's movement\n        int posX = 0, posY = 0;\n        char dir = facing;\n        char prevCmd = 0;\n        \n        for (int i = 0; i < m; ++i) {\n            while (idx_out < participant_lines.size() && participant_lines[idx_out].empty()) \n                idx_out++;\n            if (idx_out >= participant_lines.size()) \n                return false;\n            \n            const string& cmd_line = participant_lines[idx_out++];\n            if (cmd_line.empty()) \n                return false;\n            \n            char cmd = cmd_line[0];\n            // Validate command sequence rules\n            if (i == 0) {\n                if (cmd != 'Z') \n                    return false;\n            } else {\n                if (cmd == prevCmd) \n                    return false;\n                if ((cmd == 'L' && prevCmd == 'R') || (cmd == 'R' && prevCmd == 'L')) \n                    return false;\n            }\n\n            if (cmd == 'Z') {\n                // Parse distance after 'Z'\n                if (cmd_line.size() <= 2 || cmd_line[1] != ' ') \n                    return false;\n                \n                int dist;\n                try {\n                    dist = stoi(cmd_line.substr(2));\n                } catch (...) {\n                    return false;\n                }\n                if (dist < 1 || dist > 100) \n                    return false;\n                \n                // Update position based on current direction\n                if (dir == 'N') posY += dist;\n                else if (dir == 'S') posY -= dist;\n                else if (dir == 'E') posX += dist;\n                else if (dir == 'W') posX -= dist;\n            } else {\n                // Update direction for 'L' or 'R'\n                if (cmd == 'L') {\n                    if (dir == 'N') dir = 'W';\n                    else if (dir == 'W') dir = 'S';\n                    else if (dir == 'S') dir = 'E';\n                    else if (dir == 'E') dir = 'N';\n                } else if (cmd == 'R') {\n                    if (dir == 'N') dir = 'E';\n                    else if (dir == 'E') dir = 'S';\n                    else if (dir == 'S') dir = 'W';\n                    else if (dir == 'W') dir = 'N';\n                } else {\n                    return false;  // Invalid command\n                }\n            }\n            prevCmd = cmd;\n        }\n\n        // Verify final position matches target\n        if (posX != targetX || posY != targetY) \n            return false;\n    }\n\n    // Skip trailing empty lines in problem input\n    while (idx_in < stdin_lines.size() && stdin_lines[idx_in].empty()) \n        idx_in++;\n    if (idx_in != stdin_lines.size()) \n        return false;  // Extra content in problem input\n\n    // Skip trailing empty lines in participant's output\n    while (idx_out < participant_lines.size() && participant_lines[idx_out].empty()) \n        idx_out++;\n    if (idx_out != participant_lines.size()) \n        return false;  // Extra content in participant's output\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60558, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare the correct output (stdout.txt) and participant's output (answer.txt).\n  Both files should contain a single integer value. If the values match, print\n  acceptance message and return true; otherwise print rejection message and return false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Ensure both output files contain exactly one line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        ll correct = stoll(stdout_lines[0]);\n        ll user    = stoll(participant_lines[0]);\n\n        if (correct == user) {\n            printf(\"Correct: %lld\\n\", user);\n            return true;\n        } else {\n            printf(\"Wrong answer: expected %lld, found %lld\\n\", correct, user);\n            return false;\n        }\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60566, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare judge's output (from stdout.txt) against participant's output \n  (from answer.txt) by reading a single integer from each file. \n  Return true if values match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Verify both output files contain exactly one non-empty line\n    if (stdout_lines.size() != 1 || participant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        int ja = stoi(stdout_lines[0]);        // Judge's answer (correct output)\n        int pa = stoi(participant_lines[0]);   // Participant's answer\n        return ja == pa;\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60565, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare tokens from correct answer (stdout_path) and \n  participant's output (answer_path). Return true if all tokens \n  match in order and quantity, false otherwise.\n  \n  Note: \n    - stdout_path contains judge's expected output (ans in original)\n    - answer_path contains participant's output (ouf in original)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> ans_lines = read_file(stdout_path);  // Judge's expected output\n    vector<string> ouf_lines = read_file(answer_path);  // Participant's output\n\n    // Convert both files' content into token sequences\n    vector<string> ans_tokens;\n    for (const string& line : ans_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    vector<string> ouf_tokens;\n    for (const string& line : ouf_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Check token count mismatch\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60582, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Extract all whitespace-separated tokens from a vector of lines.\n  Each line is split into tokens, which are collected into a single vector.\n-----------------------------------------------------------*/\nvector<string> extract_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Return the English ordinal suffix for a number (e.g., \"st\", \"nd\").\n-----------------------------------------------------------*/\nstring englishEnding(int n)\n{\n    if (n % 100 >= 11 && n % 100 <= 13) {\n        return \"th\";\n    }\n    switch (n % 10) {\n        case 1: return \"st\";\n        case 2: return \"nd\";\n        case 3: return \"rd\";\n        default: return \"th\";\n    }\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    vector<string> answer_tokens     = extract_tokens(answer_lines);\n    vector<string> output_tokens     = extract_tokens(stdout_lines);\n\n    int n = 0;\n    string firstElems;\n\n    // Compare each token sequentially\n    size_t min_size = min(answer_tokens.size(), output_tokens.size());\n    for (size_t i = 0; i < min_size; i++) {\n        n++;\n        try {\n            long long j = stoll(answer_tokens[i]);\n            long long p = stoll(output_tokens[i]);\n            if (j != p) {\n                cerr << \"wa \" << n << englishEnding(n) \n                     << \" numbers differ - expected: '\" \n                     << j << \"', found: '\" << p << \"'\\n\";\n                return false;\n            }\n            if (n <= 5) {\n                if (!firstElems.empty()) firstElems += \" \";\n                firstElems += to_string(j);\n            }\n        } catch (...) {\n            cerr << \"wa Token \" << n << \" is not a valid number\\n\";\n            return false;\n        }\n    }\n\n    // Check for extra tokens in answer file (expected output)\n    if (answer_tokens.size() > output_tokens.size()) {\n        int total = answer_tokens.size();\n        cerr << \"wa Answer contains longer sequence [length = \" << total \n             << \"], but output contains \" << output_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra tokens in output file (contestant's submission)\n    if (output_tokens.size() > answer_tokens.size()) {\n        int total = output_tokens.size();\n        cerr << \"wa Output contains longer sequence [length = \" << total \n             << \"], but answer contains \" << answer_tokens.size() << \" elements\\n\";\n        return false;\n    }\n\n    // All tokens matched successfully\n    if (n <= 5) {\n        cout << \"ok \" << n << \" number(s): \\\"\" << firstElems << \"\\\"\\n\";\n    } else {\n        cout << \"ok \" << n << \" numbers\\n\";\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60585, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two files as sequences of tokens (ignoring line breaks).\n  Expected output (ans) is read from stdout_path, participant's output (ouf) from answer_path.\n  Returns true if token sequences match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read files (stdin_path is unused but required by template structure)\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> expected_lines = read_file(stdout_path);  // Corresponds to 'ans' (expected output)\n    vector<string> ouf_lines      = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Extract all tokens from expected output\n    vector<string> expected_tokens;\n    for (string& line : expected_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            expected_tokens.push_back(token);\n        }\n    }\n\n    // Extract all tokens from participant's output\n    vector<string> ouf_tokens;\n    for (string& line : ouf_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Compare token sequences\n    if (expected_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < expected_tokens.size(); ++i) {\n        if (expected_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";  // Contains expected output (ans)\n    const string answer_path = \"answer.txt\";  // Contains participant's output (ouf)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60584, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer with \n  1e-6 relative/absolute error tolerance. Returns true only if:\n  - Line counts match exactly\n  - All numeric values are within tolerance\n  - All lines contain valid floating-point numbers\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);   // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);   // Participant's output (ouf)\n\n    // Convert correct output lines to numeric values (skip empty lines)\n    vector<long double> jury;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        try {\n            size_t pos;\n            long double val = stold(line, &pos);\n            if (pos != line.size()) {\n                return false; // Non-numeric characters present\n            }\n            jury.push_back(val);\n        } catch (...) {\n            return false; // Conversion failed\n        }\n    }\n\n    // Convert participant's output lines to numeric values (skip empty lines)\n    vector<long double> user;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        try {\n            size_t pos;\n            long double val = stold(line, &pos);\n            if (pos != line.size()) {\n                return false; // Non-numeric characters present\n            }\n            user.push_back(val);\n        } catch (...) {\n            return false; // Conversion failed\n        }\n    }\n\n    // Verify line count matches\n    if (user.size() != jury.size()) {\n        return false;\n    }\n\n    // Check each value with relative/absolute tolerance\n    const long double EPS = 1e-6;\n    for (int i = 0; i < (int) jury.size(); i++) {\n        long double b = jury[i];\n        long double a = user[i];\n        long double diff = fabsl(a - b);\n        long double tol = EPS * max(1.0L, fabsl(b));\n        if (diff > tol) {\n            return false; // Value exceeds tolerance\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60570, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from a file into a vector<string>, splitting\n  by any whitespace (similar to testlib's readToken() behavior).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected output.\n  Returns true if correct, false otherwise (with error details\n  printed to stderr).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // stdin_path (problem input) is unused in token comparison\n    vector<string> expected_tokens = read_file(stdout_path);   // Jury's answer (ans)\n    vector<string> participant_tokens = read_file(answer_path); // Participant's output (ouf)\n\n    // Compare token counts\n    if (participant_tokens.size() != expected_tokens.size()) {\n        cerr << \"wrong number of tokens: expected \" \n             << static_cast<int>(expected_tokens.size()) \n             << \", found \" \n             << static_cast<int>(participant_tokens.size()) \n             << '\\n';\n        return false;\n    }\n\n    // Compare tokens one by one\n    for (size_t i = 0; i < expected_tokens.size(); ++i) {\n        if (participant_tokens[i] != expected_tokens[i]) {\n            cerr << \"mismatch at token \" << (i + 1) \n                 << \": expected '\" << expected_tokens[i] \n                 << \"', found '\" << participant_tokens[i] \n                 << \"'\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60568, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of signed 64-bit integers from expected\n  output (stdout.txt) and participant's output (answer.txt).\n  Returns true if sequences match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Parse all integers from expected output\n    vector<long long> expected_nums;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    throw invalid_argument(\"invalid number format\");\n                expected_nums.push_back(num);\n            } catch (...) {\n                cerr << \"Invalid number in expected output: \" << token << endl;\n                return false;\n            }\n        }\n    }\n\n    // Parse all integers from participant's output\n    vector<long long> participant_nums;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    throw invalid_argument(\"invalid number format\");\n                participant_nums.push_back(num);\n            } catch (...) {\n                cerr << \"Invalid number in participant output: \" << token << endl;\n                return false;\n            }\n        }\n    }\n\n    // Compare sequences element-by-element\n    int n = 0;\n    string firstElems;\n\n    int min_size = min(expected_nums.size(), participant_nums.size());\n    for (; n < min_size; n++) {\n        if (expected_nums[n] != participant_nums[n]) {\n            cerr << \"Mismatch at position \" << n+1 << \": expected '\"\n                 << expected_nums[n] << \"', found '\" << participant_nums[n] << \"'\\n\";\n            return false;\n        }\n        // Collect first 5 elements for success message\n        if (n < 5) {\n            if (!firstElems.empty()) firstElems += \" \";\n            firstElems += to_string(expected_nums[n]);\n        }\n    }\n\n    // Check for extra elements in expected output\n    if (expected_nums.size() > min_size) {\n        cerr << \"Expected output contains longer sequence [length = \" << expected_nums.size()\n             << \"], but participant output contains \" << participant_nums.size() << \" elements\\n\";\n        return false;\n    }\n\n    // Check for extra elements in participant's output\n    if (participant_nums.size() > min_size) {\n        cerr << \"Participant output contains longer sequence [length = \" << participant_nums.size()\n             << \"], but expected output contains \" << expected_nums.size() << \" elements\\n\";\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60574, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output against the expected output.\n  Uses stdin.txt to determine number of test cases (t), then checks\n  that each value in answer.txt (participant's output) matches the\n  corresponding value in stdout.txt (expected output).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if input file is empty\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases (t) from first line of stdin\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Verify expected line counts\n    if (t < 0 || stdout_lines.size() != t || participant_lines.size() != t) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < t; i++) {\n        try {\n            ll participant_val = stoll(participant_lines[i]);\n            ll expected_val    = stoll(stdout_lines[i]);\n            \n            if (participant_val != expected_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60548, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validator for the \"Arrow\" problem.\n  Compares contestant's output against jury's output using problem input.\n  Returns true if valid, false otherwise (with error details on cerr).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<string> ans_lines   = read_file(stdout_path);   // Correct output (jury)\n    vector<string> ouf_lines   = read_file(answer_path);   // Contestant's output\n\n    // Preprocess stdin_lines: each line is a single token (T and targets)\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        if (!line.empty()) {\n            stdin_tokens.push_back(line);\n        }\n    }\n\n    // Preprocess ans_lines: split all lines into tokens\n    vector<string> ans_tokens;\n    for (const string& line : ans_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Preprocess ouf_lines: split all lines into tokens\n    vector<string> ouf_tokens;\n    for (const string& line : ouf_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    int t_idx = 0; // Current index in stdin_tokens\n    int a_idx = 0; // Current index in ans_tokens\n    int o_idx = 0; // Current index in ouf_tokens\n\n    // 1) Read T (number of test cases)\n    if (t_idx >= stdin_tokens.size()) {\n        cerr << \"Unexpected end of input file: missing T\\n\";\n        return false;\n    }\n    int T;\n    try {\n        T = stoi(stdin_tokens[t_idx++]);\n    } catch (...) {\n        cerr << \"T is not a valid integer\\n\";\n        return false;\n    }\n\n    // Process each test case\n    for (int tc = 1; tc <= T; tc++) {\n        // --- Read target string for this test case ---\n        if (t_idx >= stdin_tokens.size()) {\n            cerr << \"Test \" << tc << \": missing target string\\n\";\n            return false;\n        }\n        string target = stdin_tokens[t_idx++];\n        int n = target.size();\n\n        // --- Read jury's verdict ---\n        if (a_idx >= ans_tokens.size()) {\n            cerr << \"Test \" << tc << \": missing jury verdict\\n\";\n            return false;\n        }\n        string juryVerdict = ans_tokens[a_idx++];\n\n        if (juryVerdict != \"Yes\" && juryVerdict != \"No\") {\n            cerr << \"Test \" << tc << \": jury printed '\" << juryVerdict << \"' instead of Yes/No\\n\";\n            return false;\n        }\n\n        // If jury said \"Yes\", skip their operation details\n        if (juryVerdict == \"Yes\") {\n            if (a_idx >= ans_tokens.size()) {\n                cerr << \"Test \" << tc << \": missing K after 'Yes'\\n\";\n                return false;\n            }\n            int K;\n            try {\n                K = stoi(ans_tokens[a_idx++]);\n            } catch (...) {\n                cerr << \"Test \" << tc << \": K is not a valid integer\\n\";\n                return false;\n            }\n            a_idx += 2 * K;  // Skip K operations (each has p and len)\n            if (a_idx > ans_tokens.size()) {\n                cerr << \"Test \" << tc << \": missing jury's operations\\n\";\n                return false;\n            }\n        }\n\n        // --- Read contestant's verdict ---\n        if (o_idx >= ouf_tokens.size()) {\n            cerr << \"Test \" << tc << \": missing contestant verdict\\n\";\n            return false;\n        }\n        string verdict = ouf_tokens[o_idx++];\n\n        if (verdict != \"Yes\" && verdict != \"No\") {\n            cerr << \"Test \" << tc << \": expected contestant to print Yes/No, got '\" << verdict << \"'\\n\";\n            return false;\n        }\n\n        // --- Compare verdicts ---\n        if (verdict != juryVerdict) {\n            cerr << \"Test \" << tc << \": verdict mismatch; jury said '\" << juryVerdict << \"' but contestant said '\" << verdict << \"'\\n\";\n            return false;\n        }\n\n        // If both said \"No\", move to next test case\n        if (verdict == \"No\") {\n            continue;\n        }\n\n        // --- Both said \"Yes\": validate contestant's operations ---\n        string cur(n, '*');  // Start with all '*'\n\n        // Read number of operations (k)\n        if (o_idx >= ouf_tokens.size()) {\n            cerr << \"Test \" << tc << \": missing k after 'Yes'\\n\";\n            return false;\n        }\n        int k;\n        try {\n            k = stoi(ouf_tokens[o_idx++]);\n        } catch (...) {\n            cerr << \"Test \" << tc << \": k is not a valid integer\\n\";\n            return false;\n        }\n\n        if (k < 0 || k > n) {\n            cerr << \"Test \" << tc << \": k = \" << k << \" out of range [0..\" << n << \"]\\n\";\n            return false;\n        }\n\n        // Process each operation\n        for (int i = 0; i < k; i++) {\n            if (o_idx + 1 >= ouf_tokens.size()) {\n                cerr << \"Test \" << tc << \", op \" << (i+1) << \": missing operation parameters\\n\";\n                return false;\n            }\n\n            int p, len;\n            try {\n                p = stoi(ouf_tokens[o_idx++]);\n                len = stoi(ouf_tokens[o_idx++]);\n            } catch (...) {\n                cerr << \"Test \" << tc << \", op \" << (i+1) << \": operation parameters are not integers\\n\";\n                return false;\n            }\n\n            // Validate p and len constraints\n            if (p < 1 || p > n - 4) {\n                cerr << \"Test \" << tc << \", op \" << (i+1) << \": p = \" << p << \" out of [1..\" << (n-4) << \"]\\n\";\n                return false;\n            }\n            if (len < 5 || len > n + 1 - p) {\n                cerr << \"Test \" << tc << \", op \" << (i+1) << \": len = \" << len << \" out of [5..\" << (n+1-p) << \"]\\n\";\n                return false;\n            }\n\n            // Apply the operation to current string\n            int L = p - 1;\n            int R = L + len - 1;\n            cur[L] = '>';\n            for (int j = L + 1; j <= R - 3; j++) {\n                cur[j] = '-';\n            }\n            cur[R - 2] = '>';\n            cur[R - 1] = '>';\n            cur[R] = '>';\n        }\n\n        // Final check: does reconstructed string match target?\n        if (cur != target) {\n            cerr << \"Test \" << tc << \": after \" << k << \" ops got '\" << cur << \"' but expected '\" << target << \"'\\n\";\n            return false;\n        }\n    }\n\n    // All test cases passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60575, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing:\n    - stdin.txt (problem input) \n    - stdout.txt (expected output/jury answer)\n    - answer.txt (contestant's output)\n  \n  Returns true if contestant's output is correct, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize stdin_lines with preserved line structure for input stream (inf)\n    vector<vector<string>> inf_tokens_2d;\n    for (const string& line : stdin_lines) {\n        if (line.empty()) continue;  // Skip empty lines after trimming\n        stringstream ss(line);\n        string token;\n        vector<string> tokens_in_line;\n        while (ss >> token) {\n            tokens_in_line.push_back(token);\n        }\n        inf_tokens_2d.push_back(tokens_in_line);\n    }\n\n    // Flatten stdout_lines (expected output/ans) and participant_lines (contestant's output/ouf) into token vectors\n    vector<string> ans_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    vector<string> ouf_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Set up stream positions and helper lambdas for input stream (inf)\n    int inf_line_idx = 0;\n    int inf_token_idx = 0;\n    auto inf_read_token = [&]() -> string {\n        // Advance to next available token in input stream\n        while (inf_line_idx < inf_tokens_2d.size() && inf_token_idx >= inf_tokens_2d[inf_line_idx].size()) {\n            inf_line_idx++;\n            inf_token_idx = 0;\n        }\n        if (inf_line_idx >= inf_tokens_2d.size()) {\n            return \"\";\n        }\n        return inf_tokens_2d[inf_line_idx][inf_token_idx++];\n    };\n    \n    auto inf_read_int = [&]() -> int {\n        string token = inf_read_token();\n        if (token.empty()) {\n            throw runtime_error(\"Input token missing\");\n        }\n        try {\n            return stoi(token);\n        } catch (...) {\n            throw runtime_error(\"Input token not integer\");\n        }\n    };\n    \n    auto inf_read_eoln = [&]() {\n        // Verify no more tokens exist on current line after read\n        if (inf_token_idx < inf_tokens_2d[inf_line_idx].size()) {\n            throw runtime_error(\"Expected end of line\");\n        }\n    };\n\n    // Set up stream positions for expected output (ans) and contestant output (ouf)\n    size_t ans_idx = 0;\n    auto ans_read_token = [&]() -> string {\n        if (ans_idx >= ans_tokens.size()) {\n            throw runtime_error(\"Expected output: unexpected end of file\");\n        }\n        return ans_tokens[ans_idx++];\n    };\n\n    size_t ouf_idx = 0;\n    auto ouf_read_token = [&]() -> string {\n        if (ouf_idx >= ouf_tokens.size()) {\n            throw runtime_error(\"Contestant output: unexpected end of file\");\n        }\n        return ouf_tokens[ouf_idx++];\n    };\n\n    auto ouf_read_int = [&]() -> int {\n        string token = ouf_read_token();\n        try {\n            return stoi(token);\n        } catch (...) {\n            throw runtime_error(\"Contestant output token not integer\");\n        }\n    };\n\n    try {\n        // Read number of test cases\n        int T = inf_read_int();\n        inf_read_eoln();  // Verify end of line after T\n\n        for (int t = 0; t < T; ++t) {\n            // Compare expected vs actual verdict\n            string expected = ans_read_token();\n            string actual = ouf_read_token();\n            if (expected != actual) {\n                return false;\n            }\n\n            // Read grid dimensions from input\n            int n = inf_read_int();\n            int m = inf_read_int();\n\n            if (expected == \"Yes\") {\n                // Read contestant's permutation vectors a and b\n                vector<int> a(n);\n                for (int i = 0; i < n; ++i) {\n                    a[i] = ouf_read_int();\n                    // Read corresponding token from expected output (to advance stream)\n                    ans_read_token();\n                    // Validate range constraint\n                    if (a[i] < 0 || a[i] >= n * m) {\n                        return false;\n                    }\n                }\n\n                vector<int> b(m);\n                for (int i = 0; i < m; ++i) {\n                    b[i] = ouf_read_int();\n                    ans_read_token();\n                    if (b[i] < 0 || b[i] >= n * m) {\n                        return false;\n                    }\n                }\n\n                // Verify the matrix c covers all integers in [0, n*m-1]\n                unordered_map<int, int> vis;\n                for (int i = 0; i < n; ++i) {\n                    for (int j = 0; j < m; ++j) {\n                        long long cij = (1LL * a[i] * b[j]) % (1LL * n * m);\n                        if (vis.find(cij) != vis.end()) {\n                            return false;  // Duplicate found\n                        }\n                        vis[cij] = 1;\n                    }\n                }\n            }\n        }\n\n        // Verify no extra tokens remain in any stream\n        if (inf_read_token() != \"\") return false;\n        if (ans_idx < ans_tokens.size()) return false;\n        if (ouf_idx < ouf_tokens.size()) return false;\n\n        return true;\n    } catch (const exception& e) {\n        return false;  // Any stream error or validation failure\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60563, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to parse integers from a C-string pointer.\n  Advances the pointer past the parsed integer and any leading spaces.\n-----------------------------------------------------------*/\nint fastParseInt(const char* &p) {\n    while (*p == ' ') ++p;\n    int val = 0;\n    while (*p >= '0' && *p <= '9') {\n        val = val * 10 + (*p - '0');\n        ++p;\n    }\n    return val;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by:\n  1. Parsing k from stdin (must be odd integer in [1, 2^31-1])\n  2. Parsing the participant's program from stdout\n  3. Simulating the program for exactly k steps\n  Returns true if validation passes, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);  // Not used but required by template\n\n    // Validate stdin: must contain exactly one line with k\n    if (stdin_lines.size() != 1) {\n        return false;\n    }\n    long long k_val;\n    try {\n        k_val = stoll(stdin_lines[0]);\n        // Check k constraints: 1 <= k <= (1 << 31) - 1 and odd\n        if (k_val < 1 || k_val > (1LL << 31) - 1 || k_val % 2 != 1) {\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n    int k = static_cast<int>(k_val);\n\n    // Validate stdout: first line must be n (1-64), followed by n program lines\n    if (stdout_lines.empty()) {\n        return false;\n    }\n    int n;\n    try {\n        n = stoi(stdout_lines[0]);\n        if (n < 1 || n > 64) {\n            return false;\n        }\n    } catch (...) {\n        return false;\n    }\n    if (stdout_lines.size() != (size_t)(n + 1)) {\n        return false;\n    }\n\n    // Parse program instructions from stdout\n    enum InstrType { HALT, COND };\n    struct Instruction {\n        InstrType type;\n        int a, x, b, y;\n    };\n    vector<Instruction> program(n);\n    for (int i = 0; i < n; ++i) {\n        const string& line = stdout_lines[1 + i];\n        const char* p = line.c_str();\n\n        if (strncmp(p, \"HALT; PUSH \", 11) == 0) {\n            p += 11;\n            int b = fastParseInt(p);\n            while (*p == ' ') ++p;\n            if (strncmp(p, \"GOTO \", 5) != 0) {\n                return false;\n            }\n            p += 5;\n            int y = fastParseInt(p);\n            program[i] = {HALT, 0, 0, b, y};\n        } else if (strncmp(p, \"POP \", 4) == 0) {\n            p += 4;\n            int a = fastParseInt(p);\n            while (*p == ' ') ++p;\n            if (strncmp(p, \"GOTO \", 5) != 0) {\n                return false;\n            }\n            p += 5;\n            int x = fastParseInt(p);\n            while (*p == ' ') ++p;\n            if (*p != ';') {\n                return false;\n            }\n            ++p;\n            while (*p == ' ') ++p;\n            if (strncmp(p, \"PUSH \", 5) != 0) {\n                return false;\n            }\n            p += 5;\n            int b = fastParseInt(p);\n            while (*p == ' ') ++p;\n            if (strncmp(p, \"GOTO \", 5) != 0) {\n                return false;\n            }\n            p += 5;\n            int y = fastParseInt(p);\n            program[i] = {COND, a, x, b, y};\n        } else {\n            return false;\n        }\n    }\n\n    // Simulate the program for exactly k steps\n    stack<int> stk;\n    int ip = 1;\n    int steps = 0;\n\n    while (true) {\n        // Check instruction pointer validity\n        if (ip < 1 || ip > n) {\n            return false;\n        }\n\n        const Instruction& inst = program[ip - 1];\n        if (inst.type == HALT) {\n            stk.push(inst.b);\n            ip = inst.y;\n        } else {\n            if (!stk.empty() && stk.top() (inst.a)) {\n                stk.pop();\n                ip = inst.x;\n            } else {\n                stk.push(inst.b);\n                ip = inst.y;\n            }\n        }\n\n        steps++;\n        if (steps > k) {\n            return false;\n        }\n        if (steps == k) {\n            break;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60577, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt)\n  line-by-line. Returns true only if both files have identical line count and\n  each corresponding line matches exactly (after whitespace trimming).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Verify both output files have same number of lines\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line character-for-character\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60569, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);\n    vector<string> answer_lines = read_file(answer_path);\n\n    // Tokenize all input streams for easier processing\n    auto tokenize = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    vector<string> inf_tokens = tokenize(stdin_lines);   // Problem input (inf)\n    vector<string> ans_tokens = tokenize(stdout_lines);  // Jury's output (ans)\n    vector<string> ouf_tokens = tokenize(answer_lines);  // Contestant's output (ouf)\n\n    size_t inf_idx = 0, ans_idx = 0, ouf_idx = 0;\n\n    // Read number of test cases T\n    if (inf_idx >= inf_tokens.size()) return false;\n    int T;\n    try {\n        T = stoi(inf_tokens[inf_idx++]);\n    } catch (...) {\n        return false;\n    }\n    if (T < 1 || T > 100000) return false;\n\n    for (int tc = 1; tc <= T; ++tc) {\n        // Read n (number of nodes)\n        if (inf_idx >= inf_tokens.size()) return false;\n        int n;\n        try {\n            n = stoi(inf_tokens[inf_idx++]);\n        } catch (...) {\n            return false;\n        }\n        if (n < 2 || n > 300000) return false;\n\n        // Build tree from input edges\n        vector<vector<pair<int, int>>> adj(n + 1);\n        vector<pair<int, int>> treeEdges;\n        for (int i = 0; i < n - 1; ++i) {\n            if (inf_idx + 1 >= inf_tokens.size()) return false;\n            int u, v;\n            try {\n                u = stoi(inf_tokens[inf_idx++]);\n                v = stoi(inf_tokens[inf_idx++]);\n            } catch (...) {\n                return false;\n            }\n            if (u < 1 || u > n || v < 1 || v > n) return false;\n            adj[u].emplace_back(v, i);\n            adj[v].emplace_back(u, i);\n            treeEdges.emplace_back(min(u, v), max(u, v));\n        }\n        sort(all(treeEdges));\n\n        // Read jury's solution (k value)\n        if (ans_idx >= ans_tokens.size()) return false;\n        int jury_k;\n        try {\n            jury_k = stoi(ans_tokens[ans_idx++]);\n        } catch (...) {\n            return false;\n        }\n        if (jury_k < -1 || jury_k > n) return false;\n\n        // Case 1: Jury expects no solution (k = -1)\n        if (jury_k == -1) {\n            if (ouf_idx >= ouf_tokens.size()) return false;\n            int k;\n            try {\n                k = stoi(ouf_tokens[ouf_idx++]);\n            } catch (...) {\n                return false;\n            }\n            if (k != -1) return false;\n            continue;\n        }\n\n        // Case 2: Jury provides a valid solution - read k edges from jury's output\n        for (int i = 0; i < jury_k; ++i) {\n            if (ans_idx + 1 >= ans_tokens.size()) return false;\n            int x, y;\n            try {\n                x = stoi(ans_tokens[ans_idx++]);\n                y = stoi(ans_tokens[ans_idx++]);\n            } catch (...) {\n                return false;\n            }\n            if (x < 1 || x > n || y < 1 || y > n) return false;\n        }\n\n        // Check contestant's output for this test case\n        if (ouf_idx >= ouf_tokens.size()) return false;\n        int k;\n        try {\n            k = stoi(ouf_tokens[ouf_idx++]);\n        } catch (...) {\n            return false;\n        }\n        if (k == -1) return false;  // Expected solution but got -1\n        if (k < 0 || k > n) return false;\n\n        set<pair<int, int>> addedSet;\n        vector<pair<int, int>> added;\n        for (int i = 0; i < k; ++i) {\n            if (ouf_idx + 1 >= ouf_tokens.size()) return false;\n            int x, y;\n            try {\n                x = stoi(ouf_tokens[ouf_idx++]);\n                y = stoi(ouf_tokens[ouf_idx++]);\n            } catch (...) {\n                return false;\n            }\n            if (x < 1 || x > n || y < 1 || y > n) return false;\n            if (x == y) return false;  // Self-loop\n            auto e = (x < y) ? make_pair(x, y) : make_pair(y, x);\n            if (!addedSet.insert(e).second) return false;  // Duplicate edge\n            if (binary_search(all(treeEdges), e)) return false;  // Edge exists in tree\n            added.emplace_back(x, y);\n        }\n\n        // Build LCA structure for cycle validation\n        int LOG = 1;\n        while ((1 << LOG) <= n) ++LOG;\n        vector<vector<int>> up(LOG, vector<int>(n + 1));\n        vector<int> parent(n + 1), depth(n + 1);\n        queue<int> q;\n        depth[1] = 0;\n        parent[1] = 1;\n        q.push(1);\n        vector<char> seen(n + 1, 0);\n        seen[1] = 1;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            up[0][u] = parent[u];\n            for (auto& pr : adj[u]) {\n                int v = pr.first;\n                if (!seen[v]) {\n                    seen[v] = 1;\n                    depth[v] = depth[u] + 1;\n                    parent[v] = u;\n                    q.push(v);\n                }\n            }\n        }\n\n        // Precompute binary lifting table\n        for (int j = 1; j < LOG; ++j)\n            for (int i = 1; i <= n; ++i)\n                up[j][i] = up[j - 1][up[j - 1][i]];\n\n        // LCA helper function\n        auto lca = [&](int a, int b) {\n            if (depth[a] < depth[b]) swap(a, b);\n            int diff = depth[a] - depth[b];\n            for (int j = 0; j < LOG; ++j)\n                if (diff & (1 << j)) a = up[j][a];\n            if (a == b) return a;\n            for (int j = LOG - 1; j >= 0; --j)\n                if (up[j][a] != up[j][b]) {\n                    a = up[j][a];\n                    b = up[j][b];\n                }\n            return parent[a];\n        };\n\n        // Count edge coverage using difference array technique\n        vector<long long> cnt(n + 1, 0);\n        for (auto& e : added) {\n            cnt[e.first] += 1;\n            cnt[e.second] += 1;\n            cnt[lca(e.first, e.second)] -= 2;\n        }\n\n        // Process nodes in decreasing depth order to accumulate counts\n        vector<int> order(n);\n        iota(all(order), 1);\n        sort(all(order), [&](int a, int b) {\n            return depth[a] > depth[b];\n        });\n        for (int v : order) {\n            if (v == 1) break;  // Skip root\n            int p = parent[v];\n            if (cnt[v] != 1) return false;  // Each tree edge must be covered exactly once\n            cnt[p] += cnt[v];\n        }\n    }\n\n    // Ensure no extra tokens remain in any stream after all test cases\n    return (ans_idx == ans_tokens.size() && ouf_idx == ouf_tokens.size());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60578, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing participant's output against\n  the correct answer for each test case.\n  Reads the number of test cases 't' from stdin.txt.\n  For each of the 't' lines, checks if the correct answer (stdout.txt)\n  matches the participant's output (answer.txt).\n  Returns true if all match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if any file reading failed\n    if (stdin_lines.empty()) {\n        cerr << \"Failed to read \" << stdin_path << '\\n';\n        return false;\n    }\n    if (stdout_lines.empty()) {\n        cerr << \"Failed to read \" << stdout_path << '\\n';\n        return false;\n    }\n    if (participant_lines.empty()) {\n        cerr << \"Failed to read \" << answer_path << '\\n';\n        return false;\n    }\n\n    // Parse t from first line of stdin\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        cerr << \"Invalid value for t in \" << stdin_path << '\\n';\n        return false;\n    }\n\n    // Ensure there are enough lines in output files\n    if (static_cast<int>(stdout_lines.size()) < t || \n        static_cast<int>(participant_lines.size()) < t) {\n        cerr << \"Output files have insufficient lines for t=\" << t << '\\n';\n        return false;\n    }\n\n    for (int i = 0; i < t; i++) {\n        try {\n            ll a = stoll(stdout_lines[i]);\n            ll b = stoll(participant_lines[i]);\n            if (a != b) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60592, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by checking that the participant's output\n  (answer_path) matches the correct output (stdout_path) for each\n  of the T test cases specified in the input (stdin_path).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if any file reading failed\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse the number of test cases T from the first line of stdin\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false; // Invalid integer for T\n    }\n\n    // Ensure there are enough lines in stdout and participant's output\n    if (static_cast<int>(stdout_lines.size()) < T || \n        static_cast<int>(participant_lines.size()) < T) {\n        return false;\n    }\n\n    // Compare each test case\n    for (int i = 0; i < T; ++i) {\n        try {\n            int expected = stoi(stdout_lines[i]);\n            int actual = stoi(participant_lines[i]);\n            if (actual != expected) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60586, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing tokens in correct answer \n  (answer.txt) and contestant's output (stdout.txt) token-by-token.\n  Ignores whitespace differences and checks for exact token matches.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Unused (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Contestant's output\n    vector<string> answer_lines      = read_file(answer_path);  // Correct answer\n\n    // Extract all tokens from correct answer\n    vector<string> correct_tokens;\n    for (const string& line : answer_lines) {\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Extract all tokens from contestant's output\n    vector<string> contestant_tokens;\n    for (const string& line : stdout_lines) {\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            contestant_tokens.push_back(token);\n        }\n    }\n\n    // Check token count matches\n    if (correct_tokens.size() != contestant_tokens.size()) {\n        return false;\n    }\n\n    // Verify each token matches exactly\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != contestant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60562, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Extract tokens from vector of lines by splitting each line\n  on whitespace. Returns a flat vector of all tokens in order.\n-----------------------------------------------------------*/\nvector<string> extract_tokens(const vector<string>& lines)\n{\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path)\n  as a sequence of tokens. The input file (stdin_path) is read but unused.\n  \n  Comparison rules:\n    - Only the first N tokens are checked (where N = number of tokens in correct output)\n    - Participant must have at least N tokens\n    - Tokens must match exactly (case-sensitive, whitespace-insensitive due to tokenization)\n  \n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin unused for comparison)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);   // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);   // Participant output (ouf)\n\n    // Convert line-based content to token sequences\n    vector<string> correct_tokens     = extract_tokens(correct_lines);\n    vector<string> participant_tokens = extract_tokens(participant_lines);\n\n    // Check if participant has fewer tokens than required\n    if (participant_tokens.size() < correct_tokens.size()) {\n        return false;\n    }\n\n    // Verify first N tokens match (N = correct_tokens.size())\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (participant_tokens[i] != correct_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60581, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare jury's expected answer (stdout.txt) against \n  contestant's output (answer.txt). Both files should contain \n  exactly one integer. Return true only if integers match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> jury_answer_lines = read_file(stdout_path);  // Corresponds to 'ans' in original\n    vector<string> contestant_lines  = read_file(answer_path);  // Corresponds to 'ouf' in original\n\n    // Verify both answer files contain exactly one line\n    if (jury_answer_lines.size() != 1 || contestant_lines.size() != 1) {\n        return false;\n    }\n\n    try {\n        // Convert trimmed lines to integers\n        int jury_value      = stoi(jury_answer_lines[0]);\n        int contestant_value = stoi(contestant_lines[0]);\n        \n        // Return true only if values match\n        return (jury_value == contestant_value);\n    } catch (...) {\n        // Handle conversion errors (non-integer content)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60571, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Check if 'abbreviation' is a valid abbreviation for 'phrase'.\n  A valid abbreviation is formed by concatenating prefixes of each word\n  in the phrase (at least one character per word).\n-----------------------------------------------------------*/\nbool isValidAbbreviation(const string& phrase, const string& abbreviation)\n{\n    // Split phrase into words\n    vector<string> words;\n    stringstream ss(phrase);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    // Create DP table initialized to -1 (uncomputed)\n    int n = words.size();\n    int m = abbreviation.size();\n    vector<vector<int>> dp(n, vector<int>(m, -1));\n\n    // Helper function for recursive DP with memoization\n    function<bool(int, int)> dpf = [&](int i, int j) -> bool {\n        if (i == n) return (j == m);\n        if (j == m) return false;\n\n        int& res = dp[i][j];\n        if (res != -1) return res;\n        res = false;\n\n        // Try all possible prefix lengths for current word\n        for (int len = 1; len <= static_cast<int>(words[i].size()); ++len) {\n            if (j + len > m) break;\n            if (words[i].substr(0, len) == abbreviation.substr(j, len) && \n                dpf(i + 1, j + len)) {\n                res = true;\n                break;\n            }\n        }\n        return res;\n    };\n\n    return dpf(0, 0);\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against the jury's answer.\n  Checks:\n    - If jury says \"no solution\", contestant must too, and vice versa.\n    - Contestant's abbreviations must be valid and unique.\n    - Total length of abbreviations must match jury's.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check input file structure\n    if (stdin_lines.empty()) return false;\n    int n = stoi(stdin_lines[0]);\n    if (static_cast<int>(stdin_lines.size()) < n + 1) return false;\n    if (static_cast<int>(answer_lines.size()) != n || \n        static_cast<int>(stdout_lines.size()) != n) return false;\n\n    // Extract phrases from stdin\n    vector<string> phrases;\n    for (int i = 1; i <= n; ++i) {\n        phrases.push_back(stdin_lines[i]);\n    }\n\n    // Handle \"no solution\" cases\n    bool juryNoSolution = (answer_lines[0] == \"no solution\");\n    bool contNoSolution = (stdout_lines[0] == \"no solution\");\n    if (juryNoSolution != contNoSolution) return false;\n    if (juryNoSolution && contNoSolution) return true;\n\n    // Validate all abbreviations\n    set<string> used;\n    int contLen = 0, juryLen = 0;\n    for (int i = 0; i < n; ++i) {\n        const string& x = stdout_lines[i];\n        const string& y = answer_lines[i];\n\n        // Check for duplicate abbreviations\n        if (!used.insert(x).second) return false;\n        \n        // Verify abbreviation validity\n        if (!isValidAbbreviation(phrases[i], x)) return false;\n        \n        contLen += x.size();\n        juryLen += y.size();\n    }\n\n    // Final length comparison\n    return (contLen == juryLen);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60588, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer line-by-line.\n  Each line should contain exactly one integer. Returns true only\n  if all integers match and line counts are equal.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input test data (not used in comparison)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Verify both files have same number of lines\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line as integer values\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            int correct = stoi(stdout_lines[i]);\n            int output  = stoi(participant_lines[i]);\n            \n            if (correct != output) {\n                return false;\n            }\n        } catch (...) {\n            // Handle non-integer values or conversion errors\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60608, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two double values (one from jury's answer in stdout.txt \n  and one from participant's output in answer.txt), allowing maximum \n  absolute or relative error of EPS (1E-9). \n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path); // Unused for this problem\n    vector<string> jury_lines        = read_file(stdout_path); // Corresponds to ans (jury's answer)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to ouf (participant's output)\n\n    // Find first non-empty line in jury's answer\n    size_t i = 0;\n    while (i < jury_lines.size() && jury_lines[i].empty()) i++;\n    if (i >= jury_lines.size()) return false;\n    \n    // Find first non-empty line in participant's output\n    size_t j = 0;\n    while (j < participant_lines.size() && participant_lines[j].empty()) j++;\n    if (j >= participant_lines.size()) return false;\n\n    try {\n        double jury_val = stod(jury_lines[i]);\n        double participant_val = stod(participant_lines[j]);\n        \n        double absolute = fabs(jury_val - participant_val);\n        // Check absolute error first\n        if (absolute <= EPS) {\n            return true;\n        }\n        \n        // Calculate relative error (avoid division by zero)\n        double maxVal = max(fabs(jury_val), fabs(participant_val));\n        double relative = absolute / maxVal;\n        \n        return relative <= EPS;\n    } catch (...) {\n        // Conversion error (non-numeric input)\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60589, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer token-by-token\n  as 64-bit integers. Returns true if all tokens match exactly,\n  false otherwise (including format errors or mismatched counts).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> jury_lines        = read_file(stdout_path);  // Corresponds to 'ans' in original\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' in original\n\n    // Tokenize jury's expected output\n    vector<string> jury_tokens;\n    for (const string& line : jury_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            jury_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize participant's output\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Check token count mismatch\n    if (jury_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token as 64-bit integers\n    for (size_t i = 0; i < jury_tokens.size(); ++i) {\n        try {\n            size_t pos_j, pos_p;\n            ll jury_val = stoll(jury_tokens[i], &pos_j);\n            ll part_val = stoll(participant_tokens[i], &pos_p);\n\n            // Verify entire token was consumed during conversion\n            if (pos_j != jury_tokens[i].size() || pos_p != participant_tokens[i].size()) {\n                return false;\n            }\n            if (jury_val != part_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;  // Handle conversion errors (invalid numbers)\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60583, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected \n  output (stdout_path) line-by-line. Input file (stdin_path) \n  is unused in comparison. Returns true only if:\n  1. Participant has >= expected line count\n  2. All corresponding lines (after stripping) match exactly\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> expected_lines = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Must have at least as many lines as expected\n    if (participant_lines.size() < expected_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches expected output\n    for (size_t i = 0; i < expected_lines.size(); ++i) {\n        if (expected_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60587, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (answer_path) against jury's output (stdout_path).\n  Input file (stdin_path) is read but not used in this validator.\n  Returns true if all answers match, false otherwise with error details on cerr.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected answers\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's submitted answers\n\n    // Parse jury's answers from trimmed lines (skipping empty lines)\n    vector<ll> jury_answers;\n    for (const auto& line : stdout_lines) {\n        if (!line.empty()) {\n            jury_answers.push_back(stoll(line));\n        }\n    }\n\n    // Parse contestant's answers from trimmed lines (skipping empty lines)\n    vector<ll> contestant_answers;\n    for (const auto& line : participant_lines) {\n        if (!line.empty()) {\n            contestant_answers.push_back(stoll(line));\n        }\n    }\n\n    // Check if number of answers matches\n    if (jury_answers.size() != contestant_answers.size()) {\n        cerr << \"Wrong number of answers: expected \" << jury_answers.size() \n             << \", found \" << contestant_answers.size() << '\\n';\n        return false;\n    }\n\n    // Verify each answer matches\n    for (int i = 0; i < (int)jury_answers.size(); i++) {\n        if (contestant_answers[i] != jury_answers[i]) {\n            cerr << \"Answer \" << i + 1 << \": expected \" << jury_answers[i] \n                 << \", found \" << contestant_answers[i] << '\\n';\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60572, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_path) against jury's answer (answer_path).\n  Both files should contain sequences of integers separated by whitespace.\n  Returns true only if both sequences are identical in value and length.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Parse all tokens from answer file into long long values\n    vector<long long> ans_numbers;\n    for (const string& line : answer_lines) {\n        if (line.empty()) continue;\n        \n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                // Convert token to number with full validation\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    return false;  // Invalid characters in number\n                ans_numbers.push_back(num);\n            } catch (...) {\n                return false;  // Conversion failed\n            }\n        }\n    }\n\n    // Parse all tokens from participant's output file\n    vector<long long> ouf_numbers;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        \n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                size_t pos;\n                long long num = stoll(token, &pos);\n                if (pos != token.size()) \n                    return false;\n                ouf_numbers.push_back(num);\n            } catch (...) {\n                return false;\n            }\n        }\n    }\n\n    // Sequences must match exactly in both length and values\n    return (ans_numbers == ouf_numbers);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60590, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing expected output (stdout.txt) with participant's output\n  (answer.txt), using stdin.txt to determine the number of test cases.\n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> expected_lines = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if stdin has valid test case count\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases (t) from first line of stdin\n    istringstream iss(stdin_lines[0]);\n    int t;\n    if (!(iss >> t) || t < 0) {\n        return false;\n    }\n\n    // Verify sufficient lines in expected and participant outputs\n    if (expected_lines.size() < (size_t)t || participant_lines.size() < (size_t)t) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (int i = 0; i < t; i++) {\n        // Parse expected value\n        istringstream iss_exp(expected_lines[i]);\n        int expected_val;\n        if (!(iss_exp >> expected_val)) {\n            return false;\n        }\n\n        // Parse participant's value\n        istringstream iss_part(participant_lines[i]);\n        int participant_val;\n        if (!(iss_part >> participant_val)) {\n            return false;\n        }\n\n        if (expected_val != participant_val) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60604, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (lang == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to uppercase for case-insensitive comparison.\n-----------------------------------------------------------*/\nstring to_upper(const string& s) {\n    string res = s;\n    for (char& c : res) c = toupper(c);\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected answer:\n  - Each token must be \"YES\" or \"NO\" (case-insensitive)\n  - Participant's tokens must exactly match expected tokens\n  - Both files must have identical token count\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    const string YES = \"YES\";\n    const string NO = \"NO\";\n\n    vector<string> stdin_lines       = read_file(stdin_path);   // Input (unused in this checker)\n    vector<string> expected_lines    = read_file(stdout_path);  // Expected answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    int index = 0;\n    int yesCount = 0, noCount = 0;\n\n    // Process tokens while both files have content\n    while (index < expected_lines.size() && index < participant_lines.size()) {\n        string ja = to_upper(expected_lines[index]);  // Expected token\n        string pa = to_upper(participant_lines[index]); // Participant's token\n\n        // Validate expected token is valid\n        if (ja != YES && ja != NO) {\n            return false;\n        }\n\n        // Validate participant token and count responses\n        if (pa == YES) {\n            yesCount++;\n        } else if (pa == NO) {\n            noCount++;\n        } else {\n            return false;\n        }\n\n        // Check token match\n        if (ja != pa) {\n            return false;\n        }\n\n        index++;\n    }\n\n    // Check for extra tokens in expected answer\n    if (expected_lines.size() > index) {\n        return false;\n    }\n\n    // Check for extra tokens in participant's output\n    if (participant_lines.size() > index) {\n        return false;\n    }\n\n    // All validations passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60595, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout.txt) against correct answers (answer.txt)\n  for 't' test cases specified in stdin.txt. Each test case's answer must be on\n  a separate line (whitespace-trimmed). Returns true only if all answers match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path);  // Participant's output\n    vector<string> answer_lines = read_file(answer_path);  // Correct answers\n\n    // Verify all files were successfully read\n    if (stdin_lines.empty() || stdout_lines.empty() || answer_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases from stdin's first line\n    int t;\n    try {\n        t = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;  // Invalid integer format\n    }\n    if (t < 0) {\n        return false;  // Negative test case count invalid\n    }\n\n    // Ensure sufficient lines exist in both answer and output files\n    if (static_cast<int>(answer_lines.size()) < t || \n        static_cast<int>(stdout_lines.size()) < t) {\n        return false;\n    }\n\n    // Compare each test case's answer (line-by-line)\n    for (int i = 0; i < t; ++i) {\n        if (answer_lines[i] != stdout_lines[i]) {\n            return false;  // Mismatch found\n        }\n    }\n    return true;  // All answers match\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60610, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output by comparing against the\n  expected output with tolerance EPS = 1e-6. The stdin file\n  provides problem parameters (n, k) and the array (skipped).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if stdin has sufficient lines (needs at least n/k line + array line)\n    if (stdin_lines.size() < 2) {\n        return false;\n    }\n\n    // Parse n and k from first line of stdin\n    istringstream iss(stdin_lines[0]);\n    int n, k;\n    if (!(iss >> n >> k)) {\n        return false;\n    }\n\n    // Skip the array line (second line in stdin) as per original logic\n\n    // Verify expected and participant outputs have at least n values\n    if (stdout_lines.size() < n || participant_lines.size() < n) {\n        return false;\n    }\n\n    const double EPS = 1e-6;\n    for (int i = 0; i < n; i++) {\n        try {\n            double expected_val = stod(stdout_lines[i]);\n            double actual_val   = stod(participant_lines[i]);\n            if (abs(expected_val - actual_val) > EPS) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60594, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Normalize the string by converting all characters to lowercase.\n-----------------------------------------------------------*/\nstring normalize(const string& s) {\n    string res = s;\n    for (char& c : res) c = tolower(c);\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's output against the correct answer.\n  Compares all tokens (case-insensitive) between correct answer\n  (stdout.txt) and participant's output (answer.txt).\n  Returns true if all tokens match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Split all lines into tokens for correct answer\n    vector<string> correct_tokens;\n    for (const string& line : correct_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Split all lines into tokens for participant's output\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Check if token counts match\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token (case-insensitive)\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (normalize(correct_tokens[i]) != normalize(participant_tokens[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60596, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert a string to uppercase.\n-----------------------------------------------------------*/\nstring toUpper(string s) {\n    for (char& c : s) {\n        c = toupper(static_cast<unsigned char>(c));\n    }\n    return s;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output against\n  expected output token-by-token (case-insensitive).\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Note: stdin_path corresponds to test input (inf in original)\n    //       stdout_path corresponds to expected output (ans in original)\n    //       answer_path corresponds to participant's output (ouf in original)\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> ans_lines    = read_file(stdout_path);  // Expected output (judge's answer)\n    vector<string> ouf_lines    = read_file(answer_path);  // Participant's output\n\n    // Convert lines to tokens for expected output (ans)\n    vector<string> ans_tokens;\n    for (const string& line : ans_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Convert lines to tokens for participant's output (ouf)\n    vector<string> ouf_tokens;\n    for (const string& line : ouf_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    const string YES = \"YES\";\n    const string NO = \"NO\";\n    int index = 0;\n    int yesCount = 0;\n    int noCount = 0;\n    string pa;  // Current participant token\n\n    // Process tokens until one stream ends\n    while (index < ans_tokens.size() && index < ouf_tokens.size()) {\n        string ja = toUpper(ans_tokens[index]);  // Judge's token in uppercase\n        pa = toUpper(ouf_tokens[index]);         // Participant's token in uppercase\n\n        // Validate judge's token is valid (should always be YES/NO)\n        if (ja != YES && ja != NO) {\n            return false;  // Invalid token in expected output\n        }\n\n        // Count participant's valid tokens\n        if (pa == YES) {\n            yesCount++;\n        } else if (pa == NO) {\n            noCount++;\n        } else {\n            return false;  // Invalid token in participant's output (PE)\n        }\n\n        // Check token matches expected\n        if (ja != pa) {\n            return false;  // Wrong answer\n        }\n\n        index++;\n    }\n\n    // Check for extra tokens in expected output\n    if (ans_tokens.size() > index) {\n        return false;  // Expected output longer than participant's\n    }\n\n    // Check for extra tokens in participant's output\n    if (ouf_tokens.size() > index) {\n        return false;  // Participant's output longer than expected\n    }\n\n    // All checks passed\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60593, "checker": "#include <bits/stdc++.h>\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate contestant's solution by:\n  1. Reading test case from stdin_path (problem input)\n  2. Computing expected answer from test case\n  3. Comparing against contestant's output from answer_path\n  Note: stdout_path (model answer) is ignored since we compute expected answer\n  Returns true if all test cases match within tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read and tokenize test case (stdin_path)\n    vector<string> stdin_lines = read_file(stdin_path);\n    vector<ll> A;\n    for (string& line : stdin_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        ll x;\n        while (ss >> x) {\n            A.push_back(x);\n        }\n    }\n\n    // Read and tokenize contestant's output (answer_path)\n    vector<string> out_lines = read_file(answer_path);\n    vector<double> contestant_answers;\n    for (string& line : out_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        double x;\n        while (ss >> x) {\n            contestant_answers.push_back(x);\n        }\n    }\n\n    // Parse test case: first try multi-case format (with T)\n    struct TestCase {\n        int n, k;\n        vector<pair<ll, ll>> pts;\n    };\n    vector<TestCase> cases;\n    bool multi_ok = true;\n    size_t idx = 0;\n\n    if (A.empty()) {\n        multi_ok = false;\n    } else {\n        ll T = A[0];\n        if (T < 1 || T > 10000) {\n            multi_ok = false;\n        } else {\n            idx = 1;\n            cases.reserve(static_cast<size_t>(T));\n            ll sumN = 0;\n            for (int tc = 0; tc < T; tc++) {\n                if (idx + 1 >= A.size()) { \n                    multi_ok = false; \n                    break; \n                }\n                ll n = A[idx], k = A[idx + 1];\n                if (n < 1 || n > 200000 || k < 1 || k > n) {\n                    multi_ok = false; \n                    break;\n                }\n                idx += 2;\n                if (idx + 2 * n > A.size()) { \n                    multi_ok = false; \n                    break; \n                }\n\n                TestCase C;\n                C.n = static_cast<int>(n);\n                C.k = static_cast<int>(k);\n                C.pts.reserve(n);\n                for (int i = 0; i < n; i++) {\n                    ll xi = A[idx++];\n                    ll yi = A[idx++];\n                    C.pts.emplace_back(xi, yi);\n                }\n                sumN += n;\n                if (sumN > 200000) { \n                    multi_ok = false; \n                    break; \n                }\n                cases.push_back(move(C));\n            }\n            if (multi_ok && idx != A.size()) {\n                // Extra data found after valid multi-case input\n                multi_ok = false;\n            }\n        }\n    }\n\n    // Fallback to single-test case format if multi-case failed\n    if (!multi_ok) {\n        if (A.size() < 3) {\n            return false;\n        }\n        ll n = A[0], k = A[1];\n        if (n < 1 || n > 200000 || k < 1 || k > n) {\n            return false;\n        }\n        if (A.size() != static_cast<size_t>(2 + 2 * n)) {\n            return false;\n        }\n        TestCase C;\n        C.n = static_cast<int>(n);\n        C.k = static_cast<int>(k);\n        C.pts.reserve(n);\n        idx = 2;\n        for (int i = 0; i < n; i++) {\n            ll xi = A[idx++];\n            ll yi = A[idx++];\n            C.pts.emplace_back(xi, yi);\n        }\n        cases.clear();\n        cases.push_back(move(C));\n    }\n\n    // Verify contestant provided exactly one answer per test case\n    if (contestant_answers.size() != cases.size()) {\n        return false;\n    }\n\n    // Validate each test case\n    const double TWO_PI = 2 * M_PI;\n    for (int tc = 0; tc < static_cast<int>(cases.size()); tc++) {\n        auto& C = cases[tc];\n        int n = C.n, k = C.k;\n\n        // Compute angles for all points\n        vector<double> ang(2 * n);\n        for (int i = 0; i < n; i++) {\n            double a = atan2(static_cast<double>(C.pts[i].second),\n                             static_cast<double>(C.pts[i].first));\n            if (a < 0) a += TWO_PI;\n            ang[i] = a;\n        }\n        sort(ang.begin(), ang.begin() + n);\n        for (int i = 0; i < n; i++) {\n            ang[i + n] = ang[i] + TWO_PI;\n        }\n\n        // Find minimal span covering (n - k + 1) points\n        int m = n - k + 1;\n        double bestSpan = TWO_PI;\n        for (int i = 0; i + m - 1 < 2 * n; i++) {\n            bestSpan = min(bestSpan,\n                           ang[i + m - 1] - ang[i]);\n        }\n        double expected = TWO_PI - bestSpan;\n\n        // Compare with contestant's answer\n        double found = contestant_answers[tc];\n        if (!isfinite(found)) {\n            return false;\n        }\n        double abs_err = fabs(found - expected);\n        double rel_err = abs_err / max(1.0, fabs(expected));\n        if (abs_err > 1e-6 && rel_err > 1e-6) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60579, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Tokenize a vector of lines into individual tokens by splitting\n  on whitespace. Each line is processed, and tokens are collected\n  into a single vector.\n-----------------------------------------------------------*/\nvector<string> tokenize(const vector<string>& lines) {\n    vector<string> tokens;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            tokens.push_back(token);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct output for \n  multiple test cases of signed integer comparison.\n  \n  Steps:\n  1. Parse number of test cases 't' from stdin input\n  2. For each test case, compare corresponding integers from \n     correct output (stdout) and participant's output (answer)\n  3. Verify both outputs contain at least 't' integers\n  4. Ensure correct output has exactly 't' tokens while \n     participant's output has no extra tokens\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert all input files into token streams\n    vector<string> stdin_tokens  = tokenize(stdin_lines);\n    vector<string> stdout_tokens = tokenize(stdout_lines);\n    vector<string> answer_tokens = tokenize(participant_lines);\n\n    // Validate test case count exists and is positive\n    if (stdin_tokens.empty()) return false;\n    int t;\n    try {\n        t = stoi(stdin_tokens[0]);\n    } catch (...) {\n        return false;\n    }\n    if (t < 0) return false;\n\n    // Check sufficient tokens exist in both outputs\n    if (stdout_tokens.size() < t || answer_tokens.size() < t) {\n        return false;\n    }\n\n    // Compare each integer pair in the test cases\n    for (int i = 0; i < t; i++) {\n        try {\n            int ja = stoi(stdout_tokens[i]);   // Correct value\n            int pa = stoi(answer_tokens[i]);   // Participant's value\n            if (ja != pa) return false;\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Verify no extra output tokens exist where not allowed\n    if (stdout_tokens.size() == t && answer_tokens.size() > t) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60597, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution for the \"Good Matrix\" problem.\n  The input file (stdin_path) contains T test cases, each with dimensions n x m.\n  The participant's output (answer_path) must contain for each test case:\n    1. A verdict token \"Yes\" (case-insensitive)\n    2. An n x m matrix of integers where:\n        - All values are distinct and in the range [1, n*m]\n        - All adjacent horizontal/vertical sums are distinct\n  Returns true if all conditions are satisfied, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Ignored (not used in this checker)\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Build input stream from stdin_lines (test data)\n    string input_str;\n    for (string& line : stdin_lines) {\n        if (!line.empty()) {\n            input_str += line;\n            input_str += ' ';  // Separate lines with space for tokenization\n        }\n    }\n    istringstream inf_stream(input_str);\n\n    // Build output stream from participant_lines\n    string output_str;\n    for (string& line : participant_lines) {\n        if (!line.empty()) {\n            output_str += line;\n            output_str += ' ';\n        }\n    }\n    istringstream ouf_stream(output_str);\n\n    // Read number of test cases\n    int T;\n    if (!(inf_stream >> T) || T < 0) {\n        return false;\n    }\n\n    for (int tc = 1; tc <= T; tc++) {\n        int n, m;\n        if (!(inf_stream >> n >> m)) {\n            return false;\n        }\n        int N = n * m;\n\n        // Read and validate verdict token\n        string verdict;\n        if (!(ouf_stream >> verdict)) {\n            return false;\n        }\n        string low;\n        for (char c : verdict) {\n            low += tolower(c);\n        }\n        if (low != \"yes\") {\n            return false;\n        }\n\n        // Read matrix values and validate basic properties\n        vector<int> A(N);\n        vector<char> seen(N + 1, 0);  // 1-indexed presence tracker\n\n        for (int i = 0; i < N; i++) {\n            if (!(ouf_stream >> A[i])) {\n                return false;\n            }\n            // Check value range\n            if (A[i] < 1 || A[i] > N) {\n                return false;\n            }\n            // Check duplicates\n            if (seen[A[i]]) {\n                return false;\n            }\n            seen[A[i]] = 1;\n        }\n\n        // Verify all values 1..N are present\n        for (int x = 1; x <= N; x++) {\n            if (!seen[x]) {\n                return false;\n            }\n        }\n\n        // Check adjacent sums for uniqueness\n        vector<char> sumSeen(2 * N + 5, 0);  // Track seen sums (up to 2*N)\n        auto at = [&](int i, int j) -> int {\n            return A[i * m + j];\n        };\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                // Check horizontal neighbor\n                if (j + 1 < m) {\n                    int s = at(i, j) + at(i, j + 1);\n                    if (sumSeen[s]) {\n                        return false;\n                    }\n                    sumSeen[s] = 1;\n                }\n                // Check vertical neighbor\n                if (i + 1 < n) {\n                    int s = at(i, j) + at(i + 1, j);\n                    if (sumSeen[s]) {\n                        return false;\n                    }\n                    sumSeen[s] = 1;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60623, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all tokens from the file into a vector<string>.\n  Each token is a sequence of non-whitespace characters.\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> tokens;\n    string token;\n\n    while (fin >> token) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare correct output (stdout_path) and participant's output (answer_path)\n  as sequences of tokens. Each token is converted to long long and verified.\n  Return true if all tokens match and both files have identical token counts.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    (void)stdin_path;  // Input file not used in this checker\n\n    vector<string> correct_tokens  = read_file(stdout_path);\n    vector<string> participant_tokens = read_file(answer_path);\n\n    // Determine the minimum token count to compare\n    size_t n = min(correct_tokens.size(), participant_tokens.size());\n\n    // Compare each token as long long\n    for (size_t i = 0; i < n; i++) {\n        try {\n            long long ja = stoll(correct_tokens[i]);\n            long long pa = stoll(participant_tokens[i]);\n            if (ja != pa) \n                return false;\n        } catch (...) {\n            return false;  // Invalid number format\n        }\n    }\n\n    // Check if correct output has extra tokens\n    if (correct_tokens.size() > n)\n        return false;\n\n    // Check if participant output has extra tokens\n    if (participant_tokens.size() > n)\n        return false;\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60607, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  by reading a single integer from each file. Returns true only if:\n  1. Both files contain exactly one line\n  2. Both lines represent valid integers (no extra characters)\n  3. The integers are numerically equal\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines   = read_file(stdin_path);   // Input data (unused in this checker)\n    vector<string> correct_lines = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> ouf_lines     = read_file(answer_path);  // Participant's output (ouf)\n\n    // Verify both outputs contain exactly one line\n    if (correct_lines.size() != 1 || ouf_lines.size() != 1) {\n        return false;\n    }\n\n    const string& correct_str = correct_lines[0];\n    const string& ouf_str     = ouf_lines[0];\n\n    try {\n        // Parse correct answer integer with strict format checking\n        size_t pos_correct;\n        int ja = stoi(correct_str, &pos_correct);\n        if (pos_correct != correct_str.size()) {\n            return false; // Extra characters in correct answer\n        }\n\n        // Parse participant's output integer\n        size_t pos_ouf;\n        int pa = stoi(ouf_str, &pos_ouf);\n        if (pos_ouf != ouf_str.size()) {\n            return false; // Extra characters in participant's output\n        }\n\n        return ja == pa;\n    } catch (...) {\n        return false; // Failed to parse integers (e.g., non-numeric input)\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60599, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed 64-bit integers between\n  correct answer (stdout.txt) and participant's output (answer.txt).\n  Returns true only if both sequences are identical in length and values.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input (unused here)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Helper: Convert all lines into sequence of long long integers\n    auto extract_numbers = [](const vector<string>& lines) -> vector<long long> {\n        vector<long long> numbers;\n        for (const string& line : lines) {\n            if (line.empty()) continue;\n            stringstream ss(line);\n            long long num;\n            while (ss >> num) {\n                numbers.push_back(num);\n            }\n        }\n        return numbers;\n    };\n\n    vector<long long> correct_seq   = extract_numbers(stdout_lines);\n    vector<long long> participant_seq = extract_numbers(participant_lines);\n\n    // Check sequence length equality first\n    if (correct_seq.size() != participant_seq.size()) {\n        return false;\n    }\n\n    // Verify each corresponding element matches\n    for (size_t i = 0; i < correct_seq.size(); ++i) {\n        if (correct_seq[i] != participant_seq[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60601, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected output (stdout_path),\n  using input (stdin_path) to determine number of test cases.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if any file reading failed\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse q from first line of stdin (must contain exactly one integer)\n    int q = 0;\n    {\n        stringstream ss(stdin_lines[0]);\n        string token;\n        if (!(ss >> q) || q < 0 || ss >> token) {\n            return false;\n        }\n    }\n\n    // Verify line counts match expected number of queries\n    if (stdout_lines.size() != q || participant_lines.size() != q) {\n        return false;\n    }\n\n    for (int i = 0; i < q; i++) {\n        ll expected_a, expected_b;\n        ll actual_a, actual_b;\n        string token;\n\n        // Parse expected output line (must contain exactly two integers)\n        stringstream ss_exp(stdout_lines[i]);\n        if (!(ss_exp >> expected_a >> expected_b) || ss_exp >> token) {\n            return false;\n        }\n\n        // Parse participant's output line (must contain exactly two integers)\n        stringstream ss_act(participant_lines[i]);\n        if (!(ss_act >> actual_a >> actual_b) || ss_act >> token) {\n            return false;\n        }\n\n        // Compare values\n        if (actual_a != expected_a || actual_b != expected_b) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60625, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing against jury's answer.\n  Uses absolute/relative error tolerance (1e-4) for floating point values.\n  Returns true if all test cases pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if any file reading failed\n    if (stdin_lines.empty() || stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    // Parse number of test cases (T) from first line of stdin\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (T <= 0) {\n        return false;\n    }\n\n    // Verify stdin structure: 1 (T) + 2*T lines (2 per test case)\n    if (stdin_lines.size() != 1 + 2 * T) {\n        return false;\n    }\n\n    // Verify output files contain exactly T lines each\n    if (stdout_lines.size() != T || participant_lines.size() != T) {\n        return false;\n    }\n\n    // Process each test case\n    for (int t = 0; t < T; ++t) {\n        // Parse n and k from test case header line\n        istringstream header_ss(stdin_lines[1 + 2 * t]);\n        int n, k;\n        if (!(header_ss >> n >> k)) {\n            return false;\n        }\n\n        // Skip the next line containing n integers (not needed for validation)\n\n        // Parse jury's answer and participant's answer\n        double jury_ans, participant_ans;\n        try {\n            jury_ans = stod(stdout_lines[t]);\n            participant_ans = stod(participant_lines[t]);\n        } catch (...) {\n            return false;\n        }\n\n        // Check floating-point tolerance (absolute + relative error)\n        double absolute_error = abs(participant_ans - jury_ans);\n        double denominator = max(1.0, abs(jury_ans));\n        \n        if (absolute_error > denominator * 1e-4) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60591, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two signed integers from answer and participant's output.\n  Returns true if both files contain a single valid integer that matches.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if both output files have at least one line\n    if (participant_lines.empty() || stdout_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse integers from first line of each file\n        int jury_answer = stoi(participant_lines[0]);\n        int participant_answer = stoi(stdout_lines[0]);\n        \n        // Compare values\n        if (jury_answer != participant_answer) {\n            return false;\n        }\n        return true;\n    } catch (...) {\n        // Handle non-integer values or conversion errors\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60634, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Splits a string into a vector of words by whitespace.\n  Used to compare token sequences ignoring extra spaces.\n-----------------------------------------------------------*/\nvector<string> split_words(const string& s) {\n    vector<string> words;\n    stringstream ss(s);\n    string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    return words;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output against expected output by:\n  1. Checking line count matches\n  2. For each line, comparing word sequences (ignoring whitespace differences)\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if line counts match between expected and participant output\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line's word sequence\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        vector<string> expected_words = split_words(stdout_lines[i]);\n        vector<string> participant_words = split_words(participant_lines[i]);\n        \n        if (expected_words != participant_words) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60612, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing participant's output \n  against jury's answer. Uses input file to determine number \n  of test cases (t). For each test case:\n    - Verify first integer from answer matches participant\n    - Verify next 'j' integers from both sources match\n  Returns true if all validations pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert all lines into token streams (whitespace-separated values)\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    vector<string> stdout_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdout_tokens.push_back(token);\n        }\n    }\n\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Parse number of test cases (t) from stdin tokens\n    if (stdin_tokens.empty()) return false;\n    int t;\n    try {\n        t = stoi(stdin_tokens[0]);\n    } catch (...) {\n        return false;\n    }\n    if (t < 1 || t > 10000) return false;\n\n    // Process each test case\n    size_t ans_idx = 0;  // Tracks position in stdout (jury answer) tokens\n    size_t ouf_idx = 0;  // Tracks position in participant output tokens\n\n    for (int i = 0; i < t; ++i) {\n        // Read first integer from jury answer (j) and participant (p)\n        if (ans_idx >= stdout_tokens.size() || ouf_idx >= participant_tokens.size()) \n            return false;\n        \n        int j, p;\n        try {\n            j = stoi(stdout_tokens[ans_idx++]);\n            p = stoi(participant_tokens[ouf_idx++]);\n        } catch (...) {\n            return false;\n        }\n\n        // Verify first integers match\n        if (j != p) return false;\n\n        // Verify next 'j' integers match\n        for (int k = 0; k < j; ++k) {\n            if (ans_idx >= stdout_tokens.size() || ouf_idx >= participant_tokens.size()) \n                return false;\n            \n            int a, b;\n            try {\n                a = stoi(stdout_tokens[ans_idx++]);\n                b = stoi(participant_tokens[ouf_idx++]);\n            } catch (...) {\n                return false;\n            }\n            if (a != b) return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60598, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert string to lowercase in-place by adjusting ASCII values.\n-----------------------------------------------------------*/\nvoid toLow(string &s) {\n    for (auto &ch : s) {\n        if (ch >= 'A' && ch <= 'Z') \n            ch += 'a' - 'A';\n    }\n}\n\n/*-----------------------------------------------------------\n  Calculate the least common multiple of two numbers using GCD.\n-----------------------------------------------------------*/\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\n/*-----------------------------------------------------------\n  Convert a character digit ('0' or '1') to its integer value.\n-----------------------------------------------------------*/\nint toInt(char ch) {\n    return ch - '0';\n}\n\n/*-----------------------------------------------------------\n  Determine the minimal period of a string by checking all divisors.\n  Returns the smallest valid period length.\n-----------------------------------------------------------*/\nint getPeriod(string &s) {\n    int n = s.size();\n    int res = n;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i) continue;\n        \n        // Check divisor i\n        int d = i, valid = 1;\n        for (int j = 0; j < d; j++) {\n            for (int k = j; k < n; k += d) {\n                if (s[k] != s[j]) {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (!valid) break;\n        }\n        if (valid) res = min(res, d);\n\n        // Check divisor n/i\n        d = n / i, valid = 1;\n        for (int j = 0; j < d; j++) {\n            for (int k = j; k < n; k += d) {\n                if (s[k] != s[j]) {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (!valid) break;\n        }\n        if (valid) res = min(res, d);\n    }\n    return res;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against the \n  correct output using the problem's input constraints.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines    = read_file(stdin_path);    // Corresponds to original 'inf' (problem input)\n    vector<string> ans_lines    = read_file(stdout_path);   // Corresponds to original 'ans' (correct output)\n    vector<string> ouf_lines    = read_file(answer_path);   // Corresponds to original 'ouf' (participant's output)\n\n    // Check if input file has at least the T value\n    if (inf_lines.empty()) \n        return false;\n\n    int T;\n    try {\n        T = stoi(inf_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    int inf_idx = 1;  // Points to first test case's pa/pb/pc line\n    int ans_idx = 0;  // Tracks current line in correct output\n    int ouf_idx = 0;  // Tracks current line in participant's output\n\n    for (int i = 0; i < T; i++) {\n        // Verify sufficient lines exist for current test case\n        if (ans_idx >= ans_lines.size() || ouf_idx >= ouf_lines.size())\n            return false;\n\n        string exp = ans_lines[ans_idx++];\n        string act = ouf_lines[ouf_idx++];\n        toLow(exp);\n        toLow(act);\n\n        // Check primary output matches\n        if (exp != act) \n            return false;\n\n        // Parse problem parameters from input file\n        if (inf_idx >= inf_lines.size())\n            return false;\n        \n        istringstream inf_ss(inf_lines[inf_idx++]);\n        int pa, pb, pc;\n        if (!(inf_ss >> pa >> pb >> pc))\n            return false;\n\n        // Additional checks only required for \"yes\" cases\n        if (exp == \"yes\") {\n            // Read participant's A, B, C strings\n            if (ouf_idx + 3 > ouf_lines.size())\n                return false;\n            string a = ouf_lines[ouf_idx++];\n            string b = ouf_lines[ouf_idx++];\n            string c = ouf_lines[ouf_idx++];\n\n            // Skip corresponding lines in correct output\n            if (ans_idx + 3 > ans_lines.size())\n                return false;\n            ans_idx += 3;\n\n            // Verify string lengths match problem parameters\n            if (a.size() != pa || b.size() != pb || c.size() != pc)\n                return false;\n\n            // Verify minimal periods\n            if (getPeriod(a) != pa || getPeriod(b) != pb || getPeriod(c) != pc)\n                return false;\n\n            // Verify binary strings and XOR property over LCM cycle\n            long long lc = lcm(lcm(pa, pb), pc);\n            for (long long j = 0; j < lc; j++) {\n                char ca = a[j % pa];\n                char cb = b[j % pb];\n                char cc = c[j % pc];\n\n                // Ensure binary characters\n                if (ca != '0' && ca != '1') return false;\n                if (cb != '0' && cb != '1') return false;\n                if (cc != '0' && cc != '1') return false;\n\n                // Verify XOR property\n                if ((toInt(ca) ^ toInt(cb)) != toInt(cc))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60602, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Custom checker for the problem Permutation Routing.\n  Validates participant's output by simulating operations on the permutation.\n  Returns true if all test cases are correctly solved, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path); // Unused but required by signature\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert lines to tokens for easier parsing\n    vector<string> stdin_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            stdin_tokens.push_back(token);\n        }\n    }\n\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    int idx_stdin = 0;\n    int idx_part = 0;\n\n    // Read number of test cases T\n    if (idx_stdin >= stdin_tokens.size()) return false;\n    int T = 0;\n    try {\n        T = stoi(stdin_tokens[idx_stdin++]);\n    } catch (...) {\n        return false;\n    }\n    if (T <= 0) return false;\n\n    for (int t = 1; t <= T; t++) {\n        // Read permutation size n\n        if (idx_stdin >= stdin_tokens.size()) return false;\n        int n = 0;\n        try {\n            n = stoi(stdin_tokens[idx_stdin++]);\n        } catch (...) {\n            return false;\n        }\n        if (n <= 0) return false;\n\n        // Read permutation p[1..n]\n        vector<int> p(n+1, 0);\n        for (int i = 1; i <= n; i++) {\n            if (idx_stdin >= stdin_tokens.size()) return false;\n            try {\n                p[i] = stoi(stdin_tokens[idx_stdin++]);\n            } catch (...) {\n                return false;\n            }\n        }\n\n        // Read edges (n-1 edges)\n        vector<pair<int, int>> edges(n); // edges[1..n-1] used\n        for (int i = 1; i <= n-1; i++) {\n            if (idx_stdin + 1 >= stdin_tokens.size()) return false;\n            try {\n                int x = stoi(stdin_tokens[idx_stdin++]);\n                int y = stoi(stdin_tokens[idx_stdin++]);\n                edges[i] = {x, y};\n            } catch (...) {\n                return false;\n            }\n        }\n\n        // Read number of operations m from participant's output\n        if (idx_part >= participant_tokens.size()) return false;\n        int m = 0;\n        try {\n            m = stoi(participant_tokens[idx_part++]);\n        } catch (...) {\n            return false;\n        }\n        if (m < 0 || m > 3*n) return false;\n\n        // Process each operation\n        for (int op = 0; op < m; op++) {\n            // Read number of swaps in this operation\n            if (idx_part >= participant_tokens.size()) return false;\n            int k = 0;\n            try {\n                k = stoi(participant_tokens[idx_part++]);\n            } catch (...) {\n                return false;\n            }\n            if (k < 0 || k > n-1) return false;\n\n            set<int> swapped;\n            for (int j = 0; j < k; j++) {\n                if (idx_part >= participant_tokens.size()) return false;\n                int tij = 0;\n                try {\n                    tij = stoi(participant_tokens[idx_part++]);\n                } catch (...) {\n                    return false;\n                }\n                if (tij < 1 || tij > n-1) return false;\n\n                int x = edges[tij].first;\n                int y = edges[tij].second;\n\n                // Ensure operation is a valid matching\n                if (swapped.find(x) != swapped.end() || \n                    swapped.find(y) != swapped.end()) {\n                    return false;\n                }\n\n                swapped.insert(x);\n                swapped.insert(y);\n                swap(p[x], p[y]);\n            }\n        }\n\n        // Verify final permutation is sorted\n        for (int i = 1; i <= n; i++) {\n            if (p[i] != i) {\n                return false;\n            }\n        }\n    }\n\n    // Ensure all tokens were consumed\n    if (idx_stdin != stdin_tokens.size() || \n        idx_part != participant_tokens.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60606, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Parse all numbers from vector of lines by splitting each line\n  into whitespace-separated tokens and converting to long long.\n-----------------------------------------------------------*/\nvector<long long> parse_numbers(const vector<string>& lines) {\n    vector<long long> numbers;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            numbers.push_back(num);\n        }\n    }\n    return numbers;\n}\n\n/*-----------------------------------------------------------\n  Validate that participant's output matches correct output\n  as an unordered sequence of signed integers.\n  - Correct output (ans) is read from stdout_path\n  - Participant's output (ouf) is read from answer_path\n  - stdin_path (inf) is unused for this checker but required by template\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read correct output (ans) and participant's output (ouf) as string lines\n    vector<string> correct_lines    = read_file(stdout_path);  // Corresponds to ans in original\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to ouf in original\n\n    // Convert string lines to vector of numbers\n    vector<long long> ja = parse_numbers(correct_lines);     // Correct sequence\n    vector<long long> pa = parse_numbers(participant_lines); // Participant's sequence\n\n    // Check if element counts differ\n    if (ja.size() != pa.size()) {\n        return false;\n    }\n\n    // Sort both sequences for comparison as unordered sets\n    sort(ja.begin(), ja.end());\n    sort(pa.begin(), pa.end());\n\n    // Verify sorted sequences are identical\n    return (ja == pa);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";  // Corresponds to inf (unused here)\n    const string stdout_path = \"stdout.txt\"; // Corresponds to ans (correct output)\n    const string answer_path = \"answer.txt\"; // Corresponds to ouf (participant's output)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60600, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nlong long x[100000], y[100000], k = 0;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Core solution logic to determine expected number of steps.\n  Returns -1 if solution is impossible, otherwise returns steps.\n-----------------------------------------------------------*/\nint solve(long long A, long long B, long long P, long long Q) {\n    long long a, b;\n    for (a = A; a % 2 == 0 && a != 0; a /= 2);\n    for (b = B; b % 2 == 0 && b != 0; b /= 2);\n    if ((a == 0 && P == 0 || P % a == 0) && (b == 0 && Q == 0 || Q % b == 0)) {\n        for (; (P != 0 && P != A) || (Q != 0 && Q != B); ) {\n            if (P <= A/2) {\n                x[k] = 0;\n                P = 2 * P;\n            } else {\n                x[k] = A;\n                P = 2 * P - A;\n            }\n            if (Q <= B/2) {\n                y[k] = 0;\n                Q = 2 * Q;\n            } else {\n                y[k] = B;\n                Q = 2 * Q - B;\n            }\n            k++;\n        }\n        return k;\n    }\n    else {\n        return -1;\n    }\n    return -1;\n}\n\n/*-----------------------------------------------------------\n  Validate the contestant's output against expected behavior.\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read problem input (stdin.txt) to get parameters\n    vector<string> stdin_lines = read_file(stdin_path);\n    if (stdin_lines.empty()) return false;\n\n    // Parse A, B, X, Y from first line of input\n    istringstream iss(stdin_lines[0]);\n    long long A, B, X, Y;\n    if (!(iss >> A >> B >> X >> Y)) {\n        return false;\n    }\n\n    // Compute expected solution steps\n    int expected = solve(A, B, X, Y);\n\n    // Read contestant's output (stdout.txt)\n    vector<string> stdout_lines = read_file(stdout_path);\n    if (stdout_lines.empty()) return false;\n\n    // Parse first line as actual step count\n    int actual;\n    try {\n        actual = stoi(stdout_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Basic validation checks\n    if (actual != expected) return false;\n    if (actual > 100000) return false;  // 1e5 limit\n\n    // Special case: no steps needed (-1 means impossible)\n    if (expected == -1) {\n        return (stdout_lines.size() == 1);  // Only step count line allowed\n    }\n\n    // Verify sufficient lines exist for step descriptions\n    if (static_cast<int>(stdout_lines.size()) - 1 < actual) {\n        return false;\n    }\n\n    // Initialize valid points set\n    set<pair<ll, ll>> cand;\n    cand.insert({0, 0});\n    cand.insert({A, 0});\n    cand.insert({0, B});\n    cand.insert({A, B});\n\n    // Process each step description\n    for (int i = 0; i < actual; i++) {\n        istringstream line_iss(stdout_lines[1 + i]);\n        ll x1, y1, x2, y2;\n        if (!(line_iss >> x1 >> y1 >> x2 >> y2)) {\n            return false;\n        }\n\n        // Verify points exist in current set\n        if (cand.find({x1, y1}) == cand.end() || \n            cand.find({x2, y2}) == cand.end()) {\n            return false;\n        }\n\n        // Verify midpoint forms valid lattice point\n        if ((x1 + x2) % 2 != 0 || (y1 + y2) % 2 != 0) {\n            return false;\n        }\n\n        // Add new midpoint to valid points\n        cand.insert({(x1 + x2) / 2, (y1 + y2) / 2});\n    }\n\n    // Final verification: target point must be achievable\n    return (cand.find({X, Y}) != cand.end());\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60564, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare token sequences between correct output (stdout.txt) and \n  participant's output (answer.txt). Returns true if all tokens match\n  in order and both files have identical token count.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Extract tokens from correct output\n    vector<string> correct_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            correct_tokens.push_back(token);\n        }\n    }\n\n    // Extract tokens from participant's output\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Check token count mismatch\n    if (correct_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Compare each token\n    for (size_t i = 0; i < correct_tokens.size(); ++i) {\n        if (correct_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60629, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer.\n  - stdin_path:   corresponds to testlib's \"inf\" (input file)\n  - stdout_path:  corresponds to testlib's \"ans\" (jury's answer)\n  - answer_path:  corresponds to testlib's \"ouf\" (participant's output)\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> model_lines       = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if either output file is empty\n    if (model_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Extract first integer from first line of each output file\n        int ja = stoi(model_lines[0]);  // Jury's answer\n        int pa = stoi(participant_lines[0]);  // Participant's answer\n\n        return (ja == pa);\n    } catch (...) {\n        // Handle non-integer content or conversion errors as WA\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Input test case\n    const string stdout_path = \"stdout.txt\";  // Jury's expected output (ans)\n    const string answer_path = \"answer.txt\";  // Participant's actual output (ouf)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60637, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to compare two strings as sequences of tokens.\n  Splits both strings by whitespace and checks if token sequences match.\n-----------------------------------------------------------*/\nbool compareTokens(const string& a, const string& b)\n{\n    vector<string> tokensA, tokensB;\n    stringstream sa(a), sb(b);\n    string word;\n\n    while (sa >> word) tokensA.push_back(word);\n    while (sb >> word) tokensB.push_back(word);\n\n    return tokensA == tokensB;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer by:\n  1. Checking line count matches\n  2. For each line, comparing token sequences (ignoring whitespace differences)\n  Returns true if all lines match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check line count consistency first\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line's token sequence\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (!compareTokens(correct_lines[i], participant_lines[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60626, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's output.\n  - stdin_path: Input file (not used in this checker)\n  - stdout_path: Jury's output file (expected answers)\n  - answer_path: Participant's output file\n  \n  Conversion process:\n    1. Read all three files as vector<string> with trimmed lines\n    2. Convert non-empty lines from stdout_path and answer_path to ll\n    3. Reject if:\n        * Any line fails integer conversion\n        * Number of valid integers differ\n        * Any integer value differs\n  \n  Returns true for accepted solutions, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert jury's output (stdout_lines) to vector<ll>\n    vector<ll> jury;\n    for (const string& s : stdout_lines) {\n        if (s.empty()) continue;\n        try {\n            size_t pos;\n            ll num = stoll(s, &pos);\n            // Ensure entire string was converted (no extra characters)\n            if (pos != s.size()) return false;\n            jury.push_back(num);\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Convert participant's output to vector<ll>\n    vector<ll> participant;\n    for (const string& s : participant_lines) {\n        if (s.empty()) continue;\n        try {\n            size_t pos;\n            ll num = stoll(s, &pos);\n            if (pos != s.size()) return false;\n            participant.push_back(num);\n        } catch (...) {\n            return false;\n        }\n    }\n\n    // Compare sizes first\n    if (jury.size() != participant.size()) {\n        return false;\n    }\n\n    // Compare element-wise\n    for (size_t i = 0; i < jury.size(); ++i) {\n        if (jury[i] != participant[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60630, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Compare participant's output (answer.txt) against jury's answer (stdout.txt)\n    // Original code compared ouf (participant) vs ans (jury) integers\n    if (stdout_lines.empty() || participant_lines.empty()) {\n        return false;\n    }\n\n    try {\n        // Parse first line as integer (mimics original readInt() behavior)\n        int jury_ans = stoi(stdout_lines[0]);\n        int part_ans = stoi(participant_lines[0]);\n        return (jury_ans == part_ans);\n    } catch (...) {\n        // Failed to parse integer - invalid format\n        return false;\n    }\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60613, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the participant's solution by comparing against\n  minimal cost computed from input. The validation checks:\n  1. Participant's reported cost matches minimal cost\n  2. Participant's permutation is valid (1-indexed, no duplicates)\n  3. Simulation of participant's order yields minimal cost\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert vector of lines to single string streams\n    string stdin_full, participant_full;\n    for (const string& s : stdin_lines) {\n        stdin_full += s + '\\n';\n    }\n    for (const string& s : participant_lines) {\n        participant_full += s + '\\n';\n    }\n    istringstream stdin_stream(stdin_full);\n    istringstream participant_stream(participant_full);\n\n    // Read number of test cases\n    int T;\n    if (!(stdin_stream >> T)) {\n        return false;\n    }\n\n    for (int tc = 1; tc <= T; tc++) {\n        // Read test case parameters\n        int n;\n        ll f, sf;\n        if (!(stdin_stream >> n >> f)) {\n            return false;\n        }\n        sf = f;\n        vector<ll> L(n), R(n);\n        ll tot = 0;\n        \n        // Read intervals and compute base cost (sum of lengths)\n        for (int i = 0; i < n; i++) {\n            if (!(stdin_stream >> L[i] >> R[i])) {\n                return false;\n            }\n            tot += R[i] - L[i];\n        }\n\n        // Compute minimal cost by processing intervals in optimal order\n        vector<int> indices(n);\n        iota(all(indices), 0);\n        sort(all(indices), [&](int a, int b) {\n            return L[a] < L[b];\n        });\n        \n        ll current_f = sf;\n        for (int idx : indices) {\n            if (R[idx] > current_f) {\n                // Add gap between current position and interval start\n                tot += max(0LL, L[idx] - current_f);\n                current_f = R[idx];\n            }\n        }\n\n        // Validate participant's reported cost\n        ll rc;\n        if (!(participant_stream >> rc) || rc != tot) {\n            return false;\n        }\n\n        // Validate participant's permutation\n        vector<bool> used(n, false);\n        current_f = sf;\n        ll ac = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int pos;\n            if (!(participant_stream >> pos)) {\n                return false;\n            }\n            pos--; // Convert to 0-indexed\n            \n            // Check validity of position\n            if (pos < 0 || pos >= n || used[pos]) {\n                return false;\n            }\n            used[pos] = true;\n            \n            // Accumulate cost: gap to interval start + interval length\n            ac += max(0LL, L[pos] - current_f) + (R[pos] - L[pos]);\n            current_f = R[pos];\n        }\n        \n        // Final cost must match minimal cost\n        if (ac != tot) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60619, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read all long long integers from a file into a vector<long long>,\n  ignoring whitespace (including newlines).\n-----------------------------------------------------------*/\nvector<ll> read_numbers(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<ll> numbers;\n    ll num;\n\n    while (fin >> num) {\n        numbers.push_back(num);\n    }\n    return numbers;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<ll> ja = read_numbers(answer_path);  // Judge's answer (ans)\n    vector<ll> pa = read_numbers(stdout_path);   // Participant's output (ouf)\n\n    // Check if the number of test cases differ\n    if (ja.size() != pa.size()) {\n        return false;\n    }\n\n    // Compare each test case result\n    for (size_t i = 0; i < ja.size(); ++i) {\n        if (ja[i] != pa[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60615, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of signed long long integers token by token.\n  Return true if all tokens match and sequences have identical length.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> ans_lines         = read_file(stdout_path);  // Correct answer (jury)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output\n\n    // Tokenize the correct answer file\n    vector<string> ans_tokens;\n    for (string& line : ans_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    // Tokenize the contestant's output file\n    vector<string> ouf_tokens;\n    for (string& line : participant_lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ouf_tokens.push_back(token);\n        }\n    }\n\n    // Compare each token as signed 64-bit integers\n    size_t min_size = min(ans_tokens.size(), ouf_tokens.size());\n    for (size_t i = 0; i < min_size; i++) {\n        try {\n            ll ja = stoll(ans_tokens[i]);\n            ll pa = stoll(ouf_tokens[i]);\n            if (ja != pa) return false;\n        } catch (...) {\n            return false;  // Invalid number format\n        }\n    }\n\n    // Check for mismatched sequence lengths\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60614, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare sequences of signed integers from jury's output (stdout_path)\n  and participant's output (answer_path). The input file (stdin_path)\n  is not used in this checker. Returns true if both sequences contain\n  identical numbers in the same order with no extra elements, false\n  otherwise. Handles tokenization of numbers from whitespace-delimited\n  content across multiple lines.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin is unused but required by template)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output\n\n    // Parse tokens from jury's answer file (stdout_lines)\n    vector<ll> jury_tokens;\n    for (const string& line : stdout_lines) {\n        if (line.empty()) continue;  // Skip empty lines\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                // Convert token to long long (handles signed integers)\n                jury_tokens.push_back(stoll(token));\n            } catch (...) {\n                // Invalid number format -> immediate failure\n                return false;\n            }\n        }\n    }\n\n    // Parse tokens from participant's output file (participant_lines)\n    vector<ll> participant_tokens;\n    for (const string& line : participant_lines) {\n        if (line.empty()) continue;  // Skip empty lines\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            try {\n                participant_tokens.push_back(stoll(token));\n            } catch (...) {\n                return false;\n            }\n        }\n    }\n\n    // Check sequence length equality\n    if (jury_tokens.size() != participant_tokens.size()) {\n        return false;\n    }\n\n    // Verify element-wise equality\n    for (size_t i = 0; i < jury_tokens.size(); ++i) {\n        if (jury_tokens[i] != participant_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60603, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against jury's answer using:\n  - stdin.txt: problem input (contains n, k, q, tasks, queries)\n  - stdout.txt: participant's output\n  - answer.txt: jury's expected output\n  \n  Compares q lines of (day, hour) pairs between outputs.\n  Returns true if all match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Check if any required file is empty\n    if (stdin_lines.empty() || stdout_lines.empty() || answer_lines.empty()) {\n        cerr << \"One or more input files are empty or could not be read.\\n\";\n        return false;\n    }\n\n    // Parse first line: n (tasks), k (hours/day), q (queries)\n    int n, k, q;\n    {\n        stringstream ss(stdin_lines[0]);\n        if (!(ss >> n >> k >> q)) {\n            cerr << \"Failed to parse n, k, q from first line of stdin.\\n\";\n            return false;\n        }\n    }\n\n    // Verify stdin structure: 1 header line + n task lines + q query lines\n    if (static_cast<int>(stdin_lines.size()) != 1 + n + q) {\n        cerr << \"stdin has \" << stdin_lines.size() \n             << \" lines, expected \" << 1 + n + q << \".\\n\";\n        return false;\n    }\n\n    // Verify output files contain exactly q lines each\n    if (static_cast<int>(answer_lines.size()) != q) {\n        cerr << \"answer.txt has \" << answer_lines.size() \n             << \" lines, expected \" << q << \".\\n\";\n        return false;\n    }\n    if (static_cast<int>(stdout_lines.size()) != q) {\n        cerr << \"stdout.txt has \" << stdout_lines.size() \n             << \" lines, expected \" << q << \".\\n\";\n        return false;\n    }\n\n    // Compare each query's output (day, hour)\n    for (int i = 0; i < q; ++i) {\n        // Parse jury's expected output\n        long long expected_day, expected_hour;\n        stringstream ans_ss(answer_lines[i]);\n        if (!(ans_ss >> expected_day >> expected_hour)) {\n            cerr << \"Failed to parse answer line \" << (i+1) << \".\\n\";\n            return false;\n        }\n\n        // Parse participant's actual output\n        long long actual_day, actual_hour;\n        stringstream out_ss(stdout_lines[i]);\n        if (!(out_ss >> actual_day >> actual_hour)) {\n            cerr << \"Failed to parse stdout line \" << (i+1) << \".\\n\";\n            return false;\n        }\n\n        // Validate match\n        if (expected_day != actual_day || expected_hour != actual_hour) {\n            cerr << \"Mismatch at query \" << (i+1) \n                 << \": expected (\" << expected_day << \", \" << expected_hour\n                 << \"), found (\" << actual_day << \", \" << actual_hour << \")\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60635, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates the participant's solution by comparing against the correct answer\n  using the input test data. Checks include:\n  1. Color validity (1 <= color <= m)\n  2. Vertex color count constraints (<=2 per vertex per color)\n  3. Participant's score not exceeding judge's score\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Validate input structure\n    if (stdin_lines.empty()) {\n        return false;\n    }\n\n    ll t = 0;\n    {\n        stringstream ss(stdin_lines[0]);\n        if (!(ss >> t) || t < 0) {\n            return false;\n        }\n    }\n\n    ll idx_stdin = 1;\n    ll idx_participant = 0;\n    ll idx_stdout = 0;\n\n    for (ll i = 0; i < t; i++) {\n        // Parse n and m from stdin\n        if (idx_stdin >= (ll)stdin_lines.size()) return false;\n        stringstream ss1(stdin_lines[idx_stdin]);\n        ll n, m;\n        if (!(ss1 >> n >> m) || n <= 0 || m <= 0) {\n            return false;\n        }\n        idx_stdin++;\n\n        // Parse edges\n        vector<pair<ll, ll>> edges;\n        for (ll j = 0; j < m; j++) {\n            if (idx_stdin >= (ll)stdin_lines.size()) return false;\n            stringstream ss_edge(stdin_lines[idx_stdin]);\n            ll u, v;\n            if (!(ss_edge >> u >> v) || u < 1 || v < 1 || u > n || v > n) {\n                return false;\n            }\n            edges.push_back({u, v});\n            idx_stdin++;\n        }\n\n        // Parse participant's colors\n        if (idx_participant >= (ll)participant_lines.size()) return false;\n        vector<ll> p_colors;\n        {\n            stringstream ss_part(participant_lines[idx_participant]);\n            ll color;\n            while (p_colors.size() < m && ss_part >> color) {\n                p_colors.push_back(color);\n            }\n            if (p_colors.size() != m) return false;\n            idx_participant++;\n        }\n\n        // Parse correct answer colors\n        if (idx_stdout >= (ll)stdout_lines.size()) return false;\n        vector<ll> j_colors;\n        {\n            stringstream ss_ans(stdout_lines[idx_stdout]);\n            ll color;\n            while (j_colors.size() < m && ss_ans >> color) {\n                j_colors.push_back(color);\n            }\n            if (j_colors.size() != m) return false;\n            idx_stdout++;\n        }\n\n        // Check color validity for participant\n        for (ll color : p_colors) {\n            if (color < 1 || color > m) {\n                return false;\n            }\n        }\n\n        // Check vertex color constraints for participant\n        vector<map<ll, ll>> p_vtx_color_counts(n + 1);\n        for (ll j = 0; j < m; j++) {\n            ll u = edges[j].first;\n            ll v = edges[j].second;\n            ll c = p_colors[j];\n            p_vtx_color_counts[u][c]++;\n            p_vtx_color_counts[v][c]++;\n            if (p_vtx_color_counts[u][c] > 2 || p_vtx_color_counts[v][c] > 2) {\n                return false;\n            }\n        }\n\n        // Calculate participant's score\n        ll p_score = 0;\n        for (ll u = 1; u <= n; u++) {\n            p_score += (ll)p_vtx_color_counts[u].size();\n        }\n\n        // Calculate judge's score\n        vector<map<ll, ll>> j_vtx_color_counts(n + 1);\n        for (ll j = 0; j < m; j++) {\n            ll u = edges[j].first;\n            ll v = edges[j].second;\n            ll c = j_colors[j];\n            j_vtx_color_counts[u][c]++;\n            j_vtx_color_counts[v][c]++;\n        }\n        ll j_score = 0;\n        for (ll u = 1; u <= n; u++) {\n            j_score += (ll)j_vtx_color_counts[u].size();\n        }\n\n        // Final score comparison\n        if (p_score > j_score) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60628, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against the correct answer (stdout_path).\n  For each line in the correct answer, verify the participant's output has an identical\n  line at the same position. Missing lines or mismatches result in rejection.\n  Note: Extra lines in participant's output are ignored (matches original behavior).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check each line in the correct answer\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        // Participant's output has fewer lines than correct answer\n        if (i >= participant_lines.size()) {\n            return false;\n        }\n        // Line content mismatch\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60605, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Helper function to convert string to lowercase\n-----------------------------------------------------------*/\nstring toLower(string a) {\n    for(char &c : a) {\n        if(c >= 'A' && c <= 'Z') \n            c = c - 'A' + 'a';\n    }\n    return a;\n}\n\n/*-----------------------------------------------------------\n  Main validation logic for the path problem.\n  Returns true if the contestant's solution is valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read the three files (test case, jury output, contestant output)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Helper: convert lines to tokens (split by whitespace)\n    auto get_tokens = [](const vector<string>& lines) {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            if (line.empty()) continue;\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    // Convert to token vectors\n    vector<string> stdin_tokens = get_tokens(stdin_lines);\n    vector<string> jury_tokens  = get_tokens(stdout_lines);\n    vector<string> cont_tokens  = get_tokens(participant_lines);\n\n    // Check if we have enough tokens in test case\n    if (stdin_tokens.size() < 2 + 4) {\n        cerr << \"Insufficient tokens in test case input\" << endl;\n        return false;\n    }\n\n    // Parse grid dimensions (n, m)\n    int n, m;\n    try {\n        n = stoi(stdin_tokens[0]);\n        m = stoi(stdin_tokens[1]);\n    } catch (...) {\n        cerr << \"Invalid grid dimensions in test case\" << endl;\n        return false;\n    }\n    if (n < 1 || n > 40 || m < 1 || m > 40) {\n        cerr << \"Grid dimensions out of bounds: n=\" << n << \", m=\" << m << endl;\n        return false;\n    }\n\n    // Parse grid (n lines of m characters)\n    vector<string> grid;\n    int token_idx = 2;\n    for (int i = 0; i < n; ++i) {\n        if (token_idx >= stdin_tokens.size()) {\n            cerr << \"Missing grid row \" << i << endl;\n            return false;\n        }\n        string row = stdin_tokens[token_idx++];\n        if (row.size() != m) {\n            cerr << \"Grid row \" << i << \" has length \" << row.size() \n                 << \", expected \" << m << endl;\n            return false;\n        }\n        for (char c : row) {\n            if (c != 'B' && c != 'W') {\n                cerr << \"Invalid character '\" << c << \"' in grid\" << endl;\n                return false;\n            }\n        }\n        grid.push_back(row);\n    }\n\n    // Parse start and end points (sx, sy, ex, ey)\n    if (token_idx + 3 >= stdin_tokens.size()) {\n        cerr << \"Missing start/end coordinates\" << endl;\n        return false;\n    }\n    int sx, sy, ex, ey;\n    try {\n        sx = stoi(stdin_tokens[token_idx++]);\n        sy = stoi(stdin_tokens[token_idx++]);\n        ex = stoi(stdin_tokens[token_idx++]);\n        ey = stoi(stdin_tokens[token_idx++]);\n    } catch (...) {\n        cerr << \"Invalid start/end coordinates\" << endl;\n        return false;\n    }\n\n    // Lambda to check if point is on border\n    auto is_border = [n, m](int x, int y) {\n        return (x == 0 || x == n || y == 0 || y == m);\n    };\n\n    // Validate start/end points\n    if (!is_border(sx, sy)) {\n        cerr << \"Start point (\" << sx << \",\" << sy << \") is not on border\" << endl;\n        return false;\n    }\n    if (!is_border(ex, ey)) {\n        cerr << \"End point (\" << ex << \",\" << ey << \") is not on border\" << endl;\n        return false;\n    }\n    if (sx == ex && sy == ey) {\n        cerr << \"Start and end points are identical\" << endl;\n        return false;\n    }\n\n    // Check if we have jury verdict\n    if (jury_tokens.empty()) {\n        cerr << \"Jury output is empty\" << endl;\n        return false;\n    }\n    string jury_verdict = toLower(jury_tokens[0]);\n    string cont_verdict = (cont_tokens.empty() ? \"\" : toLower(cont_tokens[0]));\n\n    // Case 1: Jury says \"no\"\n    if (jury_verdict == \"no\") {\n        if (cont_verdict != \"no\") {\n            cerr << \"Expected NO, but participant says YES\" << endl;\n            return false;\n        }\n        return true;  // Both say NO - valid\n    }\n\n    // Case 2: Jury says \"yes\" - contestant must say \"yes\" and provide path\n    if (cont_verdict != \"yes\") {\n        cerr << \"Expected YES, but participant says NO\" << endl;\n        return false;\n    }\n\n    // Parse path length k\n    if (cont_tokens.size() < 2) {\n        cerr << \"Missing path length after YES\" << endl;\n        return false;\n    }\n    int k;\n    try {\n        k = stoi(cont_tokens[1]);\n    } catch (...) {\n        cerr << \"Invalid path length: \" << cont_tokens[1] << endl;\n        return false;\n    }\n    int max_k = (n + 1) * (m + 1);\n    if (k < 2 || k > max_k) {\n        cerr << \"Path length \" << k << \" out of bounds [2, \" << max_k << \"]\" << endl;\n        return false;\n    }\n\n    // Parse path vertices\n    vector<pair<int, int>> path;\n    set<pair<int, int>> visited_node;\n    token_idx = 2;  // Start after verdict and k\n    for (int i = 0; i < k; ++i) {\n        if (token_idx + 1 >= cont_tokens.size()) {\n            cerr << \"Incomplete path vertex at position \" << i << endl;\n            return false;\n        }\n        int x, y;\n        try {\n            x = stoi(cont_tokens[token_idx++]);\n            y = stoi(cont_tokens[token_idx++]);\n        } catch (...) {\n            cerr << \"Invalid vertex coordinates at position \" << i << endl;\n            return false;\n        }\n\n        // Check coordinates are in valid range\n        if (x < 0 || x > n || y < 0 || y > m) {\n            cerr << \"Vertex (\" << x << \",\" << y << \") out of bounds [0,\" \n                 << n << \"]x[0,\" << m << \"]\" << endl;\n            return false;\n        }\n\n        // Check vertex is on border or strictly inside\n        if (!(is_border(x, y) || (x > 0 && x < n && y > 0 && y < m))) {\n            cerr << \"Vertex (\" << x << \",\" << y << \") is invalid\" << endl;\n            return false;\n        }\n\n        // Check no repeated vertices\n        if (!visited_node.insert({x, y}).second) {\n            cerr << \"Repeated vertex (\" << x << \",\" << y << \") at position \" << i << endl;\n            return false;\n        }\n        path.push_back({x, y});\n    }\n\n    // Check path starts and ends correctly\n    if (path[0] != make_pair(sx, sy)) {\n        cerr << \"Path doesn't start at (\" << sx << \",\" << sy \n             << \"), starts at (\" << path[0].first << \",\" << path[0].second << \")\" << endl;\n        return false;\n    }\n    if (path.back() != make_pair(ex, ey)) {\n        cerr << \"Path doesn't end at (\" << ex << \",\" << ey \n             << \"), ends at (\" << path.back().first << \",\" << path.back().second << \")\" << endl;\n        return false;\n    }\n\n    // Lambda to check adjacent vertices\n    auto is_adjacent = [](pair<int, int> a, pair<int, int> b) {\n        int dx = abs(a.first - b.first);\n        int dy = abs(a.second - b.second);\n        return (dx + dy == 1);\n    };\n\n    // Check path connectivity\n    for (int i = 1; i < k; ++i) {\n        if (!is_adjacent(path[i], path[i-1])) {\n            cerr << \"Non-adjacent vertices at positions \" << i-1 \n                 << \" and \" << i << endl;\n            return false;\n        }\n    }\n\n    // Build set of path edges (undirected)\n    set<pair<pair<int, int>, pair<int, int>>> path_edges;\n    for (int i = 1; i < k; ++i) {\n        auto a = path[i-1], b = path[i];\n        if (a > b) swap(a, b);\n        path_edges.insert({a, b});\n    }\n\n    // Directions: down, right, up, left\n    vector<int> dx = {1, 0, -1, 0};\n    vector<int> dy = {0, 1, 0, -1};\n\n    // BFS to verify color regions\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (visited[i][j]) continue;\n            \n            queue<pair<int, int>> q;\n            q.push({i, j});\n            visited[i][j] = true;\n            char color = grid[i][j];\n            \n            while (!q.empty()) {\n                auto [x, y] = q.front(); q.pop();\n                for (int d = 0; d < 4; ++d) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    if (nx < 0 || ny < 0 || nx >= n || ny >= m || visited[nx][ny]) \n                        continue;\n                    \n                    // Determine edge vertices based on direction\n                    pair<int, int> v1, v2;\n                    if (d == 0) { // down\n                        v1 = {x+1, y}, v2 = {x+1, y+1};\n                    } else if (d == 1) { // right\n                        v1 = {x, y+1}, v2 = {x+1, y+1};\n                    } else if (d == 2) { // up\n                        v1 = {x, y}, v2 = {x, y+1};\n                    } else { // left\n                        v1 = {x, y}, v2 = {x+1, y};\n                    }\n                    if (v1 > v2) swap(v1, v2);\n                    \n                    // Skip if edge is blocked by path\n                    if (path_edges.find({v1, v2}) != path_edges.end()) \n                        continue;\n                    \n                    // Verify color consistency\n                    if (grid[nx][ny] != color) {\n                        cerr << \"Mixed colors at (\" << nx << \",\" << ny \n                             << \") - expected \" << color << \", got \" << grid[nx][ny] << endl;\n                        return false;\n                    }\n                    \n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    return true;  // All checks passed\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60622, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected output (stdout_path)\n  line-by-line. Returns true if all lines match exactly (after trimming), \n  false otherwise (including line count mismatch).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Input (not used in comparison)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Check if line counts differ\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact match (after trimming)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60620, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer line-by-line.\n  - stdin_path:   Problem input (unused in this checker but required by template)\n  - stdout_path:  Correct answer file (corresponds to 'ans' in original code)\n  - answer_path:  Participant's output file (corresponds to 'ouf' in original code)\n  Returns true if all lines match exactly (after trimming), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files (stdin is unused for comparison but kept for template compliance)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Correct answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant output (ouf)\n\n    // Check line count mismatch first\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line character-by-character\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (correct_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Corresponds to 'inf' in original code\n    const string stdout_path = \"stdout.txt\";  // Corresponds to 'ans' (correct answer)\n    const string answer_path = \"answer.txt\";  // Corresponds to 'ouf' (participant output)\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60609, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against correct answer using input context.\n  Returns true if all test cases match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);  // Input test cases (L, R values)\n    vector<string> stdout_lines = read_file(stdout_path); // Participant's output\n    vector<string> answer_lines = read_file(answer_path); // Correct output (expected answers)\n\n    // Verify valid input structure\n    if (stdin_lines.empty()) \n        return false;\n\n    // Parse number of test cases (T) from first line\n    int T;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n\n    // Validate file structure consistency\n    if (T <= 0 || \n        stdout_lines.size() != T || \n        answer_lines.size() != T || \n        stdin_lines.size() < T + 1) {\n        return false;\n    }\n\n    // Process each test case\n    for (int i = 0; i < T; ++i) {\n        // Parse L and R from input line (i+1 because first line is T)\n        stringstream ss(stdin_lines[i+1]);\n        ll L, R;\n        if (!(ss >> L >> R)) \n            return false;\n\n        // Parse participant's and correct outputs\n        ll user_out, correct_out;\n        try {\n            user_out    = stoll(stdout_lines[i]);\n            correct_out = stoll(answer_lines[i]);\n        } catch (...) {\n            return false;\n        }\n\n        // Verify outputs match\n        if (user_out != correct_out) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60627, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct answer (stdout_path)\n  line-by-line. Returns true if all lines match up to the length of correct answer,\n  false if any mismatch or participant output is shorter than correct answer.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Unused input file (stdin_path corresponds to problem input)\n    vector<string> stdin_lines       = read_file(stdin_path);\n    \n    // Correct answer file (stdout_path corresponds to jury's answer)\n    vector<string> correct_lines     = read_file(stdout_path);\n    \n    // Participant's output file (answer_path corresponds to contestant's output)\n    vector<string> contestant_lines  = read_file(answer_path);\n\n    // Compare each line in correct answer with participant's output\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        // Participant output is shorter than correct answer\n        if (i >= contestant_lines.size()) {\n            return false;\n        }\n        \n        // Line content mismatch\n        if (correct_lines[i] != contestant_lines[i]) {\n            return false;\n        }\n    }\n    \n    // All compared lines match (extra lines in participant output are ignored)\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60621, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing token-by-token:\n  1. Parse 'q' (number of queries) from stdin file\n  2. Ensure participant's output (answer.txt) has exactly q tokens\n  3. Ensure correct output (stdout.txt) has at least q tokens\n  4. Verify each token matches as integers between outputs\n  Returns true if all checks pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Tokenize all input streams (stdin = problem input, stdout = correct answers, answer = participant output)\n    vector<string> inf_tokens;\n    for (const string& line : stdin_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            inf_tokens.push_back(token);\n        }\n    }\n\n    vector<string> ans_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ans_tokens.push_back(token);\n        }\n    }\n\n    vector<string> participant_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            participant_tokens.push_back(token);\n        }\n    }\n\n    // Must have at least 2 tokens in stdin (n and q)\n    if (inf_tokens.size() < 2) {\n        return false;\n    }\n\n    // Parse number of queries (q) from second token\n    int q;\n    try {\n        q = stoi(inf_tokens[1]);\n    } catch (...) {\n        return false;\n    }\n\n    // Participant must have exactly q tokens (no extra output)\n    if (static_cast<int>(participant_tokens.size()) != q) {\n        return false;\n    }\n\n    // Correct output must have at least q tokens\n    if (static_cast<int>(ans_tokens.size()) < q) {\n        return false;\n    }\n\n    // Compare each token as integers (mimics testlib's readInt() behavior)\n    for (int i = 0; i < q; ++i) {\n        try {\n            int participant_val = stoi(participant_tokens[i]);\n            int correct_val     = stoi(ans_tokens[i]);\n            if (participant_val != correct_val) {\n                return false;\n            }\n        } catch (...) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60640, "checker": null, "success": false}
{"id": 60631, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against jury's answer by:\n  1. Reading all three files (stdin, stdout/jury, answer/participant)\n  2. Parsing all numeric tokens from stdout (jury's answer) and answer (participant's output)\n  3. Verifying identical sequence of integers (size and values)\n  Note: stdin is read but unused as original checker didn't require input for validation.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);   // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path);   // Participant's actual output\n\n    // Parse all tokens from jury's answer into vector of integers\n    vector<ll> ja;\n    for (string line : stdout_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            ja.push_back(stoll(token));\n        }\n    }\n\n    // Parse all tokens from participant's output into vector of integers\n    vector<ll> pa;\n    for (string line : participant_lines) {\n        stringstream ss(line);\n        string token;\n        while (ss >> token) {\n            pa.push_back(stoll(token));\n        }\n    }\n\n    // Check for size mismatch (Presentation Error in original)\n    if (ja.size() != pa.size()) {\n        return false;\n    }\n\n    // Check each corresponding value\n    for (size_t i = 0; i < ja.size(); i++) {\n        if (ja[i] != pa[i]) {\n            return false;  // Wrong Answer in original\n        }\n    }\n\n    return true;  // All test cases matched\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60618, "checker": null, "success": false}
{"id": 60636, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Uses stdin.txt (input data), stdout.txt (correct output),\n  and answer.txt (participant's output). Returns true only if:\n  1. All test cases have matching answers\n  2. No extra output exists after test cases\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert lines to tokens for each stream\n    auto get_tokens = [](const vector<string>& lines) -> vector<string> {\n        vector<string> tokens;\n        for (const string& line : lines) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n        return tokens;\n    };\n\n    vector<string> stdin_tokens = get_tokens(stdin_lines);\n    vector<string> ans_tokens   = get_tokens(stdout_lines);   // Correct output (ans)\n    vector<string> ouf_tokens   = get_tokens(participant_lines); // Participant's output (ouf)\n\n    size_t stdin_idx = 0, ans_idx = 0, ouf_idx = 0;\n\n    // Read number of test cases T\n    if (stdin_idx >= stdin_tokens.size()) return false;\n    int T;\n    try {\n        T = stoi(stdin_tokens[stdin_idx++]);\n    } catch (...) {\n        return false;\n    }\n\n    // Process each test case\n    for (int tc = 1; tc <= T; tc++) {\n        // Check correct output has answer\n        if (ans_idx >= ans_tokens.size()) return false;\n        ll expected;\n        try {\n            expected = stoll(ans_tokens[ans_idx++]);\n        } catch (...) {\n            return false;\n        }\n\n        // Check participant provided answer\n        if (ouf_idx >= ouf_tokens.size()) return false;\n        ll got;\n        try {\n            got = stoll(ouf_tokens[ouf_idx++]);\n        } catch (...) {\n            return false;\n        }\n\n        // Verify answer matches\n        if (got != expected) return false;\n    }\n\n    // Ensure no extra output after all test cases\n    if (ouf_idx < ouf_tokens.size()) return false;\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60673, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validates participant's output (answer.txt) against jury's answer \n  (stdout.txt) by comparing line-by-line after whitespace trimming.\n  Returns true only if all lines match exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected output\n    vector<string> participant_lines = read_file(answer_path);  // Participant's submission\n\n    // Early termination if line counts differ\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Verify each line matches after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60639, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate the solution by comparing expected output (stdout.txt)\n  and contestant's output (answer.txt) against the problem input (stdin.txt).\n  Implements the same logic as the original testlib checker:\n    - Reads number of test cases from stdin\n    - For each test case:\n        * Reads grid size n and target k from stdin\n        * Compares \"Yes\"/\"No\" response from expected and contestant outputs\n        * For \"Yes\" responses, validates grid values and bingo condition\n  Returns true if all tests pass, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Create stringstreams from file contents (adding newlines for proper tokenization)\n    stringstream stdin_ss, stdout_ss, participant_ss;\n    for (const string& line : stdin_lines) {\n        stdin_ss << line << '\\n';\n    }\n    for (const string& line : stdout_lines) {\n        stdout_ss << line << '\\n';\n    }\n    for (const string& line : participant_lines) {\n        participant_ss << line << '\\n';\n    }\n\n    // Read number of test cases\n    int t;\n    if (!(stdin_ss >> t) || t < 1 || t > 50) {\n        return false;\n    }\n    string rest;\n    getline(stdin_ss, rest); // Consume rest of line\n    if (!rest.empty()) {\n        return false;\n    }\n\n    while (t--) {\n        int n, k;\n        // Read grid size and target value\n        if (!(stdin_ss >> n) || n < 1 || n > 50) {\n            return false;\n        }\n        if (!(stdin_ss >> k) || k < 1 || k > n * n) {\n            return false;\n        }\n        getline(stdin_ss, rest); // Consume rest of line\n        if (!rest.empty()) {\n            return false;\n        }\n\n        // Read response strings (\"Yes\"/\"No\")\n        string expected_response, participant_response;\n        if (!(stdout_ss >> expected_response) || !(participant_ss >> participant_response)) {\n            return false;\n        }\n        if (expected_response != participant_response) {\n            return false;\n        }\n        // Skip grid validation for \"No\" responses\n        if (expected_response == \"No\") {\n            continue;\n        }\n\n        // Read expected grid values\n        vector<int> expected_values;\n        int expected_grid[50][50] = {};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int value;\n                if (!(stdout_ss >> value)) {\n                    return false;\n                }\n                expected_values.push_back(value);\n                expected_grid[i][j] = value;\n            }\n        }\n\n        // Read and validate participant's grid values\n        vector<int> participant_values;\n        int participant_grid[50][50] = {};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int value;\n                if (!(participant_ss >> value)) {\n                    return false;\n                }\n                participant_values.push_back(value);\n                participant_grid[i][j] = value;\n                // Validate value range\n                if (value > n * n) {\n                    return false;\n                }\n            }\n        }\n\n        // Check grid size consistency\n        if (expected_values.size() != participant_values.size()) {\n            return false;\n        }\n\n        // Compare sorted grid values (as unordered sequences)\n        sort(all(expected_values));\n        sort(all(participant_values));\n        if (expected_values != participant_values) {\n            return false;\n        }\n\n        // Find minimum bingo value in participant's grid\n        int min_bingo = n * n + 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                // Check row condition\n                bool valid_row = true;\n                for (int l = 0; l < n; l++) {\n                    if (participant_grid[i][l] > participant_grid[i][j]) {\n                        valid_row = false;\n                        break;\n                    }\n                }\n                if (valid_row) {\n                    min_bingo = min(min_bingo, participant_grid[i][j]);\n                }\n\n                // Check column condition\n                bool valid_col = true;\n                for (int l = 0; l < n; l++) {\n                    if (participant_grid[l][j] > participant_grid[i][j]) {\n                        valid_col = false;\n                        break;\n                    }\n                }\n                if (valid_col) {\n                    min_bingo = min(min_bingo, participant_grid[i][j]);\n                }\n            }\n        }\n\n        // Validate bingo value matches target k\n        if (min_bingo != k) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60643, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\nconst double EPS = 1E-4;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare two sequences of doubles from judge's output (stdout.txt)\n  and participant's output (answer.txt), allowing max absolute\n  or relative error of EPS (1E-4). Returns true if all values \n  match within tolerance, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Judge's expected output\n    vector<string> participant_lines = read_file(answer_path);  // Participant's actual output\n\n    // Ensure participant provided at least as many values as expected\n    if (stdout_lines.size() > participant_lines.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        try {\n            double judge_val = stod(stdout_lines[i]);\n            double part_val  = stod(participant_lines[i]);\n\n            // Check absolute error tolerance\n            double abs_diff = fabs(judge_val - part_val);\n            if (abs_diff <= EPS) continue;\n\n            // Check relative error tolerance (only when judge's value isn't zero)\n            if (fabs(judge_val) > 1e-15) {\n                double rel_diff = abs_diff / fabs(judge_val);\n                if (rel_diff <= EPS) continue;\n            }\n\n            // Either error type exceeds tolerance\n            return false;\n        } catch (...) {\n            // Non-numeric value encountered\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60697, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct \n  output (stdout_path). Input (stdin_path) is read but typically \n  not used in basic checkers. Returns true if outputs match.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> correct_lines     = read_file(stdout_path);  // Corresponds to 'ans'\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf'\n\n    // Verify line count matches\n    if (correct_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line (already stripped of whitespace)\n    for (size_t i = 0; i < correct_lines.size(); ++i) {\n        if (correct_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";  // Corresponds to 'inf'\n    const string stdout_path = \"stdout.txt\"; // Corresponds to 'ans'\n    const string answer_path = \"answer.txt\"; // Corresponds to 'ouf'\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60700, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's output (stdout.txt).\n  Input file (stdin.txt) is available but typically unused for standard checkers.\n  Returns true if outputs match exactly (after whitespace normalization), false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's answer (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Contestant's output (ouf)\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60679, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compares participant's output (answer.txt) against correct answer (stdout.txt).\n  Returns true if all lines match exactly after trimming, false otherwise.\n  Note: stdin.txt provides problem input (inf), stdout.txt contains jury's answer (ans),\n        and answer.txt contains participant's output (ouf) to validate.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: verify participant's output matches expected answer\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60642, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Convert vector of lines into vector of tokens (long long integers).\n  Each line is split by whitespace and tokens are parsed as integers.\n-----------------------------------------------------------*/\nvector<ll> parse_tokens(const vector<string>& lines)\n{\n    vector<ll> result;\n    for (const string& line : lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n/*-----------------------------------------------------------\n  Check if participant's output matches expected output.\n  - stdin_path: input file (not used in this checker)\n  - stdout_path: contains expected output (jury's answer)\n  - answer_path: contains participant's output\n  Returns true if sequences of integers are identical, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    // Read all three files as vector of trimmed lines\n    vector<string> stdin_lines    = read_file(stdin_path);\n    vector<string> expected_lines = read_file(stdout_path);\n    vector<string> output_lines   = read_file(answer_path);\n\n    // Convert expected output and participant's output to vector of integers\n    vector<ll> ja = parse_tokens(expected_lines);\n    vector<ll> pa = parse_tokens(output_lines);\n\n    // Compare element-wise for the common prefix length\n    size_t n = min(ja.size(), pa.size());\n    for (size_t i = 0; i < n; i++) {\n        if (ja[i] != pa[i]) {\n            return false;\n        }\n    }\n\n    // Check if both sequences have same length\n    if (ja.size() != pa.size()) {\n        return false;\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60616, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Stub for whatever checking logic you need.\n  Return true  accept, false  reject.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines  = read_file(stdin_path);\n    vector<string> stdout_lines = read_file(stdout_path); // unused in this problem\n    vector<string> answer_lines = read_file(answer_path);\n\n    if (stdin_lines.empty() || answer_lines.empty()) {\n        cerr << \"Failed to read input or answer files.\\n\";\n        return false;\n    }\n\n    // Parse T (number of test cases) from first line\n    if (stdin_lines[0].empty()) {\n        cerr << \"First line of stdin is empty\\n\";\n        return false;\n    }\n    int T = stoi(stdin_lines[0]);\n    int line_idx = 1;\n    int output_idx = 0;\n\n    if (static_cast<int>(answer_lines.size()) < T) {\n        cerr << \"Expected \" << T << \" lines in answer, got \" << answer_lines.size() << \"\\n\";\n        return false;\n    }\n\n    for (int testNum = 1; testNum <= T; testNum++) {\n        // Parse n and k for current test case\n        if (line_idx >= static_cast<int>(stdin_lines.size())) {\n            cerr << \"Test \" << testNum << \": missing n and k\\n\";\n            return false;\n        }\n        istringstream iss(stdin_lines[line_idx++]);\n        int n, k;\n        if (!(iss >> n >> k)) {\n            cerr << \"Test \" << testNum << \": failed to read n and k\\n\";\n            return false;\n        }\n\n        // Parse k chains (each chain has l and r)\n        vector<pair<int, pair<int, int>>> chains;\n        for (int i = 0; i < k; i++) {\n            if (line_idx >= static_cast<int>(stdin_lines.size())) {\n                cerr << \"Test \" << testNum << \": missing chain \" << i+1 << \"\\n\";\n                return false;\n            }\n            string chain_line = stdin_lines[line_idx++];\n            istringstream chain_iss(chain_line);\n            int l, r;\n            if (!(chain_iss >> l >> r)) {\n                cerr << \"Test \" << testNum << \": failed to read chain \" << i+1 << \"\\n\";\n                return false;\n            }\n            int len = r - l + 1;\n            chains.push_back({len, {l, r}});\n        }\n\n        // Sort chains by length in descending order\n        sort(chains.rbegin(), chains.rend());\n\n        // Get contestant's output line for this test case\n        string output_line = answer_lines[output_idx++];\n\n        // Check for empty output line\n        if (output_line.empty()) {\n            cerr << \"Test \" << testNum << \": missing output line\\n\";\n            return false;\n        }\n\n        // Case 1: Output is \"IMPOSSIBLE\"\n        if (output_line == \"IMPOSSIBLE\") {\n            if (k >= 2 && chains[0].first == chains[1].first &&\n                chains.back().first > chains[0].first - 2) {\n                continue; // Valid IMPOSSIBLE case\n            }\n            cerr << \"Test \" << testNum << \": IMPOSSIBLE incorrectly\\n\";\n            return false;\n        }\n\n        // Case 2: Parse parent array from output line\n        istringstream out_iss(output_line);\n        vector<int> parent(n + 1, 0);\n        for (int i = 1; i <= n; i++) {\n            if (!(out_iss >> parent[i])) {\n                cerr << \"Test \" << testNum << \": expected \" << n << \" parents, got \" << (i-1) << \"\\n\";\n                return false;\n            }\n        }\n        // Check for extra data after n parents\n        if (out_iss >> ws && !out_iss.eof()) {\n            cerr << \"Test \" << testNum << \": extra data on line\\n\";\n            return false;\n        }\n\n        // Build tree structure and validate\n        vector<vector<int>> children(n + 1);\n        int root = 0;\n        for (int i = 1; i <= n; i++) {\n            int p = parent[i];\n            if (p == 0) {\n                if (root) {\n                    cerr << \"Test \" << testNum << \": multiple roots\\n\";\n                    return false;\n                }\n                root = i;\n            } else {\n                if (p < 1 || p > n) {\n                    cerr << \"Test \" << testNum << \": invalid parent \" << p << \" for node \" << i << \"\\n\";\n                    return false;\n                }\n                children[p].push_back(i);\n            }\n        }\n        if (!root) {\n            cerr << \"Test \" << testNum << \": no root\\n\";\n            return false;\n        }\n\n        // Perform heavy-light decomposition\n        vector<int> sz(n + 1, 0), heavy(n + 1, -1), head(n + 1, 0), depth(n + 1, 0);\n        function<int(int)> dfs1 = [&](int u) -> int {\n            sz[u] = 1;\n            int bestSize = 0, bestChild = -1;\n            for (int v : children[u]) {\n                depth[v] = depth[u] + 1;\n                int s = dfs1(v);\n                sz[u] += s;\n                if (s > bestSize || (s == bestSize && v == u + 1)) {\n                    bestSize = s;\n                    bestChild = v;\n                }\n            }\n            heavy[u] = bestChild;\n            return sz[u];\n        };\n        function<void(int, int)> dfs2 = [&](int u, int h) -> void {\n            head[u] = h;\n            if (heavy[u] != -1) {\n                dfs2(heavy[u], h);\n            }\n            for (int v : children[u]) {\n                if (v != heavy[u]) {\n                    dfs2(v, v);\n                }\n            }\n        };\n        dfs1(root);\n        dfs2(root, root);\n\n        // Extract actual chains from HLD\n        vector<pair<int, int>> actual;\n        for (int u = 1; u <= n; u++) {\n            if (head[u] == u) {\n                int v = u;\n                while (heavy[v] != -1) {\n                    v = heavy[v];\n                }\n                actual.emplace_back(u, v);\n            }\n        }\n        sort(actual.begin(), actual.end());\n\n        // Prepare expected chains from input\n        vector<pair<int, int>> expected;\n        for (const auto& chain : chains) {\n            expected.emplace_back(chain.second.first, chain.second.second);\n        }\n        sort(expected.begin(), expected.end());\n\n        // Verify chain count and content match\n        if (actual.size() != expected.size()) {\n            cerr << \"Test \" << testNum << \": chain count mismatch\\n\";\n            return false;\n        }\n        if (actual != expected) {\n            cerr << \"Test \" << testNum << \": chains differ\\n\";\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60705, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Validation logic:\n    1. Check line count matches between outputs\n    2. Verify each line matches exactly (after whitespace stripping)\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if line counts match between expected and participant output\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line exact comparison (whitespace already stripped)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60715, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against correct answer.\n  Compares line-by-line after stripping whitespace, ensuring:\n  1. Same number of lines\n  2. Identical content per line (ignoring leading/trailing spaces)\n  Returns true if valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);  // Corresponds to 'inf' (problem input)\n    vector<string> stdout_lines      = read_file(stdout_path); // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path); // Corresponds to 'ouf' (participant's output)\n\n    // Check line count mismatch\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each stripped line\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60701, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output against expected output.\n  - stdin_lines: problem input (inf) - may be unused depending on checker requirements\n  - stdout_lines: expected output (ans/jury's answer)\n  - participant_lines: participant's output (ouf)\n  Return true if outputs match line-by-line after trimming, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if line counts match\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after trimming (already done during file reading)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60633, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare ordered sequences of signed integers from the correct output\n  (stdout.txt) and participant's output (answer.txt). The comparison\n  verifies both the order and value of each number, ensuring sequences\n  are identical in content and length. Empty lines and whitespace are\n  properly handled during tokenization.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Parse all integer tokens from the correct output (stdout_lines)\n    vector<ll> ans_tokens;\n    for (const string& line : stdout_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            ans_tokens.push_back(num);\n        }\n    }\n\n    // Parse all integer tokens from participant's output (participant_lines)\n    vector<ll> ouf_tokens;\n    for (const string& line : participant_lines) {\n        stringstream ss(line);\n        ll num;\n        while (ss >> num) {\n            ouf_tokens.push_back(num);\n        }\n    }\n\n    // Check if sequence lengths match\n    if (ans_tokens.size() != ouf_tokens.size()) {\n        return false;\n    }\n\n    // Verify each corresponding element is identical\n    for (size_t i = 0; i < ans_tokens.size(); ++i) {\n        if (ans_tokens[i] != ouf_tokens[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60709, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against the correct answer (stdout.txt).\n  The input file (stdin.txt) is read but typically unused for standard output validation.\n  Returns true if all lines match exactly after whitespace trimming, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Check line count consistency first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison after whitespace normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60652, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Extract all long long tokens from a vector of lines.\n  Processes each line by splitting on whitespace and converting\n  each token to a long long number. Empty lines are skipped.\n-----------------------------------------------------------*/\nvector<long long> extract_tokens(const vector<string>& lines)\n{\n    vector<long long> tokens;\n    for (const string& line : lines) {\n        if (line.empty()) continue;\n        stringstream ss(line);\n        long long num;\n        while (ss >> num) {\n            tokens.push_back(num);\n        }\n    }\n    return tokens;\n}\n\n/*-----------------------------------------------------------\n  Compare sequences of signed integers from expected output\n  (stdout_path) and participant's output (answer_path).\n  Returns true only if both sequences:\n    1. Have identical length\n    2. Contain matching elements at every position\n  Corresponds to the original testlib checker's logic for \n  ordered sequences of numbers.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Convert expected output (stdout) and participant's output to token streams\n    vector<long long> expected   = extract_tokens(stdout_lines);\n    vector<long long> participant = extract_tokens(participant_lines);\n\n    // Check sequence length equality first\n    if (expected.size() != participant.size()) {\n        return false;\n    }\n\n    // Verify element-wise equality\n    for (size_t i = 0; i < expected.size(); i++) {\n        if (expected[i] != participant[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60675, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected \n  output (stdout_path) line-by-line after trimming whitespace.\n  Input file (stdin_path) is available for context if needed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: exact line-by-line match after trimming\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60716, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Validation logic:\n  1. Check line count matches between expected and participant outputs\n  2. Verify each corresponding line is identical after whitespace normalization\n  3. Input file (stdin.txt) is available but not used in basic comparison\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> expected_lines    = read_file(stdout_path);  // Corresponds to ans (expected output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to ouf (participant's output)\n\n    // Check line count matches\n    if (participant_lines.size() != expected_lines.size()) {\n        return false;\n    }\n\n    // Compare each line after whitespace normalization\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != expected_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60727, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against expected output (stdout.txt).\n  Both files are read as vectors of stripped lines. Return true only if all\n  corresponding lines match exactly after whitespace trimming.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count consistency first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Perform exact line-by-line comparison\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60722, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against official \n  answer (participant_lines). Uses input (stdin_lines) if needed \n  for problem-specific validation logic.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with official answer\n    // after whitespace normalization (handled by read_file)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60682, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt).\n  Returns true if all lines match exactly after trimming (accept solution),\n  false otherwise (reject solution). Input file (stdin.txt) is read but unused\n  in this basic comparison implementation.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Perform exact line-by-line comparison of trimmed content\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60723, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against expected output (stdout_path).\n  The input file (stdin_path) is also read but may not be used in all checkers.\n  Returns true if outputs match exactly line-by-line after trimming.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count first\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact match after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60676, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected answer using:\n  - stdin_lines: problem input (corresponds to testlib's inf)\n  - stdout_lines: expected correct output (corresponds to testlib's ans)\n  - participant_lines: participant's output (corresponds to testlib's ouf)\n  \n  Returns true if participant's output matches expected output exactly.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Compare participant's output with expected output\n    // (Line-by-line exact match after whitespace trimming)\n    return participant_lines == stdout_lines;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60720, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate solution by comparing participant's output (stdout_path)\n  against jury's answer (answer_path) line-by-line after stripping.\n  Input file (stdin_path) is available for context if needed.\n  Returns true if outputs match, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Contestant's output\n    vector<string> participant_lines = read_file(answer_path);  // Jury's expected output\n\n    // Check line count consistency first\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each stripped line (already processed by read_file)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60699, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against jury's \n  expected output (participant_lines) line by line. Returns \n  true only if all lines match after whitespace trimming.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line for exact content match\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60684, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct answer (stdout.txt)\n  using input (stdin.txt) if needed. Return true for accepted, false for wrong.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Verify participant's output matches the expected answer line-by-line\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60704, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's solution by comparing:\n  - stdin_lines: problem input (corresponds to testlib's inf)\n  - participant_lines: contestant's output (corresponds to testlib's ouf)\n  - answer_lines: jury's correct output (corresponds to testlib's ans)\n  \n  Implements standard checker logic: compares participant's output \n  against jury's answer line-by-line after whitespace normalization.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> participant_lines = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Core validation logic translated from testlib approach:\n    // 1. Verify line count matches between participant and jury output\n    if (participant_lines.size() != answer_lines.size()) {\n        return false;\n    }\n\n    // 2. Compare each line (already whitespace-stripped by read_file)\n    for (size_t i = 0; i < answer_lines.size(); ++i) {\n        if (participant_lines[i] != answer_lines[i]) {\n            return false;\n        }\n    }\n\n    // Additional checks could use stdin_lines here if needed\n    // (e.g., verify output consistency with input constraints)\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60702, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against \n  expected answer (participant_lines). Returns true if identical.\n  Note: \n    - stdin_lines corresponds to problem input (inf)\n    - stdout_lines corresponds to contestant's output (ans)\n    - participant_lines corresponds to jury's answer (ouf)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: Check if contestant's output matches expected answer\n    // after both have been normalized (whitespace-trimmed per line)\n    return (stdout_lines == participant_lines);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60708, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct output (stdout_path).\n  Uses stdin_path for any input-dependent validation if needed.\n  Returns true if solution is valid, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if line counts match\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line between correct output and participant's output\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    // Additional input-dependent checks could be added here using stdin_lines\n    // (e.g., verify participant's output satisfies constraints from input)\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60718, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's answer (stdout.txt)\n  using input file (stdin.txt) for context if needed. Returns true if valid.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> inf_lines  = read_file(stdin_path);   // Corresponds to 'inf' in testlib\n    vector<string> ans_lines  = read_file(stdout_path);  // Corresponds to 'ans' (correct output)\n    vector<string> ouf_lines  = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic adapted from testlib-based checker:\n    // 1. Check line count matches between participant output and jury answer\n    if (ouf_lines.size() != ans_lines.size()) {\n        return false;\n    }\n\n    // 2. Perform line-by-line comparison (whitespace-trimmed)\n    for (size_t i = 0; i < ouf_lines.size(); ++i) {\n        if (ouf_lines[i] != ans_lines[i]) {\n            return false;\n        }\n    }\n\n    // 3. Additional problem-specific checks would go here\n    //    (e.g., verifying output format against input constraints from inf_lines)\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60717, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's answer (stdout.txt)\n  using line-by-line exact string comparison after trimming.\n  Input file (stdin.txt) is available for context if needed.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);  // Jury's expected output (ans)\n    vector<string> participant_lines = read_file(answer_path);  // Participant's output (ouf)\n\n    // Check if participant provided correct number of lines\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line exactly (after trimming done during file read)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    \n    // Note: stdin_lines (input test case) is available if validation logic\n    // requires context from the problem input (not needed for simple equality checks)\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";   // Corresponds to inf in testlib\n    const string stdout_path = \"stdout.txt\";  // Corresponds to ans in testlib\n    const string answer_path = \"answer.txt\";  // Corresponds to ouf in testlib\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60683, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compares participant's output (stdout_lines) against correct answer (participant_lines).\n  First checks line count equality, then performs exact string comparison on stripped lines.\n  Returns true only if all lines match exactly after whitespace normalization.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check line count mismatch (critical failure)\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content after whitespace stripping\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60681, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt).\n  Returns true if all lines match exactly after trimming whitespace,\n  false otherwise (including file reading errors or line count mismatch).\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: participant's output must exactly match judge's output\n    // (after standardizing line endings and whitespace trimming)\n    return (stdout_lines == participant_lines);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60680, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer_path) against correct answer (stdout_path).\n  Uses input file (stdin_path) if needed for context-specific validation.\n  Returns true if solution is accepted, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input test case)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (correct output)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Core validation logic: Check if participant's output matches expected answer\n    // after standardizing whitespace (already trimmed by read_file)\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;  // Different number of lines\n    }\n    \n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;  // Line content mismatch\n        }\n    }\n    \n    return true;  // All lines match\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60694, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) with correct answer (participant_lines).\n  Return true if they match exactly after trimming whitespace, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core comparison logic: participant's output must exactly match correct answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60674, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against expected answer by:\n  1. Checking line count matches\n  2. Verifying each line content matches exactly (after trimming)\n  Returns true for accepted solutions, false for rejected.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);   // Corresponds to 'inf' (input)\n    vector<string> stdout_lines      = read_file(stdout_path);  // Corresponds to 'ans' (expected output)\n    vector<string> participant_lines = read_file(answer_path);  // Corresponds to 'ouf' (participant's output)\n\n    // Verify line count matches expected output\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line content after trimming\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60693, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare contestant's output (stdout_lines) with the correct answer\n  (participant_lines) line by line after whitespace normalization.\n  Returns true if all lines match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Core validation logic: compare contestant's output against correct answer\n    // Note: stdin_lines is retained for potential future use with problem input\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;  // Different line counts  reject\n    }\n\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;  // Line mismatch  reject\n        }\n    }\n    return true;  // All lines match  accept\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60703, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against jury's answer (stdout.txt).\n  Returns true if both outputs match exactly after line trimming,\n  otherwise returns false.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);       // Corresponds to 'inf' (input file)\n    vector<string> stdout_lines      = read_file(stdout_path);      // Corresponds to 'ans' (jury's answer)\n    vector<string> participant_lines = read_file(answer_path);      // Corresponds to 'ouf' (participant's output)\n\n    // Verify line count matches between participant's output and jury answer\n    if (stdout_lines.size() != participant_lines.size()) {\n        return false;\n    }\n\n    // Perform line-by-line comparison (after trimming)\n    for (size_t i = 0; i < stdout_lines.size(); ++i) {\n        if (stdout_lines[i] != participant_lines[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60677, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (answer.txt) against correct output (stdout.txt)\n  Line-by-line exact string comparison after whitespace trimming.\n  Input file (stdin.txt) is available but unused in this basic comparison.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);      // Correct output (ans)\n    vector<string> participant_lines = read_file(answer_path);      // Participant's output (ouf)\n\n    // Check if line counts match\n    if (participant_lines.size() != stdout_lines.size()) {\n        return false;\n    }\n\n    // Compare each line exactly (after trimming)\n    for (size_t i = 0; i < participant_lines.size(); ++i) {\n        if (participant_lines[i] != stdout_lines[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60678, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Compare participant's output (stdout_lines) against correct answer \n  (participant_lines). Both have been stripped of whitespace. \n  Return true if they match exactly, false otherwise.\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> participant_lines = read_file(answer_path);\n\n    // Check if contestant's output matches the correct answer line-for-line\n    // after whitespace normalization. This replicates standard testlib.h \n    // checker behavior where ans (contestant) is compared against ouf (correct).\n    return (stdout_lines == participant_lines);\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
{"id": 60641, "checker": "#include <bits/stdc++.h>\n\n#define ll  long long\n#define all(x)  x.begin(), x.end()\n\nusing namespace std;\n\n/*-----------------------------------------------------------\n  Read an entire text file line-by-line into a vector<string>,\n  trimming leading/trailing whitespace (similar to str.strip()).\n-----------------------------------------------------------*/\nvector<string> read_file(const string& filepath)\n{\n    ifstream fin(filepath);\n    if (!fin.is_open()) {\n        cerr << \"Failed to open \" << filepath << '\\n';\n        return {};\n    }\n\n    vector<string> lines;\n    string line;\n\n    while (getline(fin, line)) {\n        // Strip leading / trailing whitespace.\n        auto l = line.find_first_not_of(\" \\t\\r\\n\");\n        auto r = line.find_last_not_of(\" \\t\\r\\n\");\n        if (l == string::npos) line.clear();\n        else                   line = line.substr(l, r - l + 1);\n\n        lines.push_back(line);\n    }\n    return lines;\n}\n\n/*-----------------------------------------------------------\n  Check if the participant's dice sequence is valid and compute the total sum.\n  Returns true if valid, and sets totalSum to the sum of dice values.\n  Validation:\n    - Add participant's dice as (m+1)th column\n    - For each row, find the dice that appears exactly once (winner)\n    - Verify the participant with most wins is the (m+1)th participant\n-----------------------------------------------------------*/\nbool checkAnswerAndGetTotalSum(const vector<vector<int>>& casinos, const vector<int>& dices, int testCase, long long& totalSum)\n{\n    int n = casinos.size();\n    int m = casinos[0].size() + 1;  // Original columns + participant's dice\n\n    // Create a copy of casinos with participant's dice added as new column\n    vector<vector<int>> casinos_with_dices = casinos;\n    for (int i = 0; i < n; i++) {\n        casinos_with_dices[i].push_back(dices[i]);\n    }\n\n    map<int, int> totalWinsByParticipant;\n\n    // Process each row to determine winner\n    for (int i = 0; i < n; i++) {\n        map<int, int> cnt;\n        for (int j = 0; j < m; j++) {\n            cnt[casinos_with_dices[i][j]]++;\n        }\n\n        int winnerDice = 0;\n        for (auto [x, y] : cnt) {\n            if (y == 1) {\n                winnerDice = x;\n                break;\n            }\n        }\n\n        if (winnerDice != 0) {\n            int indexWinnerDice = -1;\n            for (int j = 0; j < m; j++) {\n                if (casinos_with_dices[i][j] == winnerDice) {\n                    indexWinnerDice = j;\n                    break;\n                }\n            }\n            if (indexWinnerDice == -1) {\n                return false;  // Should not happen\n            }\n            totalWinsByParticipant[indexWinnerDice + 1]++;\n        }\n    }\n\n    // Find participant with most wins\n    int winnerIndex = 1;\n    for (const auto& entry : totalWinsByParticipant) {\n        if (entry.second > totalWinsByParticipant[winnerIndex]) {\n            winnerIndex = entry.first;\n        }\n    }\n\n    // Validate: winner must be the (m+1)th participant (participant's answer)\n    if (totalWinsByParticipant[winnerIndex] != totalWinsByParticipant[m]) {\n        return false;\n    }\n\n    // Calculate sum of participant's dice values\n    totalSum = 0;\n    for (int x : dices) {\n        totalSum += x;\n    }\n    return true;\n}\n\n/*-----------------------------------------------------------\n  Validate participant's output against judge's answer using file inputs.\n  Returns true if:\n    - Both judge's and participant's answers are valid\n    - Participant's dice sum equals judge's minimal sum\n  File structure:\n    - stdin.txt: T test cases (n, m, board)\n    - answer.txt: Judge's output (dice values for each test)\n    - stdout.txt: Participant's output (dice values for each test)\n-----------------------------------------------------------*/\nbool validate_solution(const string& stdin_path,\n                       const string& stdout_path,\n                       const string& answer_path)\n{\n    vector<string> stdin_lines       = read_file(stdin_path);\n    vector<string> stdout_lines      = read_file(stdout_path);\n    vector<string> answer_lines      = read_file(answer_path);\n\n    // Parse number of test cases\n    if (stdin_lines.empty()) return false;\n    int T = 0;\n    try {\n        T = stoi(stdin_lines[0]);\n    } catch (...) {\n        return false;\n    }\n    if (T <= 0) return false;\n\n    // Verify sufficient lines in answer and output files\n    if (answer_lines.size() < T || stdout_lines.size() < T) {\n        return false;\n    }\n\n    int current_line = 1;  // Start after T\n\n    for (int t = 1; t <= T; t++) {\n        // Parse n and m\n        if (current_line >= stdin_lines.size()) return false;\n        stringstream ss(stdin_lines[current_line++]);\n        int n, m;\n        if (!(ss >> n >> m) || n <= 0 || m <= 0) {\n            return false;\n        }\n\n        // Parse game board (n x m matrix)\n        vector<vector<int>> board(n, vector<int>(m));\n        for (int i = 0; i < n; i++) {\n            if (current_line >= stdin_lines.size()) return false;\n            stringstream ss_line(stdin_lines[current_line++]);\n            for (int j = 0; j < m; j++) {\n                if (!(ss_line >> board[i][j])) {\n                    return false;\n                }\n            }\n        }\n\n        // Parse judge's answer (n dice values)\n        vector<int> judge_dices(n);\n        stringstream ans_ss(answer_lines[t-1]);\n        for (int i = 0; i < n; i++) {\n            if (!(ans_ss >> judge_dices[i]) || \n                judge_dices[i] < 0 || \n                judge_dices[i] > 1000000000) {\n                return false;\n            }\n        }\n\n        // Parse participant's answer (n dice values)\n        vector<int> participant_dices(n);\n        stringstream ouf_ss(stdout_lines[t-1]);\n        for (int i = 0; i < n; i++) {\n            if (!(ouf_ss >> participant_dices[i]) || \n                participant_dices[i] < 0 || \n                participant_dices[i] > 1000000000) {\n                return false;\n            }\n        }\n\n        // Validate both solutions and compare sums\n        long long judge_sum = 0, participant_sum = 0;\n        if (!checkAnswerAndGetTotalSum(board, judge_dices, t, judge_sum)) {\n            return false;\n        }\n        if (!checkAnswerAndGetTotalSum(board, participant_dices, t, participant_sum)) {\n            return false;\n        }\n        if (judge_sum != participant_sum) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    const string stdin_path  = \"stdin.txt\";\n    const string stdout_path = \"stdout.txt\";\n    const string answer_path = \"answer.txt\";\n\n    bool is_valid = validate_solution(stdin_path, stdout_path, answer_path);\n    return is_valid ? 0 : 1;\n}", "success": true}
